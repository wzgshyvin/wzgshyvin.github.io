{"meta":{"title":"V1n","subtitle":"","description":"I have suffered and despaired and known death and I am glad that I am in this great world.","author":"V1n","url":"http://example.com","root":"/"},"pages":[{"title":"Friends","date":"2019-03-18T03:34:17.000Z","updated":"2021-01-26T11:24:10.683Z","comments":true,"path":"Friends/index.html","permalink":"http://example.com/Friends/index.html","excerpt":"","text":"结缘于ACMArya_Erin 玥玥Axiomofchoice hjt 永远滴神BearChild 天天CallmeChallenger 爬爬Chenboluo ct 前队友Chenfu1234 飞飞Codgician 张学长Colin 金牌学弟Culaccino cby 前队友Dddfaker 丁狗DeaphetS 叉哥Dreaming2019 小彭Edwiv 郑老师EricXia 夏宝Garvey 陆老师ILLLZKQF 施巨Jiedai 汤汤Kaizyn 凯凯K0u1e 燕宝MaJorieL 小任 我滴宝REXWind 小施Tommy1123 辣宝UniverseofHK 吉老师V4yne 彭老师Willingox 刘老师Zarathu 尹宝 来自Vidar-Team357 WebAnnevi WebBrownFly 飞哥Cosmos 阿C PwnCyris cy学长 Web 前端 美工Danis Jiang 蒋公子 BinE99p1ant 199 WebFeather 语宝Fl0a1e 峥宝Kevin Web 前端Matrix BinObjectNotFound MiscOyiadin oyyRin1ang 盛宝 WebRosetta 鱼宝Y 歪宝 Re 其他朋友AYang 小老弟Caesar BaoXiaoyuyu 楼哥"},{"title":"About","date":"2019-03-15T16:44:19.000Z","updated":"2019-03-20T16:14:48.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Man goes into the noisy crowd to drown his own clamour of silence. ——《Stray Birds》"},{"title":"tags","date":"2019-03-16T02:27:12.000Z","updated":"2019-03-16T13:00:52.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-16T02:26:48.000Z","updated":"2019-03-16T02:34:46.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"各种排序学习笔记","slug":"各种排序学习","date":"2021-01-27T07:11:59.000Z","updated":"2021-01-26T16:45:44.428Z","comments":true,"path":"2021/01/27/各种排序学习/","link":"","permalink":"http://example.com/2021/01/27/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/","excerpt":"因为学了冒泡后就会用 sort 了，完全没有学过各种排序，第一次面试因为不会手写快排 GG ，痛定思痛，决定认真写篇学习博客 QAQ","text":"因为学了冒泡后就会用 sort 了，完全没有学过各种排序，第一次面试因为不会手写快排 GG ，痛定思痛，决定认真写篇学习博客 QAQ 冒泡排序时间复杂度 $O(n^2)$ ，空间复杂度 $O(1)$ ，不断 swap 把大的排到后面，咕噜咕噜冒泡泡 123456789101112void BubbleSort(int *a,int len)&#123; for(int i=1;i&lt;len;++i)&#123; int ff(0); for(int j=0;j&lt;len-i;++j)&#123; if(a[j]&gt;a[j+1])&#123; swap(a[j],a[j+1]); ff++; &#125; &#125; if(!ff) break; // 小剪枝 &#125;&#125; 插入排序时间复杂度 $O(n^2)$ ，空间复杂度 $O(1)$ ，每次将新元素插入已排序的数组中。 12345void InsertSort(int *a,int len)&#123; for(int i=1;i&lt;len;++i) for(int j=i;j&gt;0;--j) if(a[j]&lt;a[j-1]) swap(a[j],a[j-1]);&#125; 选择排序时间复杂度 $O(n^2)$ ，空间复杂度 $O(1)$ ，每次将最值放在当前可操作的首位。 12345678void SelectSort(int *a,int len)&#123; for(int i=0;i&lt;len;++i)&#123; int mn=i; for(int j=i+1;j&lt;len;++j) if(a[j]&lt;a[mn]) mn=j; swap(a[i],a[mn]); &#125;&#125; 归并排序时间复杂度 $O(nlogn)$ ，空间复杂度 $O(n)$ ，递归，每次将要排序的子数组分成两个部分排序。 1234567891011121314151617void MergeSort(int *a,int l,int r)&#123; if(l&gt;=r) return; int mid=l+r&gt;&gt;1; MergeSort(a,l,mid); MergeSort(a,mid+1,r); int i=l,j=mid+1,tlen=l,tmp[maxn]; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(a[i]&lt;=a[j]) tmp[tlen++]=a[i++]; else tmp[tlen++]=a[j++]; &#125; while(i&lt;=mid) tmp[tlen++]=a[i++]; while(j&lt;=r) tmp[tlen++]=a[j++]; for(int i=l;i&lt;=r;++i) a[i]=tmp[i];&#125;void solve()&#123; MergeSort(a,0,len-1); &#125; 快速排序时间复杂度 $O(nlogn)$ ，空间复杂度 $O(logn)$ ，每次找一个比较合适的 pivot ，根据这个值对数组进行调整。 123456789101112131415161718192021int findmiddle(int a,int b,int c)&#123; int tmp=a^b^c; int mx=max(&#123;a,b,c&#125;); int mn=min(&#123;a,b,c&#125;); return tmp^mx^mn;&#125;void QuickSortAdjust(int *a,int l,int r)&#123; if(l&gt;=r) return; int pivot=findmiddle(a[l],a[r],a[l+r&gt;&gt;1]); int i=l,j=r; while(i&lt;=j)&#123; while(i&lt;=j&amp;&amp;a[i]&lt;pivot) i++; while(i&lt;=j&amp;&amp;a[j]&gt;pivot) j--; if(i&lt;=j) swap(a[i++],a[j--]); &#125; QuickSortAdjust(a,l,j); QuickSortAdjust(a,i,r);&#125;void QuickSort(int *a,int len)&#123; QuickSortAdjust(a,0,len-1);&#125; 堆排序时间复杂度 $O(nlogn)$ ，空间复杂度 $O(1)$ ，每次对无序的子数组进行堆调整，将最值置于堆顶，然后把最值移到数组末尾，再对剩下的子数组进行操作。 1234567891011121314151617181920212223242526272829303132void HeapAdjust(int *a,int len)&#123; for(int i=len-1;i&gt;0;--i)&#123; if((i&amp;1)&amp;&amp;(a[i]&gt;a[i/2])) swap(a[i],a[i/2]); else if(!(i&amp;1)&amp;&amp;(a[i]&gt;a[i/2-1])) swap(a[i],a[i/2-1]); &#125;&#125;void HeapSort(int *a,int len)&#123; while(len)&#123; HeapAdjust(a,len--); swap(a[0],a[len]); &#125;&#125;// 加速版void _HeapAdjust(int *a,int x,int len)&#123; int fa=x,son=(fa&lt;&lt;1)|1; while(son&lt;len)&#123; if(son+1&lt;len&amp;&amp;a[son]&lt;a[son+1]) son++; // 哪个小孩 if(a[fa]&gt;=a[son]) break; swap(a[fa],a[son]); fa=son; son=(fa&lt;&lt;1)|1; &#125;&#125;void _HeapSort(int *a,int len)&#123; for(int i=(len&gt;&gt;1)-1;i&gt;=0;--i) _HeapAdjust(a,i,len); for(int i=len-1;i&gt;=0;--i)&#123; swap(a[0],a[i]); _HeapAdjust(a,0,i); &#125;&#125; 桶排序时间复杂度 $O(n+k)$ ，空间复杂度 $O(n+k)$ ，将元素放进桶里，按桶的大小取出。 12345678910void BucketSort(int *a,int len)&#123; int vis[maxn]=&#123;0&#125;; // 值域 for(int i=0;i&lt;len;++i)&#123; vis[a[i]]++; &#125; int cnt(0); for(int i=0;i&lt;maxn;++i)&#123; while(vis[i]) vis[i]--,a[cnt++]=i; &#125;&#125; 基数排序时间复杂度 $O(n*k)$ ，空间复杂度 $O(n+k)$ 。两种：一种（LSD）从低位到高位放进桶里（每次 10 个）。一种（MSD）从高位到低位放进桶里，一位处理完后，直接在当前桶里分下一位的类。复杂度略高而且代码过长，感觉能嘴就行 233","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"抑郁小记","slug":"抑郁小记","date":"2020-06-28T07:08:01.000Z","updated":"2021-01-26T16:43:57.879Z","comments":true,"path":"2020/06/28/抑郁小记/","link":"","permalink":"http://example.com/2020/06/28/%E6%8A%91%E9%83%81%E5%B0%8F%E8%AE%B0/","excerpt":"都会好起来的","text":"都会好起来的 为什么突然就抑郁了？硬要解释的话，去年十月就有点苗头了，疫情期间长期在家过于压抑，集训队和课业的压力也很大，还有一些我不想多提的事，种种事情堆积在一起从而造成的这种结果吧。我也不想嘛。可以算是突发，有一天早上睁眼突然丧失了对各种美好追求的兴趣，而前一天我还状态很好地在训练。抑郁时候我都干了什么？除了消磨时间的不务正业，还有身体本能的训练。3.10我在cf的题数刚好达到300，现在快到500，中间有三次紫的机会，一次开小号翻车了（对不起对不起对不起）但其实也全是1A，一次和晚课冲突小号打了四题，一次就普普通通地紫了。虽然我怯弱、畏缩、心思不定，但我还是有可能性。期间喜欢上了小马，听着他的直播会很安心，反之如果有事听不了会很焦虑。平时听他的歌、听他听的歌、看他做的视频，现在电脑桌面和手机壁纸也全是他，老追星了233。可以懂这一种心理寄托吧，喜欢终归是很正面的情绪。和zxj又恢复了很好的关系，虽然本身就是很适合当朋友的人233。后期的调节和他们关系也很大。虽然都看不到。但还是。谢谢谢谢。分手是决定了很久的。给他两三次机会了吧，因为是一个很怕麻烦的人，也很心软的人。最后深夜理抑郁时间线的时候还是绷不住，我觉得我该对我自己好一点，就提了分手。同理在一起也是决定了很久的，没有随随便便，曾经也给了我很多正面影响。谁没有真情实感过呢，恋爱就这。感谢小任同学给我的药和给我的鼓励。感谢情感问题调节大师盛宝。还有请我吃仟诚和鲜芋仙的xy。还有总是劝我去看病但是总气我的歪宝和可可爱爱妹有脑袋的燕宝。还有列表各个朋友给我发的话和小作文。社交达到这个程度很开心了233。还在家的时候感觉太闷了就会出去玩，老调节情绪了。和媳妇儿去逛街，去吃吃喝喝，去江边吹泡泡，拍照发空间。真的在努力康复啊。之前在实验室呆着的时候有非常严重的焦虑，借机把队服画了。说实话，在工设还是压力很大且毫无解决办法，希望小转没事。下学期想和老师谈判一波，希望小转没事。要是挂了我大四还得修，再修再挂也没啥意思吧，那还是一样的水，干嘛不一次给我过了是吧，希望小转没事。“我只是想追求我的前途。我的前途不在工业设计。”逼逼赖赖到不知道说啥了。小转很棒小转该有光明的前途的。小转还没好全小转也不知道能不能好。千言万语汇成一句话：希望小转没事🙏。","categories":[{"name":"w&y","slug":"w-y","permalink":"http://example.com/categories/w-y/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"心心奇怪素材网站收集","slug":"心宝网站素材","date":"2020-06-27T15:08:01.000Z","updated":"2021-01-26T16:43:45.583Z","comments":true,"path":"2020/06/27/心宝网站素材/","link":"","permalink":"http://example.com/2020/06/27/%E5%BF%83%E5%AE%9D%E7%BD%91%E7%AB%99%E7%B4%A0%E6%9D%90/","excerpt":"努力当一个好美工？","text":"努力当一个好美工？ 文章头图来源 背景素材光球线条炫光渐变层液态流体背景生成发散光线花里胡哨举牌小人老黑客了生成代码图片 PNG 素材配色参考配色配色配色自由选色渐变配色板块配色日本传统色 图片处理双色图片故障艺术","categories":[{"name":"y","slug":"y","permalink":"http://example.com/categories/y/"}],"tags":[{"name":"素材","slug":"素材","permalink":"http://example.com/tags/%E7%B4%A0%E6%9D%90/"}]},{"title":"wz刷题汇总","slug":"wz刷题汇总","date":"2020-03-25T05:28:38.000Z","updated":"2021-02-22T14:03:32.096Z","comments":true,"path":"2020/03/25/wz刷题汇总/","link":"","permalink":"http://example.com/2020/03/25/wz%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"个人刷题记录（不完全）","text":"个人刷题记录（不完全） cf-contests存一些让我再写不一定写得来的或者我可能去扒原题的?1202D d3线下想的数学题1214D dfs可以搞 两次dfs 第一次把走过的路堵上(“D不是dinic板子题?”)1217B 是我最讨厌的打怪兽 但是做太多这种了… 要特判一次打死(wcy赛时四题睡前三题醒来两题那场)1209D 奇怪的并查集1220B 每个ans[i]为sqrt(a[i][j]*a[i][k]/a[j][k])1221D dp 增高栏杆使没有相同高度 只可能增0121251C a[i]和a[j]奇偶性不同可以交换 问字典序最小 奇偶分别存一个数组里 sort 然后贪心输出1252H 这b卡double精度1256A-F 自己博客1257D 贪心打怪兽1253D dfs求每个点能到mn和mx 再for一遍补1265A-E 自己博客…1295C 我最怕的二分题 多次选s的子序列加起来使最后结果等于t 问最少几次 开个cnt[26][maxn]去二分1295D 问有多少0&lt;=x&lt;=m-1%%gcd(a,m)==gcd(a+x,m) 结论题 求gcd(a,m)的phi1300E 任意选区间使区间中所有数变成区间平均数 问字典序最小什么样 贪心+算不算单调栈? for一下遇到小的就去和前面的平均1301D 自己博客1303C dfs 给你s问有没有合适的单行键盘序列使每次按都只用移一格1303D 袋子容量n 给你m个2^ki的物体 问最少拆几次能填满1304D 构造 给你&lt;和&gt;代表数组递增或者递减 求LIS的最小/最大情况 最小情况就增得少减得多 最大反过来 离散化后就是答案1305E 构造 递增数列且刚好k个三元组(i,j,k)满足ai+aj=ak1307D 加一条边使加后的1到n最短路最长 跑一遍所有点到1/n的最短路 根据差值排序 然后for1311D 暴力枚举 范围是坑 给abc问最少加减一次使b%a==0&amp;&amp;c%b==01312E 区间dp 两项相邻的相同可以合并成一项比原来大1的值 问最少剩下1315D 奇怪的并查集 根据时间大到小sort 并查集判点是否出现过1316D 带模拟1316E 状压dp 每个人可以选两种身份 贡献是a和b 选p个1身份和k个2身份的人使总贡献最大1321A-D 自己博客1326D2 自己博客1327D 置换群 给p找最小k使p^k存在颜色相同的环 找环后枚举因数再枚举所在环是不是颜色相同 cf-strings/hashing5C 常见括号匹配 单调栈板子题7D 自己博客8A implementation 题意有点难懂 正着find倒着find就完了25E kmp/hash板子题 多个串省略重复地相连31B implementation+greedy?合法只要是两个@相差2 注意首尾34C 断句题 断完了就implementation39J 给定串s和t 问s能不能删一个字符得到t hash完了for一下58D sort题 sort完暴力找匹配70B 恶心人的题 带模拟75B 断句+sort 模拟就完了432D kmp预处理后o1查某个前缀出现几次471D 差分后kmp一遍526D kmp 很考对nex的理解?985F 给出串s 每次询问以x和y为起点长度len的s子串字符能否形成一一映射 hash[maxn][26]记录 每次求出两个段每个字符的hash值 sort完一一比较1200E 字符串合并 hash/kmp板子1204D2 比较精妙的构造? cf-string suffix structures19C 自己博客123D 求所有子串出现次数和 sam板子128B 求第k小字典序子串的sa/sam板子 cf-geometry1C 海伦公式+正弦定理+余弦定理+double求gcd14C 给四个线段问能不能组成矩形 记个数18A 给三个点问能不能组成或者移一个点组成直角三角形 forforfor183B 这才1700?虽然是n3暴力190B 求和两个圆相切的圆的半径 cf-number theory7C exgcd10C 求出每位数有几个 然后加上所有组合 再扣掉合法组合16C 就这?没有binary search 所谓number theory只是gcd罢了17A 问2-n有几个符合题意的数 筛出素数然后暴力17D 十进制ksm板子题26A 就这2400?暴力完事27E 反素数板子题45G 哥德巴赫猜想(一个偶数为两个质数相加)?先判单色 枚举质数看能不能双色 不能的话肯定是奇数 -3 剩下的再枚举55D 数位dp+离散化 dp开[20][48][2520] 2520是1-9的lcm 有48个因数 对每个lcm离散化 搜到最后合法情况就是mod%lcm==066D 简单构造71C 枚举i到n/3(三角形) 每个n%i==0判合不合法73E 有1选1 没1选n内所有质数(不包含) 太大特判75C 求完gcd因数对于每个询问查找 暴力就行74C 很玄学反正求个gcd就没了78C 单根木头能分解并且木头总数是奇数 先手胜 pta-problemsetL1-064 自己博客 猛男带模拟 hdoj-problemset1439 置换群 找环记录环长 每次跳k余当前位所在环长次后的位置赋值si2838 树状数组 记录逆序对数和前缀和 每次存在逆序对的时候累加2486 k倍博弈板子1402 大数相乘 fft板子 Java快读板子2065 递推 推不出具体公式能找规律 循环节为204609 fft板子 通过fft算出所有两个数和的可能个数(?表述可能不是很清 想不起来可以看kuangbin博客) 减去选相同的 再总方案减可以构成三角形的1403 sa/sam板子 lcs","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"},{"name":"pintia","slug":"pintia","permalink":"http://example.com/tags/pintia/"},{"name":"hdoj","slug":"hdoj","permalink":"http://example.com/tags/hdoj/"}]},{"title":"Codeforces 1326D2. Prefix-Suffix Palindrome (Hard version)","slug":"Codeforces-1326D2","date":"2020-03-19T22:37:40.000Z","updated":"2021-01-26T16:40:49.713Z","comments":true,"path":"2020/03/20/Codeforces-1326D2/","link":"","permalink":"http://example.com/2020/03/20/Codeforces-1326D2/","excerpt":"比赛睡过去了=。=更一下D2的各种写法","text":"比赛睡过去了=。=更一下D2的各种写法 题目链接manacher hash pam都能搞upd:kmp也行思路还是比较清晰的先把原串分为三部分：前缀 后缀 中间比如acbba 分成a+cbb+a然后对中间这个部分找最长的以0开头或者以len-1结尾的回文串答案就是前缀+最长回文串+后缀 manacher1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;int che[2*maxn];string s,ma;void manacher(string s,int len0)&#123; ma=&quot;$#&quot;; rep(i,0,len0) ma+=s[i],ma+=&#x27;#&#x27;; // 别写成ma+=s[i]+&#x27;#&#x27;;了 换成&quot;#&quot;应该就行 呜呜呜血泪教训 int maxx=0,num=0,len=ma.size(); rep(i,0,len)&#123; che[i]=maxx&gt;i?min(che[2*num-i],maxx-i):1; while(ma[i+che[i]]==ma[i-che[i]]) che[i]++; if(i+che[i]&gt;maxx) maxx=i+che[i],num=i; &#125;&#125;void solve()&#123; cin&gt;&gt;s; int l=0,r=s.size()-1; while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); manacher(s,s.size()); int len=ma.size(),p(0),q(0),r1(0),r2(0); rep(i,0,len) if(p&lt;che[i]&amp;&amp;i-che[i]&lt;2) p=che[i],r1=i; dep(i,len-1,0) if(q&lt;che[i]&amp;&amp;i+che[i]==len) q=che[i],r2=i; // 这部分比较考对manacher数组的熟练?hhh自己手写一下应该就行 if(p&gt;=q) cout&lt;&lt;t1+s.substr(0,p-1)+t2&lt;&lt;&#x27;\\n&#x27;; else cout&lt;&lt;t1+s.substr(s.size()-q+1)+t2&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; hash还是seed和mod不公开 虽然我这次没有用常用的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;string s; int n;int seed,mod,hs1[maxn],hs2[maxn],bas[maxn]; // hs看情况开void init(int* hs)&#123; s=&#x27; &#x27;+s; bas[0]=1; rep(i,1,n+1)&#123; bas[i]=1ll*bas[i-1]*seed%mod; hs[i]=1ll*hs[i-1]*seed%mod+s[i]; if(hs[i]&gt;=mod) hs[i]-=mod; &#125; &#125;int getsum(int *h,int l,int r)&#123; int res=h[r]-1ll*h[l-1]*bas[r-l+1]%mod; if(res&lt;0) res+=mod; return res;&#125;void hash_init()&#123; seed=?,mod=?; init(hs1); reverse(s.begin(),s.end()); init(hs2);&#125;void solve()&#123; cin&gt;&gt;s; int l=0,r=s.size()-1,p(0),q(0); while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); n=s.size(); hash_init(); rep(i,1,n+1) if(getsum(hs1,1,i/2)==getsum(hs2,n-i+1,n-(i+1)/2)) p=i; rep(i,1,n+1) if(getsum(hs2,1,i/2)==getsum(hs1,n-i+1,n-(i+1)/2)) q=i; if(p&gt;q)&#123; reverse(s.begin(),s.end()); // 现在的s是&#x27; &#x27;+s+&#x27; &#x27; 所以要从1开始 cout&lt;&lt;t1+s.substr(1,p)+t2&lt;&lt;&#x27;\\n&#x27;; &#125; else cout&lt;&lt;t1+s.substr(1,q)+t2&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; pam呜呜呜好难啊pam好难 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;string s;struct PAM&#123; struct node&#123; int child[26],cnt,fail,num,len,pos; &#125;tt[maxn]; int last,n,tot; char s[maxn]; inline void clear()&#123; rep(i,0,tot+1)&#123; mst(tt[i].child,0); tt[i].cnt=tt[i].fail=tt[i].len=tt[i].num=tt[i].pos=0; &#125; last=n=0; tt[0].fail=tot=1; tt[1].len=-1; &#125; inline int getfail(int x)&#123; while(s[n-tt[x].len-1]!=s[n]) x=tt[x].fail; return x; &#125; inline void add(char ch)&#123; s[n]=ch; int cur=getfail(last); if(!tt[cur].child[ch-&#x27;a&#x27;])&#123; int now=++tot; tt[now].len=tt[cur].len+2; int p=getfail(tt[cur].fail); tt[now].fail=tt[p].child[ch-&#x27;a&#x27;]; tt[cur].child[ch-&#x27;a&#x27;]=now; tt[now].num=tt[tt[now].fail].num+1; &#125; last=tt[n].pos=tt[cur].child[ch-&#x27;a&#x27;]; ++tt[last].cnt; ++n; &#125; inline void count()&#123; dep(i,tot,0) tt[tt[i].fail].cnt+=tt[i].cnt; &#125;&#125;pam;int getpos(int n,int l,int r)&#123; int t=pam.tt[r].pos; while(l*2+pam.tt[t].len&gt;n) t=pam.tt[t].fail; return pam.tt[t].len;&#125;void solve()&#123; cin&gt;&gt;s; int l=0,r=s.size()-1,n=s.size(),p(0),q(0); while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; pam.clear(); dep(i,n-1,0) pam.add(s[i]); p=getpos(n,l,r); reverse(s.begin(),s.end()); pam.clear(); dep(i,n-1,0) pam.add(s[i]); q=getpos(n,l,r); reverse(s.begin(),s.end()); if(max(p,q)+2*l&gt;=n) cout&lt;&lt;s&lt;&lt;&#x27;\\n&#x27;; else if(p&gt;q) cout&lt;&lt;s.substr(0,p+l)+s.substr(r+1)&lt;&lt;&#x27;\\n&#x27;; else cout&lt;&lt;s.substr(0,l)+s.substr(r-q+1)&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; kmp12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e6 + 5;int nex[maxn];int getnext(string s)&#123; int i=0,j=-1,len=s.size(); nex[0]=-1; while(i&lt;len)&#123; if(j==-1||s[i]==s[j])&#123; i++; j++; nex[i]=j; &#125; else j=nex[j]; &#125; return nex[len];&#125;void solve()&#123; string s,t; cin&gt;&gt;s; int l=0,r=s.size()-1; while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); t=s; reverse(t.begin(),t.end()); string a=s+&#x27;*&#x27;+t,b=t+&#x27;*&#x27;+s; string p=a.substr(0,getnext(a)); string q=b.substr(0,getnext(b)); cout&lt;&lt;t1&lt;&lt;(p.size()&gt;q.size()?p:q)&lt;&lt;t2&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"Codeforces 19C. Deletion of Repeats","slug":"Codeforces-19C","date":"2020-03-17T04:27:40.000Z","updated":"2021-01-26T16:39:14.996Z","comments":true,"path":"2020/03/17/Codeforces-19C/","link":"","permalink":"http://example.com/2020/03/17/Codeforces-19C/","excerpt":"事情为什么会发展成这样.jpg","text":"事情为什么会发展成这样.jpg 题目链接一开始感觉是求最短不包含重复段的后缀 卡了好久qwq 后来发现forfor就完事了本来想写sa hash 暴力三种写法的 结果写完暴力发现比sa还快 瞬间索然无味 我写sa干嘛呢离散化一下然后枚举就行 就当复习sa了555 后缀数组248 ms 25400 KB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int s[maxn];int sa[maxn],rk[maxn];int height[maxn];int t1[maxn],t2[maxn],c[maxn];int best[20][maxn];int a[maxn],b[maxn];vector&lt;int&gt;vv[maxn];void getsa(int *s,int n,int m)&#123; int *x=t1,*y=t2; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[i]=s[i]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[i]]]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p=0; rep(i,n-k,n) y[p++]=i; rep(i,0,n) if(sa[i]&gt;=k) y[p++]=sa[i]-k; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[y[i]]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[y[i]]]]=y[i]; swap(x,y); p=1; x[sa[0]]=0; rep(i,1,n) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++; if(p&gt;=n) break; m=p; &#125;&#125;void getheight(int n)&#123; int k=0; rep(i,1,n+1) rk[sa[i]]=i; rep(i,0,n)&#123; if(k) k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k]) k++; height[rk[i]]=k; &#125;&#125;void RMQ(int n)&#123; int lg=(int)(log(n*1.0)/log(2.0)); rep(i,1,n+1) best[0][i]=height[i]; rep(i,1,lg+1) for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++) best[i][j]=min(best[i-1][j],best[i-1][j+(1&lt;&lt;i&gt;&gt;1)]); &#125;int lcp(int x,int y)&#123; x=rk[x]; y=rk[y]; if(x&gt;y) swap(x,y); x++; int lg=(int)(log(1.0*(y-x+1))/log(2.0)); return min(best[lg][x],best[lg][y-(1&lt;&lt;lg)+1]);&#125; // 贴板子struct node&#123; int l,r,len; &#125;p[maxn*10]; // 十倍是因为题目的&quot;保证重复不过十次&quot;int cmp(node a,node b)&#123; return a.len&lt;b.len||a.len==b.len&amp;&amp;a.l&lt;b.l; &#125; // 按题意sortint solve()&#123; int n,cnt(0),ans(0); sc(n); rep(i,0,n) sc(a[i]),b[i]=a[i]; sort(b,b+n); int bn=unique(b,b+n)-b; rep(i,0,n)&#123; s[i]=lower_bound(b,b+bn,a[i])-b+1; vv[s[i]].push_back(i); &#125; getsa(s,n+1,maxn); getheight(n); RMQ(n); rep(i,0,maxn) rep(j,0,vv[i].size()) rep(k,j+1,vv[i].size())&#123; if(vv[i][k]-vv[i][j]&gt;n-vv[i][k]) continue; if(vv[i][k]-vv[i][j]&lt;=lcp(vv[i][j],vv[i][k])) p[cnt++]=&#123;vv[i][j],vv[i][k],vv[i][k]-vv[i][j]&#125;; // 只要算一下这一段是不是重复的就可以 改成hash也差不多 &#125; sort(p,p+cnt,cmp); rep(i,0,cnt) if(p[i].l&gt;=ans) ans=p[i].r; pf(&quot;%d\\n&quot;,n-ans); rep(i,ans,n) pf(&quot;%d &quot;,a[i]); return 0;&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; 暴力186 ms 5000 KB思路差不多的 不过算是优化了一下qwq 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;map&lt;int,int&gt;aaa;vector&lt;int&gt;vv[maxn];int a[maxn],q[maxn];int solve()&#123; int n,cnt(0),ans(0); sc(n); rep(i,0,n)&#123; sc(a[i]); if(!aaa.count(a[i])) aaa[a[i]]=++cnt; q[i]=aaa[a[i]]; vv[aaa[a[i]]].push_back(i); &#125; rep(i,0,n) for(auto x:vv[q[i]])&#123; if(x&gt;=i) break; if(i-x&gt;n-i||x&lt;ans) continue; int ff(0); rep(j,0,i-x) if(a[i+j]!=a[x+j])&#123; ff++; break; &#125; if(!ff)&#123; ans=i; break; &#125; &#125; pf(&quot;%d\\n&quot;,n-ans); rep(i,ans,n) pf(&quot;%d &quot;,a[i]);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; upd:ylh把我暴力卡了 更没意思了数据: 1234567#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int main()&#123; cout&lt;&lt;100000&lt;&lt;&#x27;\\n&#x27;; rep(i,0,10) rep(j,0,10000) cout&lt;&lt;(j==9999?10001+i:j+1)&lt;&lt;&#x27;\\n&#x27;;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"Codeforces 7D. Palindrome Degree","slug":"Codeforces-7D","date":"2020-03-11T05:27:40.000Z","updated":"2021-01-26T16:39:08.071Z","comments":true,"path":"2020/03/11/Codeforces-7D/","link":"","permalink":"http://example.com/2020/03/11/Codeforces-7D/","excerpt":"最近在写string 这题manacher和hash各写了一遍","text":"最近在写string 这题manacher和hash各写了一遍 题目链接乍一看以为是pam 后来发现pam写不了233 不然要写三种的只要根据dp[i]=dp[i/2]+1;来推就行了 思路还是比较清晰的qwq manacher1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e6 + 5;char s[maxn],ma[2*maxn];int che[2*maxn],ww[2*maxn];void manacher(char* s,int len0)&#123; int len=0; ma[len++]=&#x27;$&#x27;; ma[len++]=&#x27;#&#x27;; rep(i,0,len0) ma[len++]=s[i],ma[len++]=&#x27;#&#x27;; ma[len]=0; int maxx=0,num=0; rep(i,0,len)&#123; che[i]=maxx&gt;i?min(che[2*num-i],maxx-i):1; while(ma[i+che[i]]==ma[i-che[i]]) che[i]++; if(i+che[i]&gt;maxx) maxx=i+che[i],num=i; &#125;&#125;void solve(int len)&#123; ll ans(0); rep(i,1,len+1)&#123; int l=2,r=2*i,m=l+r&gt;&gt;1; if(che[m]*2&gt;r-l+1) ww[r]=ww[m-1-(m-1)%2]+1; ans+=ww[r]; &#125; pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; scs(s); int len=strlen(s); manacher(s,len); solve(len);&#125; hash我的hash常数很大啊 抠抠才过还是seed和mod不公开了吧qwq 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e6 + 5;char s[maxn]; int n;struct haash&#123; int seed,mod,hs[maxn],bas[maxn]; // hs看情况开 void init()&#123; bas[0]=1; rep(i,1,n+1)&#123; bas[i]=1ll*bas[i-1]*seed%mod; hs[i]=1ll*hs[i-1]*seed%mod+s[i]; if(hs[i]&gt;=mod) hs[i]-=mod; &#125; &#125; int getsum(int *h,int l,int r)&#123; int res=h[r]-1ll*h[l-1]*bas[r-l+1]%mod; if(res&lt;0) res+=mod; return res; &#125;&#125;hh[2];void hash_init()&#123; hh[0].seed=?,hh[0].mod=?; hh[0].init(); reverse(s+1,s+n+1); hh[1].seed=?,hh[1].mod=?; hh[1].init();&#125;int ww[maxn];void solve()&#123; ll ans=1; ww[1]=1; rep(i,2,n+1)&#123; if(hh[0].getsum(hh[0].hs,1,i/2)==hh[1].getsum(hh[1].hs,n-i+1,n-(i+1)/2)) ww[i]=ww[i/2]+1; ans+=ww[i]; &#125; pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; scs(s+1); n=strlen(s+1); hash_init(); solve();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"Codeforces Round #625解题报告","slug":"Codeforces-Round-625解题报告","date":"2020-03-02T01:42:16.000Z","updated":"2021-01-26T16:41:08.395Z","comments":true,"path":"2020/03/02/Codeforces-Round-625解题报告/","link":"","permalink":"http://example.com/2020/03/02/Codeforces-Round-625%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"记录丢人点滴","text":"记录丢人点滴 虽然真的很丢人 但是看了一下大家代码发现我至少代码还是短(? A: Contest for Robots题目链接题意：两种机器人对于n个问题有会和不会(1和0) 希望第一种的得分比第二种高 要如何安排问题分数分布 要求分数中最大的尽量小算一下第一种比第二种多的1和0 除一下可能会除零 要先判掉再除 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[105],b[105];int main()&#123; int n,c1(0),c2(0); sc(n); rep(i,0,n) sc(a[i]); rep(i,0,n)&#123; sc(b[i]); if(a[i]==b[i]) continue; else if(a[i]&gt;b[i]) c1++; else c2++; &#125; if(!c1) return pf(&quot;-1\\n&quot;),0; int ans=(c2+c1)/c1; pf(&quot;%d\\n&quot;,ans&gt;0?ans:0);&#125; B: Journey Planning题目链接题意：希望选择b的总和尽量大且满足选中的bi,bj有i-j==bi-bj每个b去减去i 找相同的数组存的话加上n也行 但是map就是香啊要ll 赛时比较草率qwq 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;#define int lltypedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[maxn];map&lt;int,int&gt;ans;signed main()&#123; int n,mx(0); sc(n); rep(i,1,n+1)&#123; sc(a[i]); int t=a[i]-i; ans[t]+=a[i]; &#125; for(auto&amp; x:ans) mx=max(mx,x.second); pf(&quot;%lld\\n&quot;,mx);&#125; C: Remove Adjacent题目链接题意：给一个字符串 对于每个字符 如果相邻字符有ascii码刚好比自己少1的 则可以删除 问最多能删多少个枚举z到a 每次for一遍删 O(26*n^3) 1234567891011#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;int main()&#123; ios::sync_with_stdio(0); int n,cnt(0); string s; cin&gt;&gt;n&gt;&gt;s; s+=&#x27; &#x27;; dep(k,25,1) rep(i,0,n) if(s[i]==k+&#x27;a&#x27;)&#123; if(s[i+1]==s[i]-1||(i&amp;&amp;s[i-1]==s[i]-1)) s.erase(i,1),n--,cnt++,i=i?i-2:-1; &#125; cout&lt;&lt;cnt;&#125; D: Navigation System题目链接题意：高德地图持续为您规划路线n个点m条边的有向无权图 给k个点是必须经过的 导航每次路线会选择最短路 如果不是最短路就rebuild重新找最短路 问rebuild的最少和最多次数无权图 bfs/dij/spfa啥的都行qwq判是不是最短路用dis就行mx和mn就差在有多条最短路的时候 这时候记一下就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;struct node&#123; int id,dt; bool operator &lt; (const node a) const&#123; return dt&gt;a.dt; &#125;&#125;;priority_queue&lt;node&gt;q;int n,m,k,s,t,tot;int dis[maxn],vis[maxn],head[maxn],cnt[maxn];int nex[maxn&lt;&lt;1],to[maxn&lt;&lt;1],val[maxn&lt;&lt;1];void addedge(int u,int v,int w)&#123; nex[++tot]=head[u]; head[u]=tot; to[tot]=v; val[tot]=w;&#125;void dij(int s)&#123; rep(i,1,n+1) dis[i]=1e9; dis[s]=0; q.push(&#123;s,0&#125;); while(!q.empty())&#123; int fr=q.top().id; q.pop(); if(vis[fr]) continue; vis[fr]++; for(int j=head[fr];j;j=nex[j]) if(dis[to[j]]&gt;val[j]+dis[fr]&amp;&amp;!vis[to[j]])&#123; dis[to[j]]=val[j]+dis[fr]; q.push(&#123;to[j],dis[to[j]]&#125;); &#125; else if(dis[to[j]]==val[j]+dis[fr]) cnt[to[j]]=1; &#125;&#125; // 板子闭着眼一套int p[maxn];int main()&#123; int mn(0),mx(0); sc(n); sc(m); while(m--)&#123; int u,v; sc(u); sc(v); addedge(v,u,1); &#125; sc(k); rep(i,1,k+1) sc(p[i]); dij(p[k]); rep(i,1,k+1)&#123; if(i!=k&amp;&amp;dis[p[i]]!=dis[p[i+1]]+1) mn++; else mx+=cnt[p[i]]; &#125; pf(&quot;%d %d\\n&quot;,mn,mn+mx);&#125; E: World of Darkraft: Battle for Azathoth题目链接补了加qwq","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"稳赚迷惑代码集","slug":"稳赚迷惑代码集","date":"2020-03-01T08:55:33.000Z","updated":"2021-01-26T16:43:38.925Z","comments":true,"path":"2020/03/01/稳赚迷惑代码集/","link":"","permalink":"http://example.com/2020/03/01/%E7%A8%B3%E8%B5%9A%E8%BF%B7%E6%83%91%E4%BB%A3%E7%A0%81%E9%9B%86/","excerpt":"自黑向 长期更新","text":"自黑向 长期更新 事情的起因是打了一场很丢人的周赛 赛后看自己代码说了一句 我赛时代码可以入选稳赚迷惑代码集了 好 说搞就搞从小到大好像为ACM哭得最多了 打个cf没打好觉得自己好笨 哭 暑假选拔以为自己没进 哭 发现被保送了 哭得更历害了… 知道自己这赛季没比赛时候忘了哭没哭了 反正过了很低谷的一段时间 还有一队ec亚军 我哭得好大声…稳赚笨笨的 学东西很慢 手速很慢 思路很容易被卡 一点点没发挥好就容易整场打崩 简直是队里蛀虫(确信 迷惑*1不知道在干嘛 多整了一个明明能用i判断的f 1rep(i,0,t) pf(&quot;%c&quot;,(f?&#x27;z&#x27;:&#x27;a&#x27;)),f^=1; 迷惑*21ans=ans*min(a[i],(n-i)%mod); 迷惑*31int n,l=0,r=n+1; sc(n); 迷惑*4CF1283C这也能过?.jpg假假地倒着for一遍这个是又菜又牛逼吧(?翻了一下大家的写的都挺长的(小声bb 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;const int maxn = 2e5 + 5;int a[maxn],b[maxn],v[maxn];int main()&#123; int n,t=-1,pos=1,tp=0,tp2=0; sc(n); rep(i,1,n+1) sc(a[i]),v[a[i]]++; dep(i,n,1) if(a[i]) b[i]=a[i]; else&#123; if(t!=-1)&#123; b[i]=t; t=-1; continue; &#125; rep(j,pos,n+1) if(!v[j]&amp;&amp;j==i) t=j,tp2=i; else if(!v[j]&amp;&amp;j!=i)&#123; b[i]=j; v[j]++; pos=j; tp=i; break; &#125; &#125; if(t!=-1) b[tp2]=b[tp],b[tp]=t; rep(i,1,n+1) pf(&quot;%d &quot;,b[i]);&#125; 迷惑*5噔 噔 咚你 在 干 什 么 123typedef long long ll;#define int ll#define %lld %d Can’t compile file:program.cpp:12:9: error: macro names must be identifiers#define %lld %d 123typedef long long ll;#define int ll#define lld d Test: #1, time: 2000 ms., memory: 180992 KB, exit code: -1, checker exit code: 0, verdict: TIME_LIMIT_EXCEEDED不愧是我 迷惑*6我:我压行了 我爽了队友:? 你 在 干 什 么 1pf(&quot;%lld\\n&quot;,dfs(m,1,0,0,0,p[i],sum[1]-a[i]*p[i],sum[0]-(1-a[i])*p[i],a[i]*2-1)); 打个正常版 12if(a[i]) pf(&quot;%lld\\n&quot;,dfs(m,1,0,0,0,p[i],sum[1]-p[i],sum[0],1));else pf(&quot;%lld\\n&quot;,dfs(m,1,0,0,0,p[i],sum[1],sum[0]-p[i],-1)); 迷惑*7有时候压了行也会哭着喊我再也不压了CF1312E","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Codeforces 1301D. Time to Run","slug":"Codeforces-1301D","date":"2020-02-13T20:47:40.000Z","updated":"2021-01-26T16:39:21.704Z","comments":true,"path":"2020/02/14/Codeforces-1301D/","link":"","permalink":"http://example.com/2020/02/14/Codeforces-1301D/","excerpt":"压行带师船新大作","text":"压行带师船新大作 题目链接27行就问你牛不牛逼 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int qaq[5005]; string s=&quot;RDU&quot;,ans[5005];int main()&#123; int n,m,k,cnt(0); sc(n); sc(m); sc(k); int num=4*n*m-2*n-2*m; if(k&gt;num) return puts(&quot;NO&quot;),0; puts(&quot;YES&quot;); if(m==1)&#123; pf(&quot;%d\\n&quot;,k&gt;n-1?2:1); pf(&quot;%d %c\\n&quot;,min(k,n-1),&#x27;D&#x27;); k-=min(k,n-1); if(k) pf(&quot;%d %c\\n&quot;,k,&#x27;U&#x27;); return 0; &#125; rep(i,1,2*n+1)&#123; if(!k) break; if(i&amp;1)&#123; if(i==2*n-1) qaq[cnt]=min(k,m-1),ans[cnt++]=&quot;R&quot;,k-=min(k,m-1); else if(k/3&gt;=m-1) qaq[cnt]=m-1,ans[cnt++]=s,k-=3*m-3; else&#123; if(k/3) qaq[cnt]=k/3,ans[cnt++]=s; if(k%3)&#123; qaq[cnt]=1; rep(j,0,k%3) ans[cnt][j]=s[j]; cnt++; &#125; k=0; &#125; &#125; else&#123; int t=min(k,m-1); qaq[cnt]=t,ans[cnt++]=&quot;L&quot;,k-=t; if(t==m-1&amp;&amp;k&amp;&amp;i!=2*n) qaq[cnt]=1,ans[cnt++]=&quot;D&quot;,k--; &#125; &#125; if(k) qaq[cnt]=k,ans[cnt++]=&quot;U&quot;; pf(&quot;%d\\n&quot;,cnt); rep(i,0,cnt) pf(&quot;%d %s\\n&quot;,qaq[i],ans[i].c_str());&#125; 要讲清楚需要配图8 我懒 我就纪念一下我短的ep的代码就好了","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"PTA L1-064估值一亿的AI核心代码","slug":"PTA-L1-064估值一亿的AI核心代码","date":"2020-02-05T21:09:57.000Z","updated":"2021-01-26T16:41:29.786Z","comments":true,"path":"2020/02/06/PTA-L1-064估值一亿的AI核心代码/","link":"","permalink":"http://example.com/2020/02/06/PTA-L1-064%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/","excerpt":"猛男就该写猛题","text":"猛男就该写猛题 应该是过的代码中很短的一个了里面也有很多小心思 算是生涯中比较优秀的代码吧题目链接 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int main()&#123; int _; cin&gt;&gt;_; getchar(); while(_--)&#123; string s; getline(cin,s); cout&lt;&lt;s&lt;&lt;&quot;\\nAI:&quot;; while(s[0]==&#x27; &#x27;) s.erase(0,1); int len=s.length(); s=&#x27; &#x27;+s+&#x27; &#x27;; rep(i,1,len+1)&#123; if(s[i]!=&#x27;I&#x27;&amp;&amp;isupper(s[i])) s[i]=tolower(s[i]); else if(!isalnum(s[i])&amp;&amp;s[i]!=&#x27; &#x27;) s.insert(i,&quot; &quot;),s.insert(i+2,&quot;*&quot;),len+=2,i+=2; &#125; while(s.find(&quot;?&quot;)!=string::npos) s.replace(s.find(&quot;?&quot;),1,&quot;!&quot;); while(s.find(&quot; &quot;)!=string::npos) s.replace(s.find(&quot; &quot;),2,&quot; &quot;); while(s.find(&quot; I &quot;)!=string::npos) s.replace(s.find(&quot; I &quot;),3,&quot; You &quot;); while(s.find(&quot;*I &quot;)!=string::npos) s.replace(s.find(&quot;*I &quot;),3,&quot;*You &quot;); while(s.find(&quot; me &quot;)!=string::npos) s.replace(s.find(&quot; me &quot;),4,&quot; You &quot;); while(s.find(&quot;*me &quot;)!=string::npos) s.replace(s.find(&quot;*me &quot;),4,&quot;*You &quot;); while(s.find(&quot; can you &quot;)!=string::npos) s.replace(s.find(&quot; can you &quot;),9,&quot; I can* &quot;); while(s.find(&quot;*can you &quot;)!=string::npos) s.replace(s.find(&quot;*can you &quot;),9,&quot;*I can &quot;); while(s.find(&quot; could you &quot;)!=string::npos) s.replace(s.find(&quot; could you &quot;),11,&quot; I could &quot;); while(s.find(&quot;*could you &quot;)!=string::npos) s.replace(s.find(&quot;*could you &quot;),11,&quot;*I could &quot;); len=s.length(); rep(i,0,len) if(s[i]==&#x27;Y&#x27;) s[i]=&#x27;y&#x27;; else if(s[i]==&#x27;*&#x27;) s.erase(i,1),len--,i--; rep(i,2,len) if(!isalnum(s[i])&amp;&amp;s[i]!=&#x27; &#x27;&amp;&amp;s[i-1]==&#x27; &#x27;) s.erase(i-1,1),len--,i--; while(s[len-1]==&#x27; &#x27;) s.erase(len-1,1),len--; if(!len) cout&lt;&lt;&#x27; &#x27;; cout&lt;&lt;s&lt;&lt;&#x27;\\n&#x27;; &#125;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"pintia","slug":"pintia","permalink":"http://example.com/tags/pintia/"}]},{"title":"牛客小白月赛21解题报告","slug":"牛客小白月赛21解题报告","date":"2020-01-25T05:56:31.000Z","updated":"2021-01-26T16:43:18.842Z","comments":true,"path":"2020/01/25/牛客小白月赛21解题报告/","link":"","permalink":"http://example.com/2020/01/25/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B21%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"namo 怎么ak一场小白月赛这么难啊","text":"namo 怎么ak一场小白月赛这么难啊 比赛链接除了代码短度一无是处了 Audio找外心 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;double x1,y11,x2,y2,x3,y3,x,y;int main()&#123; cin&gt;&gt;x1&gt;&gt;y11&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3; double A1=2*(x2-x1),B1=2*(y2-y11),C1=x2*x2+y2*y2-x1*x1-y11*y11; double A2=2*(x3-x2),B2=2*(y3-y2),C2=x3*x3+y3*y3-x2*x2-y2*y2; x=((C1*B2)-(C2*B1))/((A1*B2)-(A2*B1)); y=((A1*C2)-(A2*C1))/((A1*B2)-(A2*B1)); printf(&quot;%.3lf %.3lf\\n&quot;,x,y);&#125; Bits12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;int n,t[5],s[15][5];void print()&#123; rep(i,1,3*(2*n+1)+5) putchar(&#x27;.&#x27;); putchar(&#x27;\\n&#x27;); dep(i,n+1,1)&#123; rep(j,1,4)&#123; rep(k,0,n-s[i][j]+1) putchar(&#x27;.&#x27;); rep(k,0,s[i][j]) putchar(&#x27;*&#x27;); putchar(s[i][j]?&#x27;*&#x27;:&#x27;|&#x27;); rep(k,0,s[i][j]) putchar(&#x27;*&#x27;); rep(k,0,n-s[i][j]) putchar(&#x27;.&#x27;); &#125; putchar(&#x27;.&#x27;); putchar(&#x27;\\n&#x27;); &#125;&#125;void move(int a,int b)&#123; s[++t[b]][b]=s[t[a]][a]; s[t[a]--][a]=0; rep(i,1,3*(2*n+1)+5) putchar(&#x27;-&#x27;); putchar(&#x27;\\n&#x27;); print();&#125;void solve(int n,int a,int b,int c)&#123; if(n==1) return move(a,c); solve(n-1,a,c,b); move(a,c); solve(n-1,b,a,c);&#125;int main()&#123; cin&gt;&gt;n; rep(i,1,n+1) s[++t[1]][1]=n-i+1; print(); solve(n,1,2+(n&amp;1),3-(n&amp;1));&#125; Channels123456#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll a,b; while(cin&gt;&gt;a&gt;&gt;b) cout&lt;&lt;b/60*50+min(50ll,b%60)-(a-1)/60*50-min(50ll,(a-1)%60)&lt;&lt;&#x27;\\n&#x27;;&#125; DDoS12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)using namespace std;const int maxn = 1e5 + 5;int in[maxn],vis[maxn];vector&lt;int&gt;vv[maxn];int main()&#123; int n,m; sc(n); sc(m); while(m--)&#123; int u,v,w; sc(u); sc(v); sc(w); vv[u].push_back(v); in[v]++; &#125; vis[1]=1; queue&lt;int&gt;q; q.push(1); while(!q.empty())&#123; int fr=q.front(); q.pop(); for(int t:vv[fr])&#123; vis[t]=(vis[t]+vis[fr])%20010905; if(!--in[t]) q.push(t); &#125; &#125; pf(&quot;%d\\n&quot;,vis[n]);&#125; Exams1234567#include&lt;bits/stdc++.h&gt;int main()&#123; int n; double a1(0),a2(0); std::cin&gt;&gt;n; while(n--)&#123; int a; double b,c,d,e,f,g,h; std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f&gt;&gt;g&gt;&gt;h; if(a==2) continue; a1+=b*(int)(c*d+e*f+g*h+0.5); a2+=b; &#125; printf(&quot;%.2lf&quot;,a1/a2);&#125; Fool Problem12345#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; cin&gt;&gt;s; puts((s[s.size()-1]-&#x27;0&#x27;)&amp;1?&quot;-1&quot;:&quot;1&quot;);&#125; Game1234567#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)int main()&#123; int n,cnt(0); std::cin&gt;&gt;n; rep(i,2,n+1) while(n%i==0) n/=i,cnt++; puts(cnt&amp;1?&quot;Nancy&quot;:&quot;Johnson&quot;);&#125; ”Happy New Year!“php 1&quot;Happy New Year!&quot; I love you1234567891011#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[10],mod=20010905;int main()&#123; string s,q=&quot; iloveyou&quot;; a[0]=1; cin&gt;&gt;s; int len=s.length(); rep(i,0,len)&#123; s[i]=tolower(s[i]); rep(j,1,9) a[j]=(a[j]+(s[i]==q[j])*a[j-1])%mod; &#125; cout&lt;&lt;a[8];&#125; Jelly我真的服了 这都能wa 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;char mp[105][105][105];int dir[6][3]=&#123;1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1&#125;;struct node&#123; int x,y,z,cnt;&#125;;int n,cnt;int vis[105][105][105];queue&lt;node&gt;q;int bfs()&#123; q.push(node&#123;0,0,0,1&#125;); vis[0][0][0]++; while(!q.empty())&#123; node fr=q.front(); q.pop(); rep(i,0,6)&#123; node c=fr; c.x+=dir[i][0],c.y+=dir[i][1],c.z+=dir[i][2]; if(c.x&lt;0||c.y&lt;0||c.z&lt;0||c.x&gt;=n||c.y&gt;=n||c.z&gt;=n) continue; if(vis[c.x][c.y][c.z]||mp[c.x][c.y][c.z]==&#x27;*&#x27;) continue; vis[c.x][c.y][c.z]++; c.cnt++; q.push(c); if(c.x==n-1&amp;&amp;c.y==n-1&amp;&amp;c.z==n-1) return cout&lt;&lt;c.cnt,0; &#125; &#125; return cout&lt;&lt;-1,0;&#125;int main()&#123; cin&gt;&gt;n; rep(i,0,n) rep(j,0,n) cin&gt;&gt;mp[i][j]; bfs();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"}]},{"title":"Wannafly Winter Camp 2020-Day7","slug":"Wannafly Winter Camp 2020-Day7","date":"2020-01-18T11:46:10.000Z","updated":"2021-01-26T16:42:40.468Z","comments":true,"path":"2020/01/18/Wannafly Winter Camp 2020-Day7/","link":"","permalink":"http://example.com/2020/01/18/Wannafly%20Winter%20Camp%202020-Day7/","excerpt":"今天也还好？队伍EHK三题 我EH 虽然说E是打表的（","text":"今天也还好？队伍EHK三题 我EH 虽然说E是打表的（ 前一个小时状态极差 属于看什么什么不会 看H没有一点思路 感慨：他们怎么都会啊手推了一下H前5项的情况 心里大概有了猜想 看了看ac队伍的用时也和想的式子一样 为了保险又手推了6 果然想的是对的 早知道莽了.jpg但还是因为计算范围错了炸int了wa了一发 我是废物过了H的生活因为K两个队友都在看 就去看新题了（加上我也不是很想推 开了E 又是手推了前几项 猜想了一个结论 顺利wa然后考虑到了其他情况 继续推式子 但队友K还没过 遂帮倒忙地看了看K 因为真的懒得推 队友推了好几遍我相信式子没问题！又去看E发现E在oeis直接有表 换Java写 因为语法不熟和改得太急成功wa*2队友也把K过了 +10 排名从100开外变成50+ 最终排名60+吧 还行（ 7E. 上升下降子序列123456789101112import java.math.*;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); int n=sc.nextInt(); BigInteger m=sc.nextBigInteger(); if(n==1)&#123; System.out.println(0); return; &#125; String[] s=&#123;&quot;2&quot;,&quot;6&quot;,&quot;22&quot;,&quot;86&quot;,&quot;340&quot;,&quot;1340&quot;,&quot;5254&quot;,&quot;20518&quot;,&quot;79932&quot;,&quot;311028&quot;,&quot;1209916&quot;,&quot;4707964&quot;,&quot;18330728&quot;,&quot;71429176&quot;,&quot;278586182&quot;,&quot;1087537414&quot;,&quot;4249391468&quot;,&quot;16618640836&quot;,&quot;65048019092&quot;,&quot;254814326164&quot;,&quot;998953992728&quot;,&quot;3919041821896&quot;,&quot;15385395144092&quot;,&quot;60438585676636&quot;,&quot;237563884988120&quot;,&quot;934311596780040&quot;,&quot;3676495517376184&quot;,&quot;14474185732012088&quot;,&quot;57011153530262480&quot;,&quot;224656915621201776&quot;,&quot;885652912419210822&quot;,&quot;3492861836026915782&quot;,&quot;13780479845245611084&quot;,&quot;54388113081432337380&quot;,&quot;214729932989712917668&quot;,&quot;848052809484541707556&quot;,&quot;3350334574655466140216&quot;,&quot;13239822072430180232232&quot;,&quot;52335808270599440879284&quot;,&quot;206934571189982074002548&quot;,&quot;818425886045480073365896&quot;,&quot;3237673398479042349060632&quot;,&quot;12811192923571669467870664&quot;,&quot;50704290989642196738527048&quot;,&quot;200721767558683308700217776&quot;,&quot;794758327136359419952519952&quot;,&quot;3147480247103506996680796444&quot;,&quot;12467371711588974170827212188&quot;,&quot;49393251191799570968275635832&quot;,&quot;195721323613651013964116220008&quot;,&quot;775681930753017847189773247816&quot;,&quot;3074691375740439617836809788744&quot;,&quot;12189592067181565816702419563248&quot;,&quot;48333049189844665620128143125968&quot;,&quot;191674487676565550273850199554424&quot;,&quot;760234106384599142912931614646008&quot;,&quot;3015721572748589992463595600401200&quot;,&quot;11964485381977151314836595373090960&quot;,&quot;47473780481353767802050510461474416&quot;,&quot;188394767873878618122620614886243696&quot;,&quot;747717213262848575274466080605467552&quot;,&quot;2967958428851480386917331132533607136&quot;,&quot;11782259592346823520686656131742782022&quot;,&quot;46778706886870096588550881954439021894&quot;,&quot;185744202455399051984941117140485426188&quot;,&quot;737612707907218431744486755161165283876&quot;,&quot;2929451267263567016070637982850089264452&quot;,&quot;11635570442457473175795713890168152798404&quot;,&quot;46220155055609632689452725735280292076408&quot;,&quot;183618435592218742042711461696686422730216&quot;,&quot;729526765909664873244748736973027445604932&quot;,&quot;2898712749488697136757456372292134404034564&quot;,&quot;11518796733262965478081905854113416167753128&quot;,&quot;45776865583236473399203960989099899119494776&quot;,&quot;181937009594320978873736215406788995917525032&quot;,&quot;723154688965889751097101396443192826411889064&quot;,&quot;2874588225169330729910266250097039087510781168&quot;,&quot;11427560208426660761216674193001922526450403536&quot;,&quot;45432226748523983679867488376304124899523401012&quot;,&quot;180636860154887532842333974035976978875788303284&quot;,&quot;718256924308840704281727251872444612431548985768&quot;,&quot;2856167234882640332177000885696057331411192948216&quot;,&quot;11358398642653256630400822038234943728547172796632&quot;,&quot;45173065721576308057178968529470878470010061869784&quot;,&quot;179667842488623618336093016334593779472760809719248&quot;,&quot;714642491229551839105935178063714692911965481155696&quot;,&quot;2842722058240330382759816822753037594153543736276232&quot;,&quot;11308537787442034315752841106800792975560381040259464&quot;,&quot;44988801505636138725613585002139650894736930818859728&quot;,&quot;178989582482503853042943703302031527717732898643340656&quot;,&quot;712157265987568127773494228152764511315128648488823312&quot;,&quot;2833664093821898191595666210009358256743525029610686224&quot;,&quot;11275728828895114632325888269455044211548265118705668448&quot;,&quot;44870838790971390745360943764893423662680647193816689696&quot;,&quot;178569214591821033028866839352551169428060985661714360092&quot;,&quot;710675533602207732686301380136130771528525107574404678684&quot;,&quot;2828512285392854707326223033551336688181493890435185846968&quot;,&quot;11258130303537041119524653026082830440762998748471762960936&quot;,&quot;44812126024908558505907621010943168569218082391894548561192&quot;&#125;; BigInteger q=new BigInteger(s[n-2]); q=q.mod(m); System.out.println(q); &#125;&#125; 7H. 游戏12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;ll n,cnt,ans,num,g;int main()&#123; scl(n); rep(i,1,n+1) rep(j,i+1,n+1) if(__gcd(i,j)==1) cnt++; if(n==1) return puts(&quot;0/1&quot;),0; if(n==2||n==3) return puts(&quot;1/1&quot;),0; ans=n*(n-1)/2; num=n/2; g=__gcd(num*cnt,ans); pf(&quot;%lld/%lld\\n&quot;,num*cnt/g,ans/g);&#125; 7K. 修炼1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int n,a1,a2,b1[maxn],b2[maxn];int check(int x)&#123; ll t1=1ll*a1*x,t2=1ll*a2*x,mn=1e18; rep(i,1,n+1)&#123; ll res=0; if(t1&gt;=b1[i]&amp;&amp;t2&gt;=b2[i]) return 0; res+=b1[i]-t1&gt;0?b1[i]-t1:0; res+=b2[i]-t2&gt;0?b2[i]-t2:0; mn=min(mn,res); &#125; return 1ll*x*(x+1)/2&lt;mn;&#125;int main()&#123; cin&gt;&gt;a1&gt;&gt;a2&gt;&gt;n; rep(i,1,n+1) cin&gt;&gt;b1[i]&gt;&gt;b2[i]; int l=-1,r=1e9; while(l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if(check(mid)) l=mid+1; else r=mid-1; &#125; pf(&quot;%d\\n&quot;,l);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day6","slug":"Wannafly Winter Camp 2020-Day6","date":"2020-01-17T11:12:31.000Z","updated":"2021-01-26T16:42:34.080Z","comments":true,"path":"2020/01/17/Wannafly Winter Camp 2020-Day6/","link":"","permalink":"http://example.com/2020/01/17/Wannafly%20Winter%20Camp%202020-Day6/","excerpt":"手速场 今天是废物","text":"手速场 今天是废物 开局挑了个题目 “自闭” 一看 哦 小模拟 这个我学得来和队友说 有个模拟 我去写了 同时立下flag：前三小时可能没我了写完后因为傻逼和语文太差被关了半小时这时候已经写得差不多了 没我啥事了去想J 然后被关到比赛结束 玄学做法果然不可取赛后dp补了 6C. 酒馆战棋最不爱写的题 队友代码 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;char s[1005];int main()&#123; int _; sc(_); while(_--)&#123; int n,a,b,c,d; sc(n),sc(a),sc(b),sc(c),sc(d),scs(s); int aa=a,bb=b,cc=c,dd=d,mx=0,mn=0; rep(i,0,n)&#123; if(s[i]==&#x27;0&#x27;)&#123; if(dd) dd--,cc++; else if(cc)&#123; &#125; else if(bb) bb--,aa++; &#125; else&#123; if(cc) mx++,cc--; else if(dd) dd--,cc++; else if(aa) aa--,mx++; else if(bb) bb--,aa++; &#125; &#125; aa=a,bb=b,cc=c,dd=d; rep(i,0,n)&#123; if(s[i]==&#x27;0&#x27;)&#123; if(cc)&#123; &#125; else if(dd) dd--,cc++; else if(aa)&#123; &#125; else if(bb) bb--,aa++; &#125; else&#123; if(dd) dd--,cc++; else if(cc) cc--,mn++; else if(bb) bb--,aa++; else if(aa) aa--,mn++; &#125; &#125; pf(&quot;%d %d\\n&quot;,mx,mn); &#125;&#125; 6F. 图与三角形12345678910111213#include&lt;bits/stdc++.h&gt;#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;ll n,a,b,c,p,d,ans;vector&lt;int&gt;vv[5005];int main()&#123; scl(n); scl(a); scl(b); scl(c); scl(p); scl(d); rep(i,1,n+1) rep(j,1,n+1) if(i!=j&amp;&amp;(a*(i+j)*(i+j)+b*(i-j)*(i-j)+c)%p&gt;d) vv[i].push_back(j); rep(i,1,n+1) ans+=vv[i].size()*(n-vv[i].size()-1); ans=n*(n-1)*(n-2)/6-ans/2; printf(&quot;%lld\\n&quot;,ans);&#125; 6K. 最大权值排列123456789101112#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 1e5 + 5;int a[maxn];int main()&#123; int n,cnt(1); sc(n); rep(i,1,n+1)&#123; if(i&amp;1) a[cnt]=i; else a[n-cnt+1]=i,cnt++; &#125; rep(i,1,n+1) pf(&quot;%d &quot;,a[i]);&#125; 6L. 你吓到我的马了.jpg123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;char mp[105][105];int n,m,vis[105][105],ans[105][105];int dir[8][2]=&#123;2,1,2,-1,-2,1,-2,-1,1,2,1,-2,-1,2,-1,-2&#125;;struct node&#123; int x,y,cnt; &#125;s;void bfs()&#123; ans[s.x][s.y]=0; vis[s.x][s.y]=1; queue&lt;node&gt;q; q.push(s); while(!q.empty())&#123; node fr=q.front(); q.pop(); ans[fr.x][fr.y]=fr.cnt; rep(i,0,8)&#123; node t=fr; t.x+=dir[i][0],t.y+=dir[i][1],t.cnt++; if(t.x&lt;0||t.y&lt;0||t.x&gt;=n||t.y&gt;=m) continue; if(vis[t.x][t.y]||mp[t.x][t.y]==&#x27;X&#x27;) continue; if(mp[fr.x+dir[i][0]/2][fr.y+dir[i][1]/2]==&#x27;X&#x27;) continue; q.push(t); vis[t.x][t.y]++; &#125; &#125;&#125;int main()&#123; sc(n); sc(m); rep(i,0,n)&#123; scs(mp[i]); rep(j,0,m) if(mp[i][j]==&#x27;M&#x27;) s.x=i,s.y=j,s.cnt=0; &#125; mst(ans,-1); bfs(); rep(i,0,n) rep(j,0,m) pf(&quot;%d%c&quot;,ans[i][j],j==m-1?&#x27;\\n&#x27;:&#x27; &#x27;);&#125; 6M. 自闭12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;int q[105][15][2]; //计数int vis[105],ac[105]; //vis这个人有没有交过 ac这个人有没有提交过int sd[15]; //solvedint wa[105][15];int main()&#123; int n,m,w; sc(n); sc(m); sc(w); rep(i,0,w)&#123; int x,y,c; sc(x); sc(y); sc(c); q[x][y][c]++; vis[x]++; if(c)&#123; //如果是ac if(q[x][y][0]) wa[x][y]=max(wa[x][y],q[x][y][0]),q[x][y][0]=0; ac[x]++; if(q[x][y][1]==1) sd[y]++; //不重复计算ac人数 &#125; &#125; rep(i,1,n+1) rep(j,1,m+1) if(q[i][j][0]) wa[i][j]=max(wa[i][j],q[i][j][0]); rep(i,1,n+1)&#123; if(!vis[i]) puts(&quot;998244353&quot;); //没提交 else if(!ac[i]) puts(&quot;1000000&quot;); //爆零 else&#123; int ak(1); rep(j,1,m+1) if(!q[i][j][1]) ak=0; if(ak) puts(&quot;0&quot;); else&#123; //4 有人a自己没a +20 //5 过半人a自己没a +10 int ans(0); rep(j,1,m+1) if(!q[i][j][1]&amp;&amp;sd[j])&#123; ans+=20; if(sd[j]&gt;=n/2) ans+=10; &#125; //6 连wa k次 +k^2 //7 连wa k次且没a +k^2 rep(j,1,m+1)&#123; int k=wa[i][j]; k*=k; ans+=k; if(!q[i][j][1]) ans+=k; &#125; pf(&quot;%d\\n&quot;,ans); &#125; &#125; &#125;&#125; 6N. 合并！12345678910111213#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;int a[2005];int main()&#123; int n; ll ans(0); sc(n); rep(i,0,n) sc(a[i]); sort(a,a+n); if(n==1) return pf(&quot;%d\\n&quot;,a[0]),0; rep(i,0,n-1) ans+=1ll*a[i]*a[i+1],a[i+1]+=a[i]; pf(&quot;%lld\\n&quot;,ans);&#125; 补题： 6G. 单调栈123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;int a[105],ans[105];int main()&#123; int _; sc(_); while(_--)&#123; int n; sc(n); rep(i,0,n) sc(a[i]); int cnt(0),pos(0); mst(ans,0); rep(i,1,n+1)&#123; while(pos&lt;n&amp;&amp;ans[pos]) pos++; if(pos==n) break; if(a[pos]==-1) a[pos]=i; dep(j,n-1,pos) if(a[j]==i) ans[j]=++cnt; &#125; rep(i,0,n) pf(&quot;%d%c&quot;,ans[i],i==n-1?&#x27;\\n&#x27;:&#x27; &#x27;); &#125;&#125; 6J. K重排列123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;int jc[55],inv[55];int dp[55],tmp[55];int q[55][55][55];int qpow(int x,int y)&#123; int ans=1; while(y)&#123; if(y&amp;1) ans=1ll*ans*x%mod; x=1ll*x*x%mod; y&gt;&gt;=1; &#125; return ans;&#125;int C(int s,int x)&#123; return 1ll*jc[x]*inv[s]%mod*inv[x-s]%mod;&#125;void init()&#123; jc[0]=inv[0]=1; rep(i,1,51) jc[i]=1ll*jc[i-1]*i%mod,inv[i]=qpow(jc[i],mod-2); rep(i,1,51) rep(j,i,51) rep(k,1,j/i+1) if(k==1) q[i][j][k]=C(i,j); else q[i][j][k]=1ll*q[i][j-i][k-1]*C(i,j)%mod;&#125;void solve()&#123; int n; ll k; sc(n); scl(k); mst(dp,0); dp[0]=1; rep(i,1,n+1)&#123; if(k%i) continue; memcpy(tmp,dp,sizeof(dp)); rep(j,0,n+1) for(int t=1,a=jc[i-1];j+t*i&lt;=n;++t,a=1ll*a*jc[i-1]%mod) dp[j+t*i]=(1ll*dp[j+t*i]+1ll*tmp[j]*q[i][n-j][t]%mod*a%mod*inv[t])%mod; &#125; pf(&quot;%d\\n&quot;,dp[n]);&#125;int main()&#123; init(); int _; sc(_); while(_--) solve();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day5","slug":"Wannafly Winter Camp 2020-Day5","date":"2020-01-16T10:01:26.000Z","updated":"2021-01-26T16:42:28.349Z","comments":true,"path":"2020/01/16/Wannafly Winter Camp 2020-Day5/","link":"","permalink":"http://example.com/2020/01/16/Wannafly%20Winter%20Camp%202020-Day5/","excerpt":"今天不自闭了 rk31","text":"今天不自闭了 rk31 队里的罚时提供者 非ac的全是我交的(开场写G 当时范围还是1e16 打了个表 等表的时候去看A(一看 啊 啥玩意啊 咋写啊 我学不来啊再一看 k&lt;=3啊 那没事了然后傻逼错误wa了3次 哈哈然后表打完了 对着2e8想了一下 然后看看群 哦哦杜爹说改范围了我对队友:”哦,我会!”然后复杂度算错 -3 哈哈数组开小re一次 最后+4这时候是第七个过的!猛猛猛男我:”反正别人有+11的!我的+4也还好8”然后划水划了1h(?帮队友康了康E 找到了几个bug 调了一下 过样例了!我:”要不要交?”队友:”交交交”wa6演 wz 演然后写代码的队友找到了真正的bug!ac!快乐地离场了 5A. Alternative Accounts123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int q[3][maxn];vector&lt;int&gt;vv[6];int main()&#123; int n,k,m,a,cnt(0); sc(n); sc(k); rep(i,0,k)&#123; sc(m); rep(j,0,m) sc(a),q[i][a]++; &#125; if(k==1) pf(&quot;%d&quot;,m); else if(k==2)&#123; rep(i,1,n+1)&#123; if(q[0][i]+q[1][i]==2) cnt++; else if(q[0][i]) vv[0].push_back(i); else if(q[1][i]) vv[1].push_back(i); &#125; cnt+=max(vv[0].size(),vv[1].size()); pf(&quot;%d\\n&quot;,cnt); &#125; else if(k==3)&#123; rep(i,1,n+1)&#123; if(q[0][i]+q[1][i]+q[2][i]==3) cnt++; else if(q[0][i]+q[1][i]+q[2][i]==2)&#123; if(q[0][i]&amp;&amp;q[1][i]) vv[0].push_back(i); if(q[0][i]&amp;&amp;q[2][i]) vv[1].push_back(i); if(q[1][i]&amp;&amp;q[2][i]) vv[2].push_back(i); &#125; else if(q[0][i]+q[1][i]+q[2][i]==1)&#123; if(q[2][i]) vv[3].push_back(i); if(q[1][i]) vv[4].push_back(i); if(q[0][i]) vv[5].push_back(i); &#125; &#125; int sz[3]; mst(sz,0); rep(i,0,3) sz[i]=vv[i+3].size(); rep(i,0,3) cnt+=vv[i].size(),sz[i]-=vv[i].size(); rep(i,0,3) if(sz[i]&lt;0) sz[i]=0; cnt+=max(sz[0],max(sz[1],sz[2])); pf(&quot;%d\\n&quot;,cnt); &#125;&#125; 5E. Matching Problem1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int n,ans,a[305],b[5],sum[305][305];map&lt;int,int&gt;aaa;int getsum(int x,int y,int z)&#123; int res=n-x; res-=sum[x+1][a[x]]; if(a[x]!=a[y]) res-=sum[x+1][a[y]]; if(a[x]!=a[z]&amp;&amp;a[y]!=a[z]) res-=sum[x+1][a[y]]; return res;&#125;int main()&#123; sc(n); rep(i,1,n+1) sc(a[i]),aaa[a[i]]++; rep(i,1,5) sc(b[i]); dep(i,n,1)&#123; for(auto &amp;x:aaa) sum[i][x.first]=sum[i+1][x.first]; sum[i][a[i]]++; &#125; int pos(0); rep(i,1,4) if(b[i]==b[4]) pos=i; rep(i,1,n+1) rep(j,i+1,n+1) rep(k,j+1,n+1)&#123; int ff=(pos==1?i:pos==2?j:k); if((a[i]==a[j])==(b[1]==b[2])&amp;&amp;(a[j]==a[k])==(b[2]==b[3])&amp;&amp;(a[i]==a[k])&amp;&amp;(b[1]==b[3])) ans+=ff?sum[k+1][a[ff]]:getsum(k,j,i); &#125; pf(&quot;%d\\n&quot;,ans);&#125; 5G. Cryptographically Secure Pseudorandom Number Generator123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e5 + 5;pii a[2000]; int inv[maxn];int solve()&#123; int p,cnt(0),ff(0),mn; sc(p); if(p==1||p==2) return pf(&quot;0\\n&quot;); inv[0]=0,inv[1]=1,inv[2]=p/2+1,mn=inv[2]; rep(i,2,p)&#123; inv[i]=1ll*(p-p/i)*inv[p%i]%p; if(inv[i]&lt;=mn)&#123; if(inv[i]==a[cnt-1].first) break; mn=inv[i]; a[cnt++]=pii(i,inv[i]); if(i==inv[i])&#123; ff++; break; &#125; &#125; &#125; pf(&quot;%d\\n&quot;,cnt*2-ff); rep(i,0,cnt) pf(&quot;%d %d\\n&quot;,a[i].first,a[i].second); dep(i,cnt-1-ff,0) pf(&quot;%d %d\\n&quot;,a[i].second,a[i].first); return 0;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 补题： 5A. Alternative Accounts短的 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,k,t,a,b,q[100005];int main()&#123; cin&gt;&gt;n&gt;&gt;k; while(k--)&#123; cin&gt;&gt;m; a=max(a,m); while(m--) cin&gt;&gt;t,q[t]++; &#125; while(n--) if(q[n+1]&gt;1) b++; cout&lt;&lt;max(a,b)&lt;&lt;&#x27;\\n&#x27;; &#125; 5J. Xor on Figures1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;char s[50][50];bitset&lt;1050&gt;p[1050],q;int n,cnt,ans=1,mod=1e9+7;void change(int x,int y)&#123; rep(i,0,n) rep(j,0,n) q[(i+x)%n*n+(j+y)%n]=s[i][j]-&#x27;0&#x27;; rep(i,0,n*n) if(q[i]==1)&#123; if(!p[i].count())&#123; p[i]=q; cnt++; break; &#125; q^=p[i]; &#125;&#125;int main()&#123; sc(n); n=1&lt;&lt;n; rep(i,0,n) scs(s[i]); rep(i,0,n) rep(j,0,n) change(i,j); rep(i,0,cnt) ans=2ll*ans%mod; pf(&quot;%d\\n&quot;,ans); &#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day3","slug":"Wannafly Winter Camp 2020-Day3","date":"2020-01-14T14:55:49.000Z","updated":"2021-01-26T16:41:58.907Z","comments":true,"path":"2020/01/14/Wannafly Winter Camp 2020-Day3/","link":"","permalink":"http://example.com/2020/01/14/Wannafly%20Winter%20Camp%202020-Day3/","excerpt":"赛时爆零了 记的是补题qwq","text":"赛时爆零了 记的是补题qwq 3A. 黑色气球12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[1005][1005],h[1005];int main()&#123; int n; sc(n); ll sum(0); rep(i,0,n) rep(j,0,n) sc(a[i][j]),sum+=1ll*a[i][j],h[i]+=a[i][j]; if(n==2) return pf(&quot;1 1\\n&quot;),0; sum/=(2ll*n-2); rep(i,0,n) pf(&quot;%d &quot;,(-1*sum+h[i])/(n-2));&#125; 3C. 无向图定向1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int n,m,ans,c[20];vector&lt;int&gt;vv[20];int judge(int x,int id)&#123; for(int t:vv[x]) if(c[t]==id) return 1; return 0;&#125;void dfs(int x,int num)&#123; if(ans&lt;=num) return; if(x&gt;n) return ans=min(ans,num),(void)0; rep(i,1,num+1) if(!judge(x,i))&#123; c[x]=i; dfs(x+1,num); c[x]=0; &#125; c[x]=num+1; dfs(x+1,num+1); c[x]=0;&#125;int main()&#123; sc(n); sc(m); ans=1e9; while(m--)&#123; int u,v; sc(u); sc(v); vv[u].push_back(v); vv[v].push_back(u); &#125; dfs(1,0); printf(&quot;%d\\n&quot;,ans-1);&#125; 3E. 棋技哥123456789101112#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;char s[505],c;int main()&#123; int _; sc(_); while(_--)&#123; int n,m; sc(n); sc(m); scs(s); c=s[0]; rep(i,1,n) scs(s); puts(c==&#x27;0&#x27;?&quot;aoligei&quot;:&quot;call&quot;); &#125;&#125; 3G. 火山哥周游世界1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; pii;const int maxn = 5e5 + 5;int n,k,vis[maxn];ll num[maxn],sum[maxn];ll mx1[maxn],mx2[maxn];vector&lt;pii&gt;vv[maxn];void upd(int id,ll x)&#123; if(x&gt;=mx1[id]) mx2[id]=mx1[id],mx1[id]=x; else if(x&gt;mx2[id]) mx2[id]=x;&#125;void dfs1(int x,int f)&#123; if(vis[x]) num[x]++; sum[x]=mx1[x]=mx2[x]=0; for(pii t:vv[x])&#123; ll y=t.first,z=t.second; if(y==f) continue; dfs1(y,x); num[x]+=num[y]; sum[x]+=sum[y]+(num[y]&gt;0)*z; upd(x,mx1[y]+(num[y]&gt;0)*z); &#125;&#125;void dfs2(int x,int f)&#123; for(pii t:vv[x])&#123; ll y=t.first,z=t.second; if(y==f) continue; sum[y]=sum[x]-z*(num[y]&gt;0)+z*(n-num[y]&gt;0); if(num[y]!=n&amp;&amp;mx1[y]+z==mx1[x]) upd(y,mx2[x]+z); else if(num[y]!=n) upd(y,mx1[x]+z); dfs2(y,x); &#125;&#125;int main()&#123; sc(n); sc(k); rep(i,1,n)&#123; ll u,v,w; scl(u); scl(v); scl(w); vv[u].push_back(make_pair(v,w)); vv[v].push_back(make_pair(u,w)); &#125; int a0; sc(a0); vis[a0]++; k--; while(k--)&#123; int a; sc(a); vis[a]++; &#125; dfs1(a0,0); dfs2(a0,0); rep(i,1,n+1) pf(&quot;%lld\\n&quot;,sum[i]*2-mx1[i]);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day2","slug":"Wannafly Winter Camp 2020-Day2","date":"2020-01-13T14:55:49.000Z","updated":"2021-01-26T16:41:51.171Z","comments":true,"path":"2020/01/13/Wannafly Winter Camp 2020-Day2/","link":"","permalink":"http://example.com/2020/01/13/Wannafly%20Winter%20Camp%202020-Day2/","excerpt":"真的隔了好久才补 赛时爆零了qwq","text":"真的隔了好久才补 赛时爆零了qwq 2A. 托米的字符串123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;char s[maxn];double p[maxn],q[maxn],ans;int judge(char c)&#123; if(c==&#x27;a&#x27;||c==&#x27;e&#x27;||c==&#x27;i&#x27;) return 1; if(c==&#x27;o&#x27;||c==&#x27;u&#x27;||c==&#x27;y&#x27;) return 1; return 0;&#125;int main()&#123; scs(s+1); int len=strlen(s+1); rep(i,1,len+1) p[i]=p[i-1]+1.0/i; rep(i,1,len+1) q[i]=q[i-1]+p[i]; rep(i,1,len+1) if(judge(s[i])) ans+=q[len]-q[len-i]-q[i-1]; pf(&quot;%.9lf\\n&quot;,2.0*ans/(1.0*len*(len+1)));&#125; 2C. 纳新一百的石子游戏123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;ll x,q[65];int main()&#123; int n; sc(n); rep(i,0,n)&#123; ll a; scl(a); x^=a; int cnt=0; while(a)&#123; cnt++; if(a&amp;1) q[cnt]++; a&gt;&gt;=1; &#125; if(!x) pf(&quot;0\\n&quot;); else&#123; cnt=0; ll x1=x; while(x1)&#123; cnt++; x1&gt;&gt;=1; &#125; pf(&quot;%d\\n&quot;,q[cnt]); &#125; &#125;&#125; 2K. 破忒头的匿名信12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;const int maxn = 5e5 + 5;char s[maxn];ll tot,ch[maxn][26],nex[maxn];ll len[maxn],val[maxn],f[maxn];void insert(char* s,ll x)&#123; int n=strlen(s+1),p=1; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!ch[p][tmp]) ch[p][tmp]=++tot,len[tot]=len[p]+1; p=ch[p][tmp]; &#125; if(!val[p]) val[p]=x; else val[p]=min(val[p],x);&#125;void build()&#123; queue&lt;ll&gt;q; q.push(1); nex[1]=0; while(!q.empty())&#123; int fr=q.front(); q.pop(); rep(i,0,26) if(!ch[fr][i]) ch[fr][i]=ch[nex[fr]][i]; else nex[ch[fr][i]]=ch[nex[fr]][i],q.push(ch[fr][i]); &#125;&#125;int find(char* s)&#123; int n=strlen(s+1),p=1; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;,k=ch[p][tmp]; while(k&gt;1)&#123; if(val[k]) f[i]=min(f[i],f[i-len[k]]+val[k]); k=nex[k]; &#125; p=ch[p][tmp]; &#125; if(f[n]&gt;1e18) return puts(&quot;-1&quot;); return pf(&quot;%lld\\n&quot;,f[n]);&#125;int main()&#123; ll n,a; scl(n); mst(f,0x3f); f[0]=0; rep(i,0,26) ch[0][i]=1; tot=1; rep(i,0,n) scs(s+1),scl(a),insert(s,a); build(); scs(s+1); find(s);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day1","slug":"Wannafly Winter Camp 2020-Day1","date":"2020-01-12T14:55:49.000Z","updated":"2021-01-26T16:41:44.005Z","comments":true,"path":"2020/01/12/Wannafly Winter Camp 2020-Day1/","link":"","permalink":"http://example.com/2020/01/12/Wannafly%20Winter%20Camp%202020-Day1/","excerpt":"第一场比赛还算比较顺利8","text":"第一场比赛还算比较顺利8 队伍BCH三题 rk55 我写了CH两题 算是没丢数学选手兼Java选手的脸吧233开题时看到H的题目“最大公约数”就直接点进去了 然后有思路开始写 wa2 造了几个小数据发现自己有地方假了 调过了一交还是wa2 然后想了想极限数据 啊好像long long必炸 就换Java写了 然后AC在我调H的时候队友已经把B过了 然后好像是对着F自闭？H过了惊闻刘老师把C秒了 我:刘老师能秒我们应该也能A! 就看看C 很快有了想法 手推了一下样例验证了猜想开始写 因为我是没有化出式子的QAQ 就一堆中间过程 写得头都没了 写完一测样例四个没过 开始自闭 然后当时以为五点半就结束了有点想放弃了 一看比赛时间还一个小时 又充满了信心继续调 终于把第四个样例调对了 一比对第五个样例的对的 直接交了 1A 激动得要死最后45min试着想F 实在是没思路QAQ 比赛结束!晚上听jls讲题 啊jls真的太帅了 我永远喜欢jry附赛时代码 2020 CCPC Wannafly Winter Camp Day1 B. 密码学1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;char s[1005][105];int n,m,x[1005],y[1005];int change(char c)&#123; if(c&gt;=&#x27;a&#x27;) return c-&#x27;a&#x27;; else return c-&#x27;A&#x27;+26;&#125;void solve(int a,int b)&#123; int l1=strlen(s[a]),l2=strlen(s[b]); rep(i,0,l2)&#123; int p=change(s[a][i%l1]),q=change(s[b][i]),t=(q-p+52)%52; if(t&lt;26) s[b][i]=&#x27;a&#x27;+t; else s[b][i]=&#x27;A&#x27;+t-26; &#125;&#125;int main()&#123; sc(n); sc(m); rep(i,1,m+1) sc(x[i]),sc(y[i]); rep(i,1,n+1) scs(s[i]); dep(i,m,1) solve(x[i],y[i]); rep(i,1,n+1) pf(&quot;%s\\n&quot;,s[i]);&#125; 2020 CCPC Wannafly Winter Camp Day1 C. 染色图想了想公式确实是可以化出来的 但我没有(调傻了( 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;int main()&#123; int _; sc(_); while(_--)&#123; ll n,l,r; scl(n); scl(l); scl(r); ll ans=n*(n-1)/2%mod,res=0; ans=ans*(r-l+1)%mod; for(ll i=1;i*i&lt;=n;i++)&#123; ll r1=n/i,l1=n/(i+1)+1; if(l1&gt;r1) l1=r1; //上下界 if(i&gt;=l)&#123; ll ys=n%i,sy=i-ys; //余数 剩余 res+=ys*(r1*(r1+1)/2)%mod+sy*(r1*(r1-1)/2)%mod; res%=mod; //i时的数量 &#125; if(r1==i) break; l1=max(l1,l); r1=min(r1,r); if(l1&gt;r1) continue; ll a1=n%r1,a2=n%l1; ll num=(r1-l1+1),sum=(a1+a2)*num/2%mod; ll rem=(l1+r1)*num/2-sum; rem%=mod; ll t1=i*(i-1)/2%mod,t2=i*(i+1)/2%mod; res+=t1*rem%mod; res%=mod; res+=t2*sum%mod; res%=mod; &#125; ans-=res; ans=(ans+mod)%mod; pf(&quot;%lld\\n&quot;,ans); &#125;&#125; 2020 CCPC Wannafly Winter Camp Day1 H. 最大公约数wa了两次才想到用Java( 1234567891011121314151617181920212223import java.math.*;import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc=new Scanner(System.in); int t=sc.nextInt(); while(t--&gt;0)&#123; int n=sc.nextInt(); int x=sc.nextInt(); int[] vis=new int[505]; for(int i=1;i&lt;=n;i++) vis[i]=0; if(n&lt;2*x) Syst,em.out.println(x); else&#123; for(int i=2*x;i&lt;=n;i+=x) vis[i]=1; for(int i=2*x;i&lt;=n;i+=x) for(int j=i*2;j&lt;=n;j+=i) if(vis[j]==1) vis[j]=0; BigInteger ans=BigInteger.valueOf(x); ans=ans.multiply(new BigInteger(&quot;2&quot;)); for(int i=2*x+1;i&lt;=n;i++) if(vis[i]==1)&#123; BigInteger tmp=BigInteger.valueOf(i); tmp=tmp.divide(ans.gcd(BigInteger.valueOf(i))); ans=ans.multiply(tmp); &#125; System.out.println(ans); &#125; &#125; &#125;&#125; 补题: 2020 CCPC Wannafly Winter Camp Day1 A. 期望逆序对123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e3 + 5;const int mod = 998244353;pii p[maxn];ll inv[maxn];int cmp(pii a,pii b)&#123; return a.first+a.second&lt;b.first+b.second;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1) ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;ll count(pii a,pii b)&#123; if(b.first&gt;a.second) return 0; int l=max(a.first,b.first),r=min(a.second,b.second); ll ans=1ll*(l-b.first+r-b.first)*(r-l+1)/2%mod; ans=(ans+1ll*(a.second-r)*(b.second-b.first+1))%mod; return ans;&#125;int main()&#123; int n; sc(n); rep(i,0,n) sc(p[i].first),sc(p[i].second); sort(p,p+n,cmp); rep(i,0,n) inv[i]=qpow(p[i].second-p[i].first+1,mod-2); ll ans(0); rep(i,0,n) rep(j,i+1,n) ans=(ans+inv[i]*inv[j]%mod*count(p[i],p[j])%mod)%mod; pf(&quot;%lld\\n&quot;,ans);&#125; 2020 CCPC Wannafly Winter Camp Day1 F. 乘法生 涯 之 耻 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;ll n,m,k,a[maxn],b[maxn],an[3],bn[3];ll getsum(ll c,ll x)&#123; int l=1,r=m; while(l&lt;=r)&#123; int mid=(l+r)/2; if(b[mid]*c&gt;=x) c&gt;0?r=mid-1:l=mid+1; else c&gt;0?l=mid+1:r=mid-1; &#125; return c&gt;0?m-l+1:r;&#125;int check(ll x)&#123; ll sum(0); rep(i,1,n+1) sum+=getsum(a[i],x); return sum&gt;=k;&#125;ll solve(ll l,ll r)&#123; while(l&lt;=r)&#123; ll mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; return r;&#125;int main()&#123; scl(n); scl(m); scl(k); rep(i,1,n+1) scl(a[i]),an[a[i]?a[i]&gt;0?0:1:2]++; rep(i,1,m+1) scl(b[i]),bn[b[i]?b[i]&gt;0?0:1:2]++; sort(a+1,a+n+1); sort(b+1,b+m+1); ll t=an[0]*bn[0]+an[1]*bn[1]; if(k&lt;=t) return pf(&quot;%lld\\n&quot;,solve(1ll,max(a[1]*b[1],a[n]*b[m]))),0; t+=an[2]*m+bn[2]*n-an[2]*bn[2]; if(k&lt;=t) return puts(&quot;0&quot;),0; return pf(&quot;%lld\\n&quot;,solve(min(a[1]*b[m],b[1]*a[n]),-1ll)),0;&#125; 2020 CCPC Wannafly Winter Camp Day1 I. K小数查询namo n2可以过 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int a[maxn],p[maxn];int main()&#123; int n,m; sc(n); sc(m); rep(i,1,n+1) sc(a[i]); while(m--)&#123; int op,l,r,x; sc(op); sc(l); sc(r); sc(x); if(op==1) rep(i,l,r+1) a[i]=min(a[i],x); else&#123; mst(p,0); rep(i,l,r+1) p[a[i]]++; int ans(0); rep(i,1,n+1)&#123; int at=ans; ans+=p[i]; if(at&lt;ans&amp;&amp;ans&gt;=x)&#123; pf(&quot;%d\\n&quot;,i); break; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"一道快乐的井字棋带模拟","slug":"带模拟","date":"2020-01-11T03:28:38.000Z","updated":"2021-01-26T16:43:02.633Z","comments":true,"path":"2020/01/11/带模拟/","link":"","permalink":"http://example.com/2020/01/11/%E5%B8%A6%E6%A8%A1%E6%8B%9F/","excerpt":"我过了带模拟 我好快乐 我是快乐的小熊软糖","text":"我过了带模拟 我好快乐 我是快乐的小熊软糖 题目链接吉首大学新生赛的带模拟 下井字棋问自己两步能不能赢其实也不算很大233代码长度3185 生涯之耻（不是注释应该蛮清楚的（挠头要注意的一点是如果初始局面自己已经获胜了 这个时候算wrong 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e5 + 5;char mp[3][3],c,d,t,p;map&lt;char,int&gt;aaa;int judge(char x)&#123; rep(i,0,3) if(mp[i][0]==x&amp;&amp;mp[i][1]==x&amp;&amp;mp[i][2]==x) return 1; rep(i,0,3) if(mp[0][i]==x&amp;&amp;mp[1][i]==x&amp;&amp;mp[2][i]==x) return 1; if(mp[0][0]==x&amp;&amp;mp[1][1]==x&amp;&amp;mp[2][2]==x) return 1; if(mp[0][2]==x&amp;&amp;mp[1][1]==x&amp;&amp;mp[2][0]==x) return 1; return 0;&#125;int count(char x)&#123; rep(i,0,3) if((mp[i][0]==x)+(mp[i][1]==x)+(mp[i][2]==x)&gt;=2 &amp;&amp;(mp[i][0]==&#x27;.&#x27;||mp[i][1]==&#x27;.&#x27;||mp[i][2]==&#x27;.&#x27;)) return t=1,p=i,1; rep(i,0,3) if((mp[0][i]==x)+(mp[1][i]==x)+(mp[2][i]==x)&gt;=2 &amp;&amp;(mp[0][i]==&#x27;.&#x27;||mp[1][i]==&#x27;.&#x27;||mp[2][i]==&#x27;.&#x27;)) return t=2,p=i,1; if((mp[0][0]==x)+(mp[1][1]==x)+(mp[2][2]==x)&gt;=2 &amp;&amp;(mp[0][0]==&#x27;.&#x27;||mp[1][1]==&#x27;.&#x27;||mp[2][2]==&#x27;.&#x27;)) return t=3,1; if((mp[2][0]==x)+(mp[1][1]==x)+(mp[0][2]==x)&gt;=2 &amp;&amp;(mp[2][0]==&#x27;.&#x27;||mp[1][1]==&#x27;.&#x27;||mp[0][2]==&#x27;.&#x27;)) return t=4,1; return 0;&#125;int find(char x)&#123; rep(i,0,3) if(mp[i][0]!=x&amp;&amp;mp[i][1]!=x&amp;&amp;mp[i][2]!=x) return t=1,p=i,1; rep(i,0,3) if(mp[0][i]!=x&amp;&amp;mp[1][i]!=x&amp;&amp;mp[2][i]!=x) return t=2,p=i,1; if(mp[0][0]!=x&amp;&amp;mp[1][1]!=x&amp;&amp;mp[2][2]!=x) return t=3,1; if(mp[0][2]!=x&amp;&amp;mp[1][1]!=x&amp;&amp;mp[2][0]!=x) return t=4,1; return 0;&#125;int solve()&#123; getchar(); aaa.clear(); rep(i,0,3) rep(j,0,3)&#123; mp[i][j]=getchar(); aaa[mp[i][j]]++; getchar(); &#125; c=getchar(); d=&#x27;o&#x27;+&#x27;x&#x27;-c; if(aaa[c]!=aaa[d]) return puts(&quot;wrong!&quot;); if(!aaa[&#x27;.&#x27;]||judge(d)||judge(c)) return puts(&quot;wrong!&quot;); if(aaa[&#x27;.&#x27;]==9||aaa[c]==1) return puts(&quot;Cannot win!&quot;); //一种是 自己第一步能赢 if(count(c)) return puts(&quot;LeeLdler win!&quot;); //一种是 自己不能一步赢 人机能一步赢 先堵人机 //count d 然后根据t去改mp 改完再去count c if(count(d))&#123; if(t==1) rep(i,0,3) if(mp[p][i]==&#x27;.&#x27;) mp[p][i]=c; else if(t==2) rep(i,0,3) if(mp[i][p]==&#x27;.&#x27;) mp[p][i]=c; else if(t==3) rep(i,0,3) if(mp[i][i]==&#x27;.&#x27;) mp[i][i]=c; else rep(i,0,3) if(mp[i][2-i]==&#x27;.&#x27;) mp[i][2-i]=c; return puts(count(c)?&quot;LeeLdler win!&quot;:&quot;Cannot win!&quot;); &#125; //一种是 自己和人机不能一步赢 下自己的 人机去堵 //这时候你选的应该是一个空列 指一行只有自己和空位 //如果没有空列 肯定赢不了 //一个空列有两种情况 两种都判一下 if(!find(d)) return puts(&quot;Cannot win!&quot;); else&#123; int tp1,tp2; if(t==1)&#123; rep(i,0,3) if(mp[p][i]==&#x27;.&#x27;)&#123; mp[p][i]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[p][i]==&#x27;.&#x27;)&#123; mp[p][i]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[p][tp1]=d,mp[p][tp2]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; else if(t==2)&#123; rep(i,0,3) if(mp[i][p]==&#x27;.&#x27;)&#123; mp[i][p]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[i][p]==&#x27;.&#x27;)&#123; mp[i][p]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[tp1][p]=d,mp[tp2][p]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; else if(t==3)&#123; rep(i,0,3) if(mp[i][i]==&#x27;.&#x27;)&#123; mp[i][i]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[i][i]==&#x27;.&#x27;)&#123; mp[i][i]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[tp1][tp1]=d,mp[tp2][tp2]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; else&#123; rep(i,0,3) if(mp[i][2-i]==&#x27;.&#x27;)&#123; mp[i][2-i]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[i][2-i]==&#x27;.&#x27;)&#123; mp[i][2-i]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[tp1][2-tp1]=d,mp[tp2][2-tp2]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; &#125; &#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 哈哈我过了！写模拟能直接a真的好快乐！！","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"}]},{"title":"ACM模板-稳赚个人版","slug":"ACM模板-稳赚个人版","date":"2020-01-01T12:36:36.000Z","updated":"2021-01-26T16:38:24.090Z","comments":true,"path":"2020/01/01/ACM模板-稳赚个人版/","link":"","permalink":"http://example.com/2020/01/01/ACM%E6%A8%A1%E6%9D%BF-%E7%A8%B3%E8%B5%9A%E4%B8%AA%E4%BA%BA%E7%89%88/","excerpt":"稳赚又丑又T的板子","text":"稳赚又丑又T的板子 头文件1234567891011121314151617#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scd(x) scanf(&quot;%lf&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;const double eps = 1e-10;const double PI = acos(-1.0); 字符串操作char函数1234567891011char s1[maxn], s2[maxn];char c; int n;strcat(s1,s2); // s1+=s2;strncat(s1,s2,n); // 加上s2的前n个字符strchr(s1,c); // 返回s1中第一次出现c的位置strnchr(s1,c); // 返回s1中最后一次出现c的位置strstr(s1,s2); // 返回s1中第一次出现s2的位置strcmp(s1,s2); // 比较 能比大小的strncmp(s1,s2,n); // 比前n个strcpy(s1,s2); // s1=s2;strncpy(s1,s2,n); // s1为s2前n个字符 string函数1234567891011121314string s1,s2;int pos,len; char c;s1.find(s2);// 返回值为s2第一次出现在s1的位置 // 若s2不是s1子串返回 string::nposs1.replace(pos,len,s2);// s1从pos位开始长度len的子串替换成s2s1.substr(pos,len);s1.insert(pos,s2);s1.insert(pos,s2,len);// 插入s2的前len个字符s1.insert(pos,len,c);// 插入len个cs1.erase(pos,len); 字典树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 数组版int trie[maxn][26];int cnt[maxn];void insert(char *s)&#123; int u=0; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!trie[u][tmp])&#123; trie[u][tmp]=++n; cnt[n]++; &#125; else cnt[trie[u][tmp]]++; u=trie[u][tmp]; &#125;&#125;int find(char *s)&#123; int u=0,len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!trie[u][tmp]) return 0; u=trie[u][tmp]; &#125; return cnt[u];&#125;// 指针版struct trie &#123; int cnt; trie *next[26]; trie()&#123; cnt=0; rep(i,0,26) next[i]=NULL; &#125;&#125;;trie *root,*p;void insert(char* s)&#123; p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if (p-&gt;next[tmp]==NULL) p-&gt;next[tmp]=new trie(); p=p-&gt;next[tmp]; p-&gt;cnt++; &#125;&#125;int find(char* s)&#123; p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if (p-&gt;next[tmp] == NULL) return 0; p=p-&gt;next[tmp]; &#125; return p-&gt;cnt;&#125; KMP12345678910111213141516171819202122232425262728293031323334353637int nex[maxn];void getnext(char* s)&#123; int i=0,j=-1,len=strlen(s); nex[0]=-1; while(i&lt;len)&#123; if(j==-1||s[i]==s[j])&#123; i++; j++; nex[i]=j; &#125; else j=nex[j]; &#125;&#125;int kmp(char *s1,char *s2)&#123; int i=0,j=0; getnext(s2); int len1=strlen(s1),len2=strlen(s2); while(i&lt;len1&amp;&amp;j&lt;len2)&#123; if(j==-1||s1[i]==s2[j])&#123; i++; j++; &#125; else j=nex[j]; if(j==len2) return i-j+1; &#125; return 0;&#125;/* 关于next数组应用如if(nex[pos]&amp;&amp;pos%(pos-nex[pos])==0)即有s的前pos位有(pos/(pos-nex[pos]))个长度为pos-nex[pos]的前缀*///求总前缀数 dprep(i,1,len+1)&#123; int tmp=nex[i]; while(tmp) sum++,tmp=nex[tmp];&#125;// 根据nex求s1和s2尾头衔接重叠部分s2+=&#x27;*&#x27;+s1; int q=getnext(s2); ans=s2.substr(0,q);// 套娃nex求前缀和后缀相同部分// on预处理求每个前缀在字符串中出现了几次void getnum(int len)&#123; rep(i,1,len+1) num[nex[i]]++; dep(i,len,1) num[nex[i]]+=num[i]; int t=len; while(t)&#123; vv.push_back(t),t=nex[t]; &#125; pf(&quot;%d\\n&quot;,vv.size()); sort(vv.begin(),vv.end()); for(int x:vv) pf(&quot;%d %d\\n&quot;,x,num[x]+1); // 长度和次数&#125; EXKMP12345678910111213141516171819202122232425262728293031int nex[maxn], extend[maxn];void getnext(char* s)&#123; int aa=0,len=strlen(s); nex[0]=len; while(aa&lt;len-1&amp;&amp;s[aa]==s[aa+1]) aa++; nex[1]=aa; aa=1; rep(i,2,len)&#123; int p=aa+nex[aa]-1; int l=nex[i-aa]; if(i+l-1&gt;=p)&#123; int j=(p-i+1)&gt;0?p-i+1:0; while(i+j&lt;len&amp;&amp;s[i+j]==s[j]) j++; nex[i]=j; aa=i; &#125; else nex[i]=l; &#125;&#125;void getextend(char* s1,char* s2)&#123; int aa=0; mst(nex,0); getnext(s2); int len1=strlen(s1),len2=strlen(s2); int minl=min(len1,len2); while(aa&lt;minl&amp;&amp;s1[aa]==s2[aa]) aa++; extend[0]=aa; aa=0; rep(i,1,len1)&#123; int p=aa+extend[aa]-1,l=nex[i-aa]; if(i+l-1&gt;=p)&#123; int j=(p-i+1)&gt;0?p-i+1:0; while(i+j&lt;len1&amp;&amp;j&lt;len2&amp;&amp;s1[i+j]==s2[j]) j++; extend[i]=j; aa=i; &#125; else extend[i]=l; &#125;&#125; 马拉车123456789101112int che[2*maxn];char s[maxn],ma[2*maxn];void manacher(char* s,int len0)&#123; int len=0; ma[len++]=&#x27;$&#x27;; ma[len++]=&#x27;#&#x27;; rep(i,0,len0) ma[len++]=s[i],ma[len++]=&#x27;#&#x27;; ma[len]=0; int maxx=0,num=0; rep(i,0,len)&#123; che[i]=maxx&gt;i?min(che[2*num-i],maxx-i):1; while(ma[i+che[i]]==ma[i-che[i]]) che[i]++; if(i+che[i]&gt;maxx) maxx=i+che[i],num=i; &#125;&#125; AC自动机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 计每个单词有无出现 注释里写记单词数的 以*开头int ans;struct node&#123; node* next[26]; // 最大100够的 所有题 node* fail; int end; // 在单词末尾做标记 //* int id; node()&#123; end=0; //* id=0; fail=0; mst(next,0); &#125;&#125;;node* root;// 建字典树//* int tot;void insert(char* s)&#123; node* p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if(p-&gt;next[tmp]==NULL) p-&gt;next[tmp]=new node(); p=p-&gt;next[tmp]; &#125; p-&gt;end++; //* p-&gt;id=++tot;&#125;queue&lt;node*&gt;q;// fail数组：root指向NULL 没出现过的指向root 出现过的指向前一个void getfail()&#123; root-&gt;fail=NULL; q.push(root); while(!q.empty())&#123; node* fr=q.front(); q.pop(); rep(i,0,26) if(fr-&gt;next[i])&#123; node* tem=fr-&gt;fail; while(tem)&#123; if(tem-&gt;next[i])&#123; fr-&gt;next[i]-&gt;fail=tem-&gt;next[i]; break; &#125; tem=tem-&gt;fail; &#125; if(tem==NULL) fr-&gt;next[i]-&gt;fail=root; q.push(fr-&gt;next[i]); &#125; &#125;&#125;//* num[maxn], mark[maxn], cnt;void ac_auto(char* s)&#123; node* p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; while(!p-&gt;next[tmp] &amp;&amp; p!=root) p=p-&gt;fail; p=p-&gt;next[tmp]; if(!p) p=root; node* tem=p; while(tem!=root)&#123; if(tem-&gt;end&gt;=0)&#123; ans+=tem-&gt;end; tem-&gt;end=-1; // 出现过了第二次遇到不再统计 &#125; else break; /* if(tem-&gt;id)&#123; *if(!mark[tem-&gt;id]) *num[cnt++]=tem-&gt;id; // num按在s串中出现顺序存id *mark[tem-&gt;id]++; //mark存出现与否 顺便存次数 &#125;*/ tem=tem-&gt;fail; &#125; &#125;&#125;// 虽然指针版怪弱智的 但舍不得了struct ACAM&#123; int ch[maxn][26]; int tot,num[maxn],nex[maxn]; void init()&#123; tot=1; rep(i,0,26) ch[0][i]=1; rep(i,0,26) ch[1][i]=0; &#125; void insert(char* s,int x)&#123; int n=strlen(s+1),p=1; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!ch[p][tmp])&#123; ch[p][tmp]=++tot; rep(j,0,26) ch[tot][j]=0; num[tot]=0; &#125; p=ch[p][tmp]; &#125; num[p]++; &#125; void getfail()&#123; queue&lt;int&gt;q; q.push(1); nex[1]=0; while(!q.empty())&#123; int fr=q.front(); q.pop(); rep(i,0,26) if(!ch[fr][i]) ch[fr][i]=ch[nex[fr]][i]; else nex[ch[fr][i]]=ch[nex[fr]][i],q.push(ch[fr][i]); &#125; &#125; void query(char* s)&#123; int n=strlen(s+1),p=1; cnt=0; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;,k=ch[p][tmp]; while(k&gt;1) ...,k=nex[k]; p=ch[p][tmp]; &#125; &#125;&#125;ac; 后缀数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int s[maxn];int sa[maxn],rk[maxn];int height[maxn];int t1[maxn],t2[maxn],c[maxn];int best[20][maxn];char ss[maxn];void getsa(int *s,int n,int m)&#123; int *x=t1,*y=t2; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[i]=s[i]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[i]]]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p=0; rep(i,n-k,n) y[p++]=i; rep(i,0,n) if(sa[i]&gt;=k) y[p++]=sa[i]-k; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[y[i]]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[y[i]]]]=y[i]; swap(x,y); p=1; x[sa[0]]=0; rep(i,1,n) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++; if(p&gt;=n) break; m=p; &#125;&#125;void getheight(int n)&#123; int k=0; rep(i,1,n+1) rk[sa[i]]=i; rep(i,0,n)&#123; if(k) k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k]) k++; height[rk[i]]=k; &#125;&#125;void RMQ(int n)&#123; int lg=(int)(log(n*1.0)/log(2.0)); rep(i,1,n+1) best[0][i]=height[i]; rep(i,1,lg+1) for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++) best[i][j]=min(best[i-1][j],best[i-1][j+(1&lt;&lt;i&gt;&gt;1)]); &#125;int lcp(int x,int y)&#123; x=rk[x]; y=rk[y]; if(x&gt;y) swap(x,y); x++; int lg=(int)(log(1.0*(y-x+1))/log(2.0)); return min(best[lg][x],best[lg][y-(1&lt;&lt;lg)+1]);&#125; 后缀自动机1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374struct SAM&#123; int next[maxn&lt;&lt;1][26],link[maxn&lt;&lt;1],len[maxn&lt;&lt;1]; int a[maxn&lt;&lt;1],id[maxn&lt;&lt;1],right[maxn&lt;&lt;1]; int tot,root,last; inline void init()&#123; rep(i,0,tot+1) mst(next[i],0),right[i]=0; mst(len,0); mst(link,0); tot=last=root=1; &#125; inline void extend(int x)&#123; int p=last,now=++tot; right[now]=1; len[now]=len[p]+1; while(p&amp;&amp;!next[p][x]) next[p][x]=now,p=link[p]; if(!p) link[now]=root; else&#123; int q=next[p][x]; if(len[q]==len[p]+1) link[now]=q; else&#123; int tmp=++tot; memcpy(next[tmp],next[q],sizeof(next[q])); link[tmp]=link[q]; link[q]=link[now]=tmp; len[tmp]=len[p]+1; while(p&amp;&amp;next[p][x]==q) next[p][x]=tmp,p=link[p]; &#125; &#125; last=now; &#125; inline void slove()&#123; // 拓扑排序 rep(i,1,tot+1) ++a[len[i]]; rep(i,1,tot+1) a[i]+=a[i-1]; rep(i,1,tot+1) id[a[len[i]]--]=i; // wz可能会记不得的sam简单运用： // ·s是否包含t：跑一遍t的点看next是不是都有值 // ·s不同子串个数：累加len[id[i]]-len[link[id[i]]] // ·s不同子串总长度：累加(len[id[i]]+1)*len[id[i]]/2-(len[link[id[i]]]+1)*len[link[id[i]]]/2 // ·s所有子串出现次数： int las=1; rep(i,0,n)&#123; num[next[las][s[i]-&#x27;a&#x27;]]=1; las=next[las][s[i]-&#x27;a&#x27;]; &#125; ll ans(0); dep(i,tot,1)&#123; num[link[id[i]]]+=num[id[i]]; ans+=1ll*(len[id[i]]-len[link[id[i]]])*num[id[i]]; &#125; // ·字典序第k大子串： //* op为0指计算本质不同子串 为1计算全部 if(!op) rep(i,1,tot+1) right[i]=1; else dep(i,tot,1)&#123; int t=id[i]; right[fa[t]]+=right[t]; &#125; right[1]=0; dep(i,tot,1)&#123; int t=id[i]; num[t]+=right[t]; rep(j,0,26) if(next[t][j]) num[t]+=num[next[t][j]]; &#125; if(k&gt;num[1]) return (void)pf(&quot;No such line.\\n&quot;); int now=1,cnt=0; while(k&gt;0)&#123; rep(i,0,26) if(next[now][i])&#123; if(k&lt;=num[next[now][i]])&#123; ans[cnt++]=&#x27;a&#x27;+i; now=next[now][i]; k-=right[now]; break; &#125; else k-=num[next[now][i]]; &#125; &#125; ans[cnt]=0; pf(&quot;%s\\n&quot;,ans); // ·t在s出现次数 // ·t在s出现位置 // ·多个字符串间的最长公共子串 &#125; inline void lcs()&#123; int las=1,mx(0),cnt(0); rep(i,0,m)&#123; if(!next[las][t[i]-&#x27;a&#x27;])&#123; while(las&amp;&amp;!next[las][t[i]-&#x27;a&#x27;]) las=link[las]; if(las) cnt=len[las]+1,las=next[las][t[i]-&#x27;a&#x27;]; else las=1,cnt=0; &#125; else ++cnt,las=next[las][t[i]-&#x27;a&#x27;]; mx=max(mx,cnt); &#125; pf(&quot;%d\\n&quot;,mx); &#125;&#125;sam; 最大最小表示法12345678910111213141516171819202122int getmin(char* s)&#123; int len=strlen(s); int i=0,j=1,k=0; while(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)&#123; int tmp=s[(i+k)%len]-s[(j+k)%len]; if(!tmp) k++; else&#123; if(tmp&gt;0) i+=k+1; else j+=k+1; if(i==j) j++; k=0; &#125; &#125; return min(i,j);&#125;int getmax(char* s)&#123; int len=strlen(s); int i=0,j=1,k=0; while(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)&#123; int tmp=s[(i+k)%len]-s[(j+k)%len]; if(!tmp) k++; else&#123; if(tmp&lt;0) i+=k+1; else j+=k+1; if(i==j) j++; k=0; &#125; &#125; return min(i,j);&#125; 回文树123456789101112131415161718192021222324252627282930313233343536373839// 回文树初始节点01 表示偶/奇数长度串的根节点struct PAM&#123; struct node&#123; int child[26],cnt,fail,num,len,pos; // len是从开头开始最长回文串长度 // num是以这个结点结束的回文串数 // cnt是节点表示的本质不同回文串数 &#125;tt[maxn]; int last,n,tot; char s[maxn]; inline void clear()&#123; rep(i,0,tot+1)&#123; mst(tt[i].child,0); tt[i].cnt=tt[i].fail=tt[i].len=tt[i].num=0; &#125; last=n=0; tt[0].fail=tot=1; tt[1].len=-1; &#125; inline int getfail(int x)&#123; while(s[n-tt[x].len-1]!=s[n]) x=tt[x].fail; return x; &#125; inline void add(char ch)&#123; s[++n]=ch; int cur=getfail(last); if(!tt[cur].child[ch-&#x27;a&#x27;])&#123; int now=++tot; tt[now].len=tt[cur].len+2; int p=getfail(tt[cur].fail); tt[now].fail=tt[p].child[ch-&#x27;a&#x27;]; tt[cur].child[ch-&#x27;a&#x27;]=now; tt[now].num=tt[tt[now].fail].num+1; &#125; last=tt[n].pos=tt[cur].child[ch-&#x27;a&#x27;]; ++tt[last].cnt; &#125; inline void count()&#123; dep(i,tot,0) tt[tt[i].fail].cnt+=tt[i].cnt; &#125;&#125;pam; hash123456789101112131415161718int seed[2]=&#123;27174403,19260817&#125;;// 18052103// 18271131 小燕学号 不是质数int mod; // 998244353 100000007 // 大质数 9999999999999937/17int hs[2][maxn],bas[2][maxn];void init()&#123; bas[0][0]=bas[1][0]=1; rep(j,0,2) rep(i,1,n+1)&#123; bas[j][i]=1ll*bas[j][i-1]*seed[j]%mod; hs[j][i]=1ll*hs[j][i-1]*seed[j]%mod+s[i]; if(hs[j][i]&gt;=mod) hs[j][i]-=mod; &#125; &#125;int getsum(int j,int l,int r)&#123; int res=hs[j][r]-1ll*hs[j][l-1]*bas[j][r-l+1]%mod; if(res&lt;0) res+=mod; return res;&#125; 自闭图论dijkstra1234567891011121314151617181920212223242526struct node&#123; int id,dt; bool operator &lt; (const node a) const&#123; return dt&gt;a.dt; &#125;&#125;;priority_queue&lt;node&gt;q;int n,m,s,t,tot;int dis[maxn],vis[maxn],head[maxn];int nex[maxn&lt;&lt;1],to[maxn&lt;&lt;1],val[maxn&lt;&lt;1];void addedge(int u,int v,int w)&#123; nex[++tot]=head[u]; head[u]=tot; to[tot]=v; val[tot]=w;&#125;void dij(int s)&#123; rep(i,1,n+1) dis[i]=1e9; dis[s]=0; q.push(&#123;s,0&#125;); while(!q.empty())&#123; int fr=q.top().id; q.pop(); if(vis[fr]) continue; vis[fr]++; for(int j=head[fr];j;j=nex[j]) if(dis[to[j]]&gt;val[j]+dis[fr]&amp;&amp;!vis[to[j]])&#123; dis[to[j]]=val[j]+dis[fr]; q.push(&#123;to[j],dis[to[j]]&#125;); &#125; &#125;&#125; 同余最短路12345678910// n个数有Σai*xi=b b∈[b0,b1]void slove()&#123; rep(i,0,a[0]-1) rep(j,0,n) addedge(i,(i+a[j])%a[0],a[j]); dij(0); rep(i,0,a[0]-1)&#123; int t=dis[i]; if(t&lt;b0) ans+=(b1-t)/a[0]-(b0-t-1)/a[0]; else if(t&lt;=b1) ans+=(b1-t)/a[0]+1; &#125;&#125; 稳定婚姻问题12345678910111213141516171819202122232425262728int b[maxn][maxn],g[maxn][maxn];// b 每个男生按好感位次排下来的女生// g 每个女生对应每个男生的好感度int bm[maxn],gm[maxn];// 对应异性号数int vis[maxn][maxn];void stable_marriage()&#123; mst(bm,-1); mst(gm,-1); mst(vis,0); queue&lt;int&gt; q; rep(i,1,n+1) q.push(i); int fr,nex; while(!q.empty())&#123; fr=q.front(); q.pop(); rep(i,1,m+1)&#123; nex=b[fr][i]; if(vis[fr][nex]) continue; vis[fr][nex]=1; if(gm[nex]==-1)&#123; gm[nex]=fr; bm[fr]=nex; break; &#125; else if(g[nex][gm[nex]]&gt;g[nex][fr])&#123; q.push(gm[nex]); gm[nex]=fr; bm[fr]=nex; break; &#125; &#125; &#125;&#125; 二分匹配匈牙利算法1234567891011121314151617int ans;int mp[maxn][maxn];int vis[maxn],line[maxn];void init()&#123; ans=0; mst(mp,0); mst(line,0);&#125;int dfs(int x)&#123; rep(i,1,n+1) if(!vis[i]&amp;&amp;mp[i][x])&#123; vis[i]=1; if(!line[i]||dfs(line[i])) &#123; line[i]=x; return 1; &#125; &#125; return 0;&#125;void slove()&#123; rep(i,1,n+1)&#123; mst(vis,0); if(dfs(i)) ans++; &#125;&#125; 强连通tarjan123456789101112131415161718192021222324252627282930313233int n,m,cnt,id;int dfn[maxn],low[maxn];int ins[maxn],scc[maxn];stack&lt;int&gt;s;vector&lt;int&gt;vv[maxn];void init()&#123; cnt=id=0; rep(i,0,n+1)&#123; vv[i].clear(); dfn[i]=low[i]=ins[i]=scc[i]=0; &#125;&#125;void tarjan(int x)&#123; dfn[x]=low[x]=++id; ins[x]=1; s.push(x); rep(i,0,vv[x].size())&#123; int tmp=vv[x][i]; if(!dfn[tmp])&#123; tarjan(tmp); low[x]=min(low[x],low[tmp]); &#125; else if(ins[tmp]) low[x]=min(low[x],dfn[tmp]); &#125; if(low[x]==dfn[x])&#123; int tmp; cnt++; do&#123; tmp=s.top(); s.pop(); ins[tmp]=0; scc[tmp]=cnt; &#125; while(x!=tmp); &#125;&#125;void slove()&#123; rep(i,1,n+1) if(!dfn[i]) tarjan(i); mst(ins,0); mst(out,0); rep(i,1,n+1) rep(j,0,vv[i].size()) if(scc[i]!=scc[vv[i][j]])&#123; ins[scc[vv[i][j]]]++; out[scc[i]]++; &#125;&#125; 双连通分量123456789101112131415161718192021222324252627282930313233343536// 割点：这个点一旦被删除，这张图的连通块数量会增加// 桥：这条边一旦被删除，这张图的连通块数量会增加// 带*边双int n,m,cnt,id,child;int dfn[maxn],low[maxn],isc[maxn];int num[maxn],ans,sum;vector&lt;int&gt;vv[maxn];//* vector&lt;pii&gt;bri;void init()&#123; cnt=id=child=0; rep(i,0,n+1)&#123; vv[i].clear(); dfn[i]=low[i]=isc[i]=0; &#125;&#125;void tarjan(int x,int f)&#123; dfn[x]=low[x]=++id; int ff(0); rep(i,0,vv[x].size())&#123; int tmp=vv[x][i]; if(tmp==f&amp;&amp;!ff)&#123; ff++; continue; &#125; // 重边 if(!dfn[tmp])&#123; child++; tarjan(tmp,x); low[x]=min(low[x],low[tmp]); if(low[tmp]&gt;dfn[x])&#123; isc[x]=1; // 判断这个点是否为割点 //* bri.push_back(pii(x,tmp)); &#125; &#125; else if(dfn[tmp]&lt;dfn[x]) low[x]=min(low[x],dfn[tmp]); &#125; if(f==-1&amp;&amp;child==1) isc[x]=0; // 关于根节点的特判 // 带缩点 if(dfn[x]==low[x])&#123; scc++; do...while...; &#125;&#125;void slove()&#123; rep(i,1,n+1) if(!dfn[i]) tarjan(i,-1);&#125; LCA123456789101112131415161718192021222324252627282930313233343536373839int n,m,tot,best[20][maxn&lt;&lt;1];int dis[maxn],vis[maxn],head[maxn];int nex[maxn&lt;&lt;1],to[maxn&lt;&lt;1],val[maxn&lt;&lt;1];int id[maxn&lt;&lt;1],num[maxn],dep[maxn&lt;&lt;1],cnt;void addedge(int u,int v,int w)&#123; nex[++tot]=head[u]; head[u]=tot; to[tot]=v; val[tot]=w;&#125;void dfs(int x,int f,int d)&#123; id[++cnt]=x; num[x]=cnt; dep[cnt]=d; for(int i=head[x];i;i=nex[i])&#123; int y=to[i],z=val[i]; if(y==f) continue; dis[y]=dis[x]+z; dfs(y,x,d+1); id[++cnt]=x; dep[cnt]=d; &#125;&#125;void ST(int n)&#123; int lg=(int)(log(n*1.0)/log(2.0)); rep(i,1,n+1) best[0][i]=i; rep(i,1,lg+1) for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++)&#123; int t1=best[i-1][j],t2=best[i-1][j+(1&lt;&lt;i&gt;&gt;1)]; best[i][j]=dep[t1]&lt;dep[t2]?t1:t2; &#125;&#125;int RMQ(int x,int y)&#123; if(x&gt;y) swap(x,y); int lg=(int)(log(1.0*(y-x+1))/log(2.0)); int t1=best[lg][x],t2=best[lg][y-(1&lt;&lt;lg)+1]; return dep[t1]&lt;dep[t2]?t1:t2;&#125;int LCA(int x,int y)&#123; int t1=num[x],t2=num[y]; return id[RMQ(t1,t2)];&#125;int getdis(int x,int y)&#123; return dis[x]+dis[y]-2*dis[LCA(x,y)];&#125;void slove()&#123; dfs(1,-1,1); ST(2*n-1);&#125; 数据结构并查集1234567int find(int x)&#123; return vis[x]==x?x:vis[x]=find(vis[x]);&#125;void change(int x, int y)&#123; int c=find(x),d=find(y); if(c!=d) vis[c]=d;&#125; 树状数组12345678910int tree[maxn];int lowbit(int i)&#123; return i&amp;(-i); &#125;void update(int i,int x)&#123; for(;i&lt;=maxn;i+=lowbit(i)) tree[i]+=x;&#125;int query(int n)&#123; int ans=0; for(int i=n;i&gt;0;i-=lowbit(i)) ans+=tree[i]; return ans;&#125; 线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 单点更新，加*区间更新#define lson (rt&lt;&lt;1)#define rson ((rt&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)int segtree[4*maxn];//* int lazy[4*maxn];void pushup(int rt)&#123; segtree[rt]=segtree[lson]+segtree[rson];&#125;/** void pushdown(int rt,int begin,int end)&#123; if (!lazy[rt]) return; segtree[lson]+=(mid-begin+1)*lazy[rt]; segtree[rson]+=(end-mid)*lazy[rt]; lazy[lson]+=lazy[rt]; lazy[rson]+=lazy[rt]; lazy[rt]=0;&#125;*/void build(int rt,int begin,int end)&#123; //* lazy[rt]=0; if(begin==end)&#123; sc(segtree[rt]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushup(rt);&#125;void update(int rt,int begin,int end,int pos,int a)&#123; if(pos&lt;begin||pos&gt;end) return; if(begin==end)&#123; segtree[rt]+=a; return; &#125; update(lson,begin,mid,pos,a); update(rson,mid+1,end,pos,a); pushup(rt);&#125;/** void update(int rt,int begin,int end,int left,int right,int a)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; segtree[rt]+=(end-begin+1)*a; lazy[rt]+=a; return; &#125; pushdown(rt,begin,end); update(lson,begin,mid,left,right,a); update(rson,mid+1,end,left,right,a); pushup(rt);&#125;*/int slove(int rt,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segtree[rt]; //* pushdown(rt,begin,end); int ans=0; ans+=slove(lson,begin,mid,left,right); ans+=slove(rson,mid+1,end,left,right); return ans;&#125; DP数位dp12345678910111213141516171819202122int a[20]; // 位数 一般题目最大1e18ll dp[20][state];ll dfs(int pos,int pre,/*int state,*/int limit)&#123; // pos位数 pre之前状态 与dp数组对应 // state各种情况包括前导零 具体看题目 limit前一位限制 if(pos==-1) return 1; // 计数，具体看题目 if(!limit&amp;&amp;dp[pos][pre]!=-1/*&amp;&amp;!state*/) return dp[pos][pre]; int last=limit?a[pos]:9; ll ans=0; rep(i,0,last+1)&#123; if(...) ans+=dfs(pos-1,...,/*...,*/limit&amp;&amp;i==a[pos]); else(...) &#125; if(!limit/*&amp;&amp;!state*/) dp[pos][pre]=ans; return ans;&#125;ll slove(ll x)&#123; mst(dp,-1); // 多组数据只用最开始mst一次 因为保证边界就可以了 int pos=0; while(x)&#123; a[pos++]=x%10; x/=10; &#125; return dfs(pos-1,0,/*...,*/1);&#125; 数学常见公式12// 1-n的平方和 n*(n+1)*(2*n+1)/6// 1-n的立方和 n*n*(n+1)*(n+1)/4 快速幂12345678910111213ll qpow(ll a,ll b)&#123; ll ans=1; for(;b&gt;0;b&gt;&gt;=1)&#123; if(b&amp;1) ans=ans*a%mod; a=a*a%mod; &#125; return ans;&#125;// 十进制ksm 大数幂次ll qpow(ll a,char* s)&#123; int len=strlen(s); ll res=1,q=1; dep(i,len-1,0)&#123; rep(j,1,s[i]-&#x27;0&#x27;+1) res=res*a%mod; a=a*a%mod; q=a*a%mod; q=q*q%mod; a=q*a%mod; &#125; return res;&#125; 快速乘123456789101112131415ll qmul(ll a,ll b,ll p)&#123; a%=p; ll ans(0); while(b&gt;0)&#123; if(b&amp;1) ans+=a; if(ans&gt;=p) ans-=p; b&gt;&gt;=1; a+=a; if(a&gt;=p) a-=p; &#125; return ans;&#125; // ologll modMul(ll a,ll b,ll p)&#123; if(p&lt;=1000000000) return a*b%p; else if(p&lt;=1000000000000ll) return (((a*(b&gt;&gt;20)%p)&lt;&lt;20)+(a*(b&amp;((1&lt;&lt;20)-1))))%p; else&#123; ll d=(ll)floor(a*(long double)b/p+0.5); ll ret=(a*b-d*p)%p; if (ret&lt;0) ret+=p; return ret; &#125;&#125; // o1 模逆元12345678910111213// exgcdvoid exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1; y=0; return; &#125; exgcd(b,a%b,y,x); y-=(a/b)*x; return;&#125;ll inv(ll a,ll p)&#123; ll x,y; exgcd(a,p,x,y); return (x%p+p)%p;&#125; // 好像比ksm快的// qpowinv=qpow(a,mod-2,mod);// 递推inv[i]=(mod-mod/i)*inv[mod%i]%mod; 组合数12345678910111213141516// 预处理写法int jc[maxn],inv[maxn];void init()&#123; jc[0]=inv[0]=1; rep(i,1,maxn) jc[i]=1ll*jc[i-1]*i%mod; inv[maxn-1]=qpow(jc[maxn-1],mod-2,mod); dep(i,maxn-2,1) inv[i]=1ll*inv[i+1]*(i+1)%mod;&#125;int C(int s,int x)&#123; return 1ll*jc[x]*inv[s]%mod*inv[x-s]%mod;&#125;// lucasll Lucas(ll n,ll m,ll p)&#123; ll ans=1; while(n|m) ans=ans*C(n%p,m%p)%p,n/=p,m/=p; return ans;&#125; 素数判断12345678910111213141516171819202122232425262728bool isPrime(ll n)&#123; if(n==2||n==3||n==5) return 1; if(n%2==0||n%3==0||n%5==0||n==1) return 0; ll c=7,a[8]=&#123;4,2,4,2,4,6,2,6&#125;; while(c*c&lt;=n) for(auto i:a)&#123; if(n%c==0) return 0; c+=i; &#125; return 1;&#125; // 抠// n极大时素数测试算法ll Rand()&#123; static ll x=(srand((int)time(0)),rand()); x+=1000003; if(x&gt;mod) x-=mod; return x;&#125;bool Witness(ll a,ll n)&#123; ll t=0,u=n-1; while(!(u&amp;1)) u&gt;&gt;=1,t++; ll x=fpow(a,u,n),y; while(t--)&#123; y=x*x%n; if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1) return true; x=y; &#125; return x!=1;&#125;bool MillerRabin(ll n,ll s)&#123; if(n==2||n==3||n==5) return 1; if(n%2==0||n%3==0||n%5==0||n==1) return 0; while(s--) if(Witness(Rand()%(n-1)+1,n)) return false; return true;&#125; 求最小素因数123456789int p[maxn/3],mpf[maxn],pn;void init()&#123; int tmp; rep(i,2,maxn)&#123; if(!mpf[i]) p[pn++]=i,mpf[i]=i; for(int j=0;(tmp=i*p[j])&lt;maxn;j++)&#123; mpf[tmp]=p[j]; if(!(i%p[j])) break; &#125; &#125;&#125; Pollard’s rho123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 对于比较大的数分解因数typedef pair&lt;ll,int&gt; pli;namespace pollard_rho&#123; const int C=2307; const int S=10; mt19937 rd(time(0)); vector&lt;ll&gt;ve; ll gcd(ll a,ll b)&#123; while((a%=b)&amp;&amp;(b%=a)); return a+b; &#125; ll mul(ll a,ll b,ll mod)&#123; return (__int128)a*b%mod; &#125; ll qpow(ll a,ll b,ll mod)&#123; ll res=1; a%=mod; while(b&gt;0)&#123; if(b&amp;1) res=mul(res,a,mod); b&gt;&gt;=1; a=mul(a,a,mod); &#125; return res; &#125; bool check(ll a,ll n)&#123; ll m=n-1,x,y; int j=0; while(!(m&amp;1))m&gt;&gt;=1,j++; x=qpow(a,m,n); for(int i=1;i&lt;=j;x=y,i++)&#123; y=mul(x,x,n); if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1) return 1; &#125; return y!=1; &#125; bool miller_rabin(ll n)&#123; ll a; if(n==1) return 0; if(n==2) return 1; if(!(n&amp;1)) return 0; for(int i=0;i&lt;S;i++) if(check(rd()%(n-1)+1,n)) return 0; return 1; &#125; ll pollard_rho(ll n,int c)&#123; ll i=1,k=2,x=rd()%n,y=x,d; while(1)&#123; i++; x=(mul(x,x,n)+c)%n,d=gcd(y-x,n); if(d&gt;1&amp;&amp;d&lt;n) return d; if(y==x) return n; if(i==k) y=x,k&lt;&lt;=1; &#125; &#125; void findfac(ll n,int c)&#123; if(n==1) return; if(miller_rabin(n))&#123; ve.push_back(n); return; &#125; ll m=n; while(m==n) m=pollard_rho(n,c--); findfac(m,c); findfac(n/m,c); &#125; vector&lt;pli&gt; solve(ll n)&#123; vector&lt;pli&gt;res; ve.clear(); findfac(n,C); sort(ve.begin(),ve.end()); for(auto x:ve)&#123; if(res.empty()||res.back().first!=x) res.push_back(&#123;x,1&#125;); else res.back().second++; &#125; return res; &#125;&#125; 中国剩余定理123456789101112131415161718192021ll a[maxn],r[maxn];ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1; y=0; return a; &#125; else&#123; ll ans=exgcd(b,a%b,y,x); y-=(a/b)*x; return ans; &#125;&#125;int excrt()&#123; ll m1,r1,m2,r2; ll x,y,t,c,d; m1=a[0],r1=r[0]; rep(i,1,tot)&#123; m2=a[i],r2=r[i]; c=r2-r1; d=exgcd(m1,m2,x,y); if(c%d) return puts(&quot;-1&quot;); t=m2/d; x*=c/d; x=(x%t+t)%t; r1=x*m1+r1; m1=m1*m2/d; r1=(r1%m1+m1)%m1; &#125; return pf(&quot;%d\\n&quot;,r1);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 大数版import java.math.*;import java.util.*;public class Main &#123; public static BigInteger[] exgcd(BigInteger a,BigInteger b)&#123; BigInteger ans; BigInteger[] result=new BigInteger[3]; if(b.compareTo(BigInteger.ZERO)==0)&#123; result[0]=a; result[1]=BigInteger.ONE; result[2]=BigInteger.ZERO; return result; &#125; BigInteger[] tmp=exgcd(b,a.mod(b)); ans=tmp[0]; result[0]=ans; result[1]=tmp[2]; result[2]=tmp[1].subtract((a.divide(b).multiply(tmp[2]))); return result; &#125; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); BigInteger a[]=new BigInteger[105]; BigInteger r[]=new BigInteger[105]; int n; n=sc.nextInt(); for(int i=0;i&lt;n;i++)&#123; a[i]=sc.nextBigInteger(); r[i]=sc.nextBigInteger(); &#125; BigInteger m1,m2,r1,r2,t,c; BigInteger[] d; m1=a[0]; r1=r[0]; for(int i=1;i&lt;n;i++)&#123; m2=a[i]; r2=r[i]; c=r2.subtract(r1); d=exgcd(m1,m2); if(c.mod(d[0]).compareTo(BigInteger.ZERO)!=0)&#123; System.out.println(&quot;-1&quot;); return; &#125; t=m2.divide(d[0]); d[1]=d[1].multiply(c.divide(d[0])).mod(t); r1=d[1].multiply(m1).add(r1); m1=m1.multiply(t); r1=r1.mod(m1); &#125; d=exgcd(BigInteger.ONE,m1); if(r1.mod(d[0]).compareTo(BigInteger.ZERO)!=0)&#123; System.out.println(&quot;-1&quot;); return; &#125; t=m1.divide(d[0]); d[1]=d[1].multiply(r1.divide(d[0])).mod(t); System.out.println(d[1]); &#125;&#125; (ex)bsgs1234567891011121314// 求解a^x=b(mod p)ll bsgs(ll a,ll b,ll p)&#123; unordered_map&lt;ll,ll&gt;tab; tab.clear(); ll u=(ll)ceil(sqrt(p)),ans; rep(i,0,u+1)&#123; if(!i) ans=b%p,tab[ans]=i; else ans=ans*a%p,tab[ans]=i; &#125; ll sum=qpow(a,u,p); ans=1; if(!sum) return b?-1:1; rep(i,1,u+1)&#123; ans=ans*sum%p; if(tab[ans]) return u*i-tab[ans]; &#125; return -1;&#125; 打表素数及莫比乌斯函数 1234567891011int p[maxn],u[maxn],vis[maxn],pn;void init()&#123; u[1]=1; rep(i,2,maxn)&#123; if(!vis[i]) p[pn++]=i,u[i]=-1; for(int j=0;j&lt;pn&amp;&amp;i*p[j]&lt;maxn;j++)&#123; vis[i*p[j]]=1; if(i%p[j]) u[i*p[j]]=-u[i]; else &#123; u[i*p[j]]=0; break; &#125; &#125; &#125;&#125; 反素数123456789101112int n,p[]=&#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53&#125;;ll ans=1e18; // n个因数void dfs(int pos,ll v,int num)&#123; if(num&gt;n||pos&gt;15) return; if(num==n) return ans=min(ans,v),(void)0; for(int i=1;i&lt;64;i++)&#123; if(v&gt;ans/p[pos]||num*(i+1)&gt;n) break; v*=p[pos]; if(!(n%(num*(i+1)))) dfs(pos+1,v,num*(i+1)); &#125;&#125;void slove()&#123; dfs(0,1,1); &#125;// ans是因数有n个的最小正整数 欧拉函数12345678910ll getphi(ll x)&#123; ll res=x; rep(i,2,x+1)&#123; if(1ll*i*i&gt;x) break; if(x%i==0)&#123; res=res/i*(i-1); while(x%i==0) x/=i; &#125; &#125; if(x&gt;1) res=res/x*(x-1); return res;&#125; 欧拉降幂1234// 求qpow(a,b,p)有if(__gcd(a,p)==1) ans=qpow(a,b%phi(p),p);else if(__gcd(a,p)&gt;1&amp;&amp;b&lt;phi(p)) ans==qpow(a,b,p);else ans=qpow(a,b%phi(p)+phi(p),p); BM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657namespace linear_seq&#123; const int N=101100; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt;Md; void mul(ll *a,ll *b,int k)&#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if(_c[i]) rep(j,0,Md.size()) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int slove(ll n,vector&lt;int&gt; a,vector&lt;int&gt; b)&#123; // a系数 b初值 b[n+1]=a[0]*b[n]+... ll ans=0,pnt=0; int k=a.size(); assert((int)a.size()==(int)b.size()); Md.clear(); rep(i,0,k) _md[k-1-i]=-a[i]; _md[k]=1; rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while((1ll&lt;&lt;pnt)&lt;=n) pnt++; dep(p,pnt,0)&#123; mul(res,res,k); if((n&gt;&gt;p)&amp;1)&#123; dep(i,k-1,0) res[i+1]=res[i];res[0]=0; rep(j,0,Md.size()) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if(ans&lt;0) ans+=mod; return ans; &#125; vector&lt;int&gt; BM(vector&lt;int&gt; s)&#123; vector&lt;int&gt; C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,s.size())&#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if(d==0) ++m; else if(2*L&lt;=n)&#123; vector&lt;int&gt; T=C; ll c=mod-d*qpow(b,mod-2)%mod; while((int)C.size()&lt;(int)B.size()+m) C.push_back(0); rep(i,0,B.size()) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else&#123; ll c=mod-d*qpow(b,mod-2)%mod; while((int)C.size()&lt;(int)B.size()+m) C.push_back(0); rep(i,0,B.size()) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int qaq(vector&lt;int&gt; a,ll n)&#123; vector&lt;int&gt; c=BM(a); c.erase(c.begin()); rep(i,0,c.size()) c[i]=(mod-c[i])%mod; return slove(n,c,vector&lt;int&gt;(a.begin(),a.begin()+(int)c.size())); &#125;&#125;;int slove()&#123; vector&lt;int&gt;vv; ll tmp(0); rep(i,1,maxn)&#123; tmp=...; vv.push_back(tmp); &#125; ll ans=linear_seq::qaq(vv,n-1); return printf(&quot;%lld\\n&quot;,ans);&#125; 二次剩余12345678910111213141516171819202122bool judge(ll a,ll p)&#123; // 判断a是否为p的二次剩余 p是素数 return qpow(a,(p-1)&gt;&gt;1,p)==1;&#125;ll Shanks(ll a,ll p)&#123; // 求解二次同余方程x^2=a(mod p) p是素数 if(a==0) return 0; ll q=p-1,e=0; while(!(q&amp;1)) q&gt;&gt;=1,e++; static mt19937_64 rd(time(0)); ll n=rd()%(p-1)+1; // 随机选取p的一个非二次剩余，若p为定值，n也可为定值 while(judge(n,p)) n=rd()%(p-1)+1; ll z=qpow(n,q,p),y=z,r=e,x=qpow(a,(q-1)&gt;&gt;1,p),b=a*x%p*x%p; x=a*x%p; while(b!=1)&#123; ll temp=b*b%p,m=1; while(temp!=1) (temp*=temp)%=p,m++; if(m==r) return -1; ll t=y; rep(i,1,r-m-1)(t*=t)%=p; y=t*t%p,r=m%p,x=x*t%p,b=b*y%p; &#125; return x;&#125; fft123456789101112131415161718192021222324252627282930313233typedef complex&lt;double&gt; cd;const double PI = acos(-1.0);void change(cd* f,int n)&#123; int j=n&gt;&gt;1; rep(i,1,n-1)&#123; if(i&lt;j) swap(f[i],f[j]); int k=n&gt;&gt;1; while(j&gt;=k)&#123; j-=k; k&gt;&gt;=1; &#125; if(j&lt;k) j+=k; &#125;&#125;void fft(cd* f,int n,int dft)&#123; // n为多项式位数 change(f,n); for(int step=1;step&lt;n;step&lt;&lt;=1)&#123; // 合并 cd wn=exp(cd(0,dft*PI/step)); for(int j=0;j&lt;n;j+=step&lt;&lt;1)&#123; cd wnk(1,0); for(int k=j;k&lt;j+step;k++)&#123; cd x=f[k],y=wnk*f[k+step]; f[k]=x+y; // F(x)=G(x)+ωH(x) f[k+step]=x-y; wnk*=wn; &#125; &#125; &#125; if(dft==-1) rep(i,0,n) f[i]/=n; // IDFT需要整个矩阵的内容乘上1/n &#125;cd a[maxn],b[maxn]; int ans[maxn];void slove()&#123; int mx=...,L=1; while(L&lt;mx*2) L&lt;&lt;=1; mst(ans,0); fft(a,L,1); fft(b,L,1); rep(i,0,L) a[i]=a[i]*b[i]; fft(a,L,-1); rep(i,0,L) ans[i]=(int)(a[i].real()+0.5);&#125; fwt123456789101112131415161718192021222324void fwt_or(int *a,int op)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;++k) if(op==1) a[i+j+k]=(a[j+k]+a[i+j+k])%mod; else a[i+j+k]=(a[i+j+K]-a[j+K]+mod)%mod;&#125; void fwt_and(int *a,int op)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;++k) if(op==1) a[j+k]=(a[j+k]+a[i+j+k])%mod; else a[j+k]=(a[j+K]-a[i+j+K]+mod)%mod;&#125; void fwt_xor(int *a,int op)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;++k)&#123; int x=a[j+k],y=a[i+j+k]; a[j+k]=(x+y)%mod,a[i+j+k]=(x-y+mod)%mod; if(op==-1) a[j+k]=1ll*a[j+k]*inv2%mod, a[i+j+k]=1ll*a[i+j+k]*inv2%mod; &#125;&#125; 拉格朗日插值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465namespace polysum&#123; const int D = 1e5 + 5; ll a[D],f[D],g[D],p1[D],p2[D],b[D],h[D][2],C[D]; ll qpow(ll a,ll b)&#123; ll ans=1; for(;b;b&gt;&gt;=1)&#123; if(b&amp;1) ans=ans*a%mod; a=a*a%mod; &#125; return ans; &#125; void init(int M)&#123; f[0]=f[1]=g[0]=g[1]=1; rep(i,2,M+5) f[i]=f[i-1]*i%mod; g[M+4]=qpow(f[M+4],mod-2); dep(i,M+3,2) g[i]=g[i+1]*(i+1)%mod; &#125; // 已知f(0),f(1)..f(d) 求 f(n) ll calcn(ll d,ll *a,ll n)&#123; // a[0].. a[d] a[n] if(n&lt;=d) return a[n]; p1[0]=p2[0]=1; rep(i,0,d+1)&#123; ll t=(n-i+mod)%mod; p1[i+1]=p1[i]*t%mod; &#125; rep(i,0,d+1)&#123; ll t=(n-d+i+mod)%mod; p2[i+1]=p2[i]*t%mod; &#125; ll ans(0); rep(i,0,d+1)&#123; ll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod; if((d-i)&amp;1) ans=(ans-t+mod)%mod; else ans=(ans+t)%mod; &#125; return ans; &#125; // 已知 f(0),f(1)...f(m),求\\sum_&#123;i=0 &#125;^&#123;n&#125; f[i] ll polysum(ll m,ll *a,ll n)&#123; // a[0].. a[m] ll b[D]; rep(i,0,m+1) b[i]=a[i]; b[m+1]=calcn(m,b,m+1); rep(i,1,m+2) b[i]=(b[i-1]+b[i])%mod; return calcn(m+1,b,n-1); &#125; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i ll qpolysum(ll R,ll n,ll *a,ll m) &#123; if(R==1) return polysum(n,a,m); a[m+1]=calcn(m,a,m+1); ll r=qpow(R,mod-2),p3=0,p4=0,c,ans; h[0][0]=0; h[0][1]=1; rep(i,1,m+2)&#123; h[i][0]=(h[i-1][0]+a[i-1])*r%mod; h[i][1]=h[i-1][1]*r%mod; &#125; rep(i,0,m+2)&#123; ll t=g[i]*g[m+1-i]%mod; if(i&amp;1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod; else p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod; &#125; c=qpow(p4,mod-2)*(mod-p3)%mod; rep(i,0,m+2) h[i][0]=(h[i][0]+h[i][1]*c)%mod; rep(i,0,m+2) C[i]=h[i][0]; ans=(calcn(m,C,n)*qpow(R,n)%mod-c)%mod; if(ans&lt;0) ans+=mod; return ans; &#125;&#125; 博弈1234567891011121314151617181920212223242526272829/* 巴什博弈：一堆物品n两人轮流取物，一次最多m根据n%(m+1)是否为零判断胜者 *//* 威佐夫博奕：两堆物品a、b两人轮流取物，一次只能在一堆任意取或是两堆取同样多 //默认a&lt;b根据(int)((double)(1.0+sqrt(4.0))/2.0)*(b-a))是否等于a判断胜者扩展威佐夫博弈：两堆物品a、b两人轮流取物，一次只能在一堆任意取或是两堆取相差不超过k的 //默认a&lt;b */if(a&gt;b) swap(a,b);if(a==1) return puts(b==k+2?&quot;0&quot;:&quot;1&quot;);if(a==k+2||b==k+2) return puts(&quot;1&quot;);ll r=(b-a)%(k+1); if(r) return puts(&quot;1&quot;);double t=(1.0-k+sqrt(1ll*(k+1)*(k+1)+4.0))/2.0;ll q=(b-a)/(k+1); q=(ll)q*t;return puts(q==a?&quot;0&quot;:&quot;1&quot;);/* Fibonacci博弈：一堆物品n，两人轮流取物，每一次能取的个数是上一次的两倍以内，最后取完胜n为Fibonacci数时先手败 */// k倍动态减法// 一堆石头 第一步可以拿1~n-1个石头 之后每步最多拿上一步的k倍int a[maxn],b[maxn];int slove()&#123; int n,k; sc(n); sc(k); a[0]=b[0]=1; int i=0,j=0; while(n&gt;a[i])&#123; i++; a[i]=b[i-1]+1; while(a[j+1]*k&lt;a[i]) j++; if(a[j]*k&lt;a[i]) b[i]=b[j]+a[i]; else b[i]=a[i]; &#125; if(a[i]==n) return puts(&quot;lose&quot;); // 先手败 int ans; while(n)&#123; if(n&gt;=a[i]) n-=a[i],ans=a[i]; i--; &#125; return pf(&quot;%d\\n&quot;,ans); // 第一步所拿最少数&#125; 斐波那契求循环节1234567/*给定一个数n 求%n的斐波那契循坏节长度len·n为质数且5是模n的二次剩余 len为(n-1)的因子·n为质数且5不为模n的二次剩余 len为(2n+2)的因子·n为质数p的k次 len为lenp*p^(k-1)·n分解为质因数 len为每个质因数循环节长度的lcm*/ 计算几何二维几何123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// 一般形式// 直线L上两点(x1,y1),(x2,y2);// 直线外一点P(x0,y0);// L表示为Ax+By+C=0;double A,B,C;A=y2-y1; B=x1-x2; C=x2*y1-x1*y2;// 点到直线距离ddouble d=fabs(A*x0+B*y0+C)/sqrt(A*A+B*B);// 点到直线垂足H(x, y)double x,y;x=(B*B*x0-A*B*y0-A*C)/(A*A+B*B);y=(-A*B*x0+A*A*y0-B*C)/(A*A+B*B);// 点关于直线的对称点P&#x27;(_x, _y);double k,_x,_y;k=-2*(A*x0+B*y0+C)/(A*A+B*B); _x=x0+k*A; _y=y0+k*B;// 求三角形内整数点个数// 三角形三个顶点坐标(x1, y1), (x2, y2), (x3, y3) 都为整数点int t1,t2,t3; // 三边上整数点个数t1=gcd(abs(x1-x2),abs(y1-y2));t2=gcd(abs(x3-x2),abs(y3-y2));t3=gcd(abs(x1-x3),abs(y1-y3));int num; // 三角形内整数点num=abs((x2-x1)*(y3-y2)-(x3-x2)*(y2-y1))/2;num-=(t1+t2+t3)/2-1; // 皮克定理// 一个格点多边形有 S=a+b/2-1;// S面积 a内部格点数 b边上格点数// 结构体形式struct point&#123; double x,y; point(double _x=0,double _y=0)&#123; x=_x,y=_y; &#125; point operator+ (const point&amp; a) const&#123; return point(x+a.x,y+a.y); &#125; point operator- (const point&amp; a) const&#123; return point(x-a.x,y-a.y); &#125; point operator* (double a) const&#123; return point(x*a,y*a); &#125;&#125;; // 点struct line&#123; point s,e; line(point a,point b)&#123; s=a,e=b; &#125; line()&#123;&#125;&#125;; // 线int dcmp(double x)&#123; if(x&gt;eps) return 1; return x&lt;-eps?-1:0;&#125;double getdis(point a, point b)&#123; double xx=a.x-b.x,yy=a.y-b.y; return sqrt(xx*xx+yy*yy);&#125; // 两点距离double multi(point a,point b,point c)&#123; double xa,ya,xb,yb; xa=b.x-a.x; ya=b.y-a.y; xb=c.x-b.x; yb=c.y-b.y; return xa*xb+ya*yb;&#125; // 点乘double cross(point a,point b,point c)&#123; double xa,ya,xb,yb; xa=b.x-a.x; ya=b.y-a.y; xb=c.x-a.x; yb=c.y-a.y; return xa*yb-xb*ya;&#125; // 叉乘int judgec(line a,line b)&#123; if (max(a.s.x,a.e.x)&gt;=min(b.s.x,b.e.x) &amp;&amp; max(a.s.y,a.e.y)&gt;=min(b.s.y,b.e.y) &amp;&amp; max(b.s.x,b.e.x)&gt;=min(a.s.x,a.e.x) &amp;&amp; max(b.s.y,b.e.y)&gt;=min(a.s.y,a.e.y) &amp;&amp; cross(a.s,b.s,b.e)*cross(a.e,b.s,b.e)&lt;=0 &amp;&amp; cross(b.s,a.s,a.e)*cross(b.e,a.s,a.e)&lt;=0 ) return 1; else return 0;&#125; // 判断线段是否相交point getpoi(point a,point b,point c,point d)&#123; double u=cross(a,b,c),v=cross(b,a,d); return point((c.x*v+d.x*u)/(u+v),(c.y*v+d.y*u)/(u+v));&#125; // 求交点double parea(point p[],int n)&#123; if(n&lt;3) return 0; double ans=0; p[n]=p[0]; rep(i,0,n) ans+=p[i].x*p[i+1].y-p[i+1].x*p[i].y; return ans/2;&#125; // 多边形面积// 求两个多边形面积交/并double CPIA(point a[],point b[],int n1,int n2)&#123; if(n2&lt;3) return 0; point p[15],t[15]; a[n1]=a[0]; b[n2]=b[0]; memcpy(p,b,sizeof(point)*(n2+1)); rep(i,0,n1)&#123; int f1=dcmp(cross(a[i],a[i+1],p[0])),tn=0; rep(j,0,n2)&#123; if(f1&gt;=0) t[tn++]=p[j]; int f2=dcmp(cross(a[i],a[i+1],p[j+1])); if((f1^f2)==-2) t[tn++]=getpoi(a[i],a[i+1],p[j],p[j+1]); f1=f2; &#125; memcpy(p,t,sizeof(point)*tn); n2=tn; p[n2]=p[0]; &#125; return parea(p,n2);&#125;double SPIA(point a[],point b[],int n1,int n2)&#123; point t1[5],t2[5]; a[n1]=t1[0]=a[0]; b[n2]=t2[0]=b[0]; double res=0; rep(i,2,n1)&#123; t1[1]=a[i-1]; t1[2]=a[i]; int f1=dcmp(cross(t1[0],t1[1],t1[2])); if(f1&lt;0) swap(t1[1],t1[2]); rep(j,2,n2)&#123; t2[1]=b[j-1]; t2[2]=b[j]; int f2=dcmp(cross(t2[0],t2[1],t2[2])); if(f2&lt;0) swap(t2[1],t2[2]); res+=CPIA(t1,t2,3,3)*f1*f2; &#125; &#125; return fabs(res); //面积交 //return fabs(parea(a,n1)+parea(b,n2)-res); //面积并 &#125;double gx, gy;void find_gra()&#123; double area=0,tmp; rep(i,1,n-1)&#123; tmp=(p[i].x-p[0].x)*(p[i+1].y-p[0].y)-(p[i+1].x-p[0].x)*(p[i].y-p[0].y); area+=tmp; gx+=(p[0].x+p[i].x+p[i+1].x)*tmp; gy+=(p[0].y+p[i].y+p[i+1].y)*tmp; &#125; gx=gx/3/area, gy=gy/3/area;&#125; // 求重心坐标 二维凸包12345678910111213141516171819// 以下凸包Grahamint top;point p[maxn],s[maxn];int iszero(double x)&#123; return fabs(x)&lt;eps; &#125;int cmp(point a,point b)&#123; double tt=multi(a,b,p[0]); if(tt&gt;0||iszero(tt)&amp;&amp;getdis(a,p[0])&lt;getdis(b,p[0])) return 1; return 0;&#125;void graham() &#123; point tmp; rep(i,1,n) if(p[i].y&lt;p[0].y||(p[i].y==p[0].y&amp;&amp;p[i].x&lt;p[0].x)) swap(p[0],p[i]); sort(p+1,p+n,cmp); s[0]=p[0]; s[1]=p[1]; s[2]=p[2]; top=2; rep(i,3,n)&#123; while(top&gt;=2&amp;&amp;multi(s[top-1],s[top],p[i])&lt;=eps) top--; s[++top]=p[i]; &#125;&#125; Java快读123456789101112131415161718192021222324252627282930import java.io.*;public class Main &#123; public static void main(String[] args) throws IOException &#123; // 这句是io流包装，记住就好 StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); /*in.resetSyntax(); in.whitespaceChars(0, 32); in.wordChars(&#x27;0&#x27;, &#x27;9&#x27;); in.wordChars(&#x27;-&#x27;, &#x27;.&#x27;); in.wordChars(&#x27;+&#x27;, &#x27;+&#x27;); in.wordChars(&#x27;a&#x27;, &#x27;z&#x27;); in.wordChars(&#x27;A&#x27;, &#x27;Z&#x27;); in.wordChars(0xa0, 0xff); in.slashSlashComments(true); in.slashStarComments(true); in.quoteChar(&#x27;&quot;&#x27;); in.quoteChar(&#x27;\\&#x27;&#x27;);*/ // 以上加上可以将数字当字符串读 // StreamTokenizer.TT_EOF这个是个参数，就是EOF while (in.nextToken() != StreamTokenizer.TT_EOF) &#123; String n = in.sval; in.nextToken(); // 没记错是换行 double m = in.nval; int a = (int) in.nval; out.println(m); out.flush(); // 刷新，不然max会留在缓冲区 &#125; &#125;&#125; 高精度123456789101112131415161718import java.math.*;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); // 普通读入 while(sc.hasNext())&#123; // 大数常见函数 BigInteger.valueOf(); // int转大数 BigInteger a = new BigInteger(/*val:*/&quot;&quot;); BigInteger b = new BigInteger(/*String*/); BigInteger array[]=new BigInteger[maxn]; add(); subtract(); multiply(); divide(); compareTo(); mod(); pow(); gcd(); // 理论上大部分有补全的 System.out.println(a.stripTrailingZeros().toPlainString()); // 实数的输出去除末尾0 Arrays.sort(a,0,n); // 数组排序 &#125; &#125;&#125; 其他各种函数12345is_sorted(a+l,a+r); // 判断数组a在区间是否有序__builtin_popcount(x); // 计算二进制x有几个1__builtin_popcountll(x); // ll模式 末尾加个llprev_permutation(iterator strat,iterator end);next_permutation(iterator strat,iterator end); pbds1234567891011121314151617181920212223// 平衡树#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/tree_policy.hpp&gt;using namespace __gnu_pbds;tree&lt;/*int*/,null_type,greater&lt;/*int*/&gt;,rb_tree_tag,tree_order_statistics_node_update&gt; T;// 第一个参数是数据类型// 第二个要填null_type，低版本编译器填null_mapped_type// 第三个填比较函数 std::greater&lt;&gt; or std::less&lt;&gt; or cmp// 第四个填树的类型，有rb_tree_tag红黑树和splay_tree_tag// 第五个是为了支持查询第k大和排名的一个参数T.insert(x); T.erase(x); T.lower_bound(x);int rk=(int)T.order_of_key(x)+1; // 查询一个数的排名int num=(int)*T.find_by_order(x-1)); //查询第k大的数 返回迭代器// rope#include&lt;ext/rope&gt;using namespace __gnu_cxx;rope&lt;/*int*/&gt;r;r.push_back(x); // 在末尾添加xr.insert(pos,x); // 在pos插入x，自然支持整个char数组的一次插入r.erase(pos,x); // 从pos开始删除x个r.copy(pos,len,x); // 从pos开始到pos+len为止用x代替r.replace(pos,x); // 从pos开始换成xr.substr(pos,x); // 提取pos开始x个 指令集优化123#pragma GCC optimize(3)#pragma GCC optimize(&quot;Ofast,no-stack-protector&quot;)#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native&quot;) 关同步1ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 快读123456inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch)) w|=ch==&#x27;-&#x27;,ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-&#x27;0&#x27;,ch=getchar(); return w?-x:x;&#125; __int128输入输出1234567891011void scan(__int128 &amp;x)&#123; x=0; int op=1; char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;) op=(c==&#x27;-&#x27;?-1:1),c=getchar(); while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#x27;0&#x27;,c=getchar(); x*=op;&#125;void print(__int128 x)&#123; if(x&lt;0)&#123; x=-x; putchar(&#x27;-&#x27;); &#125; if(x&gt;9) print(x/10); putchar(x%10+&#x27;0&#x27;);&#125; 随机12mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count());int rnd(int x)&#123; return mrand()%x; &#125; 给逆元求概率123456789101112void slove(ll pa,ll xa,ll pb,ll xb,ll &amp;a,ll &amp;b)&#123; ll tmp=(pa-1)/xa; if(tmp+1&lt;=pb/xb)&#123; a=tmp+1; b=1; return; &#125; pa-=tmp*xa; pb-=tmp*xb; slove(xb,pb,xa,pa,b,a); a+=tmp*b; &#125;void getsample()&#123; ll p,x,a,b; scl(p); scl(x); // p模的质数 x结果 slove(p,x,p,x-1,a,b); ll c=x*a-p*b; pf(&quot;%lld/%lld\\n&quot;,c,a);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"板子","slug":"板子","permalink":"http://example.com/tags/%E6%9D%BF%E5%AD%90/"}]},{"title":"2019流水账总结","slug":"2019流水账总结","date":"2019-12-31T12:08:01.000Z","updated":"2021-01-26T16:39:01.021Z","comments":true,"path":"2019/12/31/2019流水账总结/","link":"","permalink":"http://example.com/2019/12/31/2019%E6%B5%81%E6%B0%B4%E8%B4%A6%E6%80%BB%E7%BB%93/","excerpt":"没干什么的2019","text":"没干什么的2019 2019对我来说 是很没有概念的一年日常生活都是训练画稿摸鱼 每天都很一样一月开始寒假的专题训练二月画了hgame的稿三月进了正式队四月做了vidar兔初设五月染了个头 保持每日写题打卡 挺拼的经常趴在电脑旁就睡着了qwq六月有了世界上最好看的老婆海洋之星 但是打铜了呜呜七月留着暑假集训了 开心八月继续集训 好喜欢集训的日子 睡到中午然后去实验室打比赛/补题 很纯粹九月开始忙招新 cfrating开始涨十月好像也没干嘛？可能是没比赛打心态有点小崩 不过养起来了各种好习惯十一月恢复训练了 cf蓝了 睡了两次实验室 开始忙d3的稿 两头跑累死十二月和ylh在一起了 cf1802了 当上了副队除了1205没有什么很特殊的时候了qwq 每天都一样 很普通 普通到一眨眼2019就已经过去了对于acm 有过迷茫 有过挣扎 有过痛苦 但更多的还是热爱吧 “如果你觉得打acm痛苦多于快乐 那才算不适合” 希望wenzhuan继续加油 希望cf稳在1800 还希望自己能当一个独当一面的选手 保证单刷稳铜qwqqq关于ylh 其实没在一起前就想过要写他 网易云年初的签是“遇到你生命里很珍贵的人”还真应了 还是好兄弟的时候就把他看得很重了 一起刷题一起跑步一起吃饭一起比赛 以致我甚至有段时间产生了很严重的依赖 害怕一个人吃饭一个人跑步一个人打比赛 他是我生活里不可或缺的一部分 是我的良好习惯 是我永遇乐的寄托能成是“我这个防ak题为了放他的傻逼代码1a调了一个月的数据” 十月底做梦梦到他和我表白 当场吓醒 因为真的很怕失去这样的一个好朋友 做了一个月的心理准备 觉得如果是他的话 也不是不可以 后来感觉测了几次样例 也放他过了 最后就理所当然地1a好喜欢他啊 我都不知道我能这么喜欢一个人 嘻嘻有在看我博客的 新年快乐呀 嘻嘻","categories":[{"name":"w&y","slug":"w-y","permalink":"http://example.com/categories/w-y/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"哈理工2019新生赛解题报告","slug":"哈理工2019新生赛解题报告","date":"2019-12-21T07:30:28.000Z","updated":"2021-01-26T16:43:12.585Z","comments":true,"path":"2019/12/21/哈理工2019新生赛解题报告/","link":"","permalink":"http://example.com/2019/12/21/%E5%93%88%E7%90%86%E5%B7%A52019%E6%96%B0%E7%94%9F%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"没啥好写的但毕竟也是ak了","text":"没啥好写的但毕竟也是ak了 来看压行小天才的表演 A: 会长的烦心事题目链接 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int len[15];int change(char c)&#123; if(c==&#x27;l&#x27;) return 0; if(c==&#x27;e&#x27;) return 1; if(c==&#x27;a&#x27;) return 2; if(c==&#x27;g&#x27;) return 3; if(c==&#x27;u&#x27;) return 4; if(c==&#x27;o&#x27;) return 5; if(c==&#x27;f&#x27;) return 6; return 7;&#125;int main()&#123; string s; while(cin&gt;&gt;s)&#123; int n=s.length(); rep(i,0,7) len[i]=0; rep(i,0,n) len[change(s[i])]++; len[0]/=2; len[1]/=2; int mn=1e9; rep(i,0,7) mn=min(mn,len[i]); cout&lt;&lt;mn&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; B: 快来秒掉我！题目链接嗯！第一次写php（逃 1Do you want to play ACM?(yes\\no) C: 素数圆环题目链接暴搜 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int n,cas,ans[25],vis[25];int p[25]=&#123;0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1&#125;;void dfs(int x)&#123; if(x&gt;n&amp;&amp;p[ans[n]+1]) rep(i,1,n+1) cout&lt;&lt;ans[i]&lt;&lt;(char)(i==n?&#x27;\\n&#x27;:&#x27; &#x27;); if(x&lt;=n) rep(i,2,n+1) if(!vis[i]&amp;&amp;p[i+ans[x-1]])&#123; vis[i]=1; ans[x]=i; dfs(x+1); vis[i]=0; &#125;&#125;void solve()&#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;++cas&lt;&lt;&quot;:\\n&quot;; ans[1]=1; if(n%2==0) dfs(2); cout&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) solve();&#125; D: 电脑磨损程度题目链接委屈，它卡cout精度 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int solve(int n)&#123; if(n&lt;=4) return cout&lt;&lt;10&lt;&lt;&#x27;\\n&#x27;,0; int r=n%8,c=n/8; if(!r) return cout&lt;&lt;c*18&lt;&lt;&#x27;\\n&#x27;,0; if(r==1) return cout&lt;&lt;c*18+2&lt;&lt;&quot;.4&quot;&lt;&lt;&#x27;\\n&#x27;,0; if(r==2) return cout&lt;&lt;c*18+4&lt;&lt;&quot;.8&quot;&lt;&lt;&#x27;\\n&#x27;,0; if(r==3) return cout&lt;&lt;c*18+7&lt;&lt;&quot;.2&quot;&lt;&lt;&#x27;\\n&#x27;,0; if(r==4) return cout&lt;&lt;c*18+9&lt;&lt;&quot;.6&quot;&lt;&lt;&#x27;\\n&#x27;,0; return cout&lt;&lt;c*18+10+(r-4)*2&lt;&lt;&#x27;\\n&#x27;,0;&#125;int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n) solve(n);&#125; E: ACMer如何拯救小学生题目链接 123456789101112#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;string s;int main()&#123; int _; cin&gt;&gt;(_); getchar(); while(_--)&#123; getline(cin,s); int n=s.length(); string t=&quot;&quot;; t+=toupper(s[0]); rep(i,1,n)&#123; if(s[i-1]==&#x27; &#x27;&amp;&amp;s[i]!=&#x27; &#x27;) t+=toupper(s[i]); &#125; cout&lt;&lt;t&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; F: 当会长和一群手贱的耗子在电梯相遇题目链接算因数个数 123456789101112#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)using namespace std;typedef long long ll;void solve(ll n)&#123; ll cnt(0); rep(i,1,1e8)&#123; if(i*i&gt;n) break; if(n%i==0) cnt+=i*i==n?1:2; &#125; puts(cnt&amp;1?&quot;Goddess,I&#x27;m coming~~~&quot;:&quot;Farewell~&quot;);&#125;int main()&#123; ll n; while(cin&gt;&gt;n&amp;&amp;n) solve(n);&#125; G: ACMer分奖金题目链接 1234567891011121314#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int main()&#123; int _; cin&gt;&gt;_; while(_--)&#123; int num[10]; rep(i,0,6) num[i]=0; int n; cin&gt;&gt;n; rep(i,0,n)&#123; int a; cin&gt;&gt;a; num[0]+=a/100; a%=100; num[1]+=a/50; a%=50; num[2]+=a/20; a%=20; num[3]+=a/10; a%=10; num[4]+=a/5; a%=5; num[5]+=a; &#125; int sum(0); rep(i,0,6) sum+=num[i]; cout&lt;&lt;sum&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; H: 放轻松题目链接 12345678910#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;double a[15];int main()&#123; int n; while(cin&gt;&gt;n)&#123; rep(i,0,n) cin&gt;&gt;a[i]; sort(a,a+n); rep(i,0,n) printf(&quot;%.2lf &quot;,a[i]); cout&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; I: ACM协会晚会题目链接组合数 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;const int mod = 1e18;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1,y=0; return; &#125; else&#123; exgcd(b,a%b,y,x); y-=(a/b)*x; return; &#125;&#125;ll C(int s,int x)&#123; if(s&gt;x-s) s=x-s; ll ans=1,tmp=1,xx,y; rep(i,1,s+1) ans=ans*(x-i+1)%mod,tmp=tmp*i%mod; exgcd(tmp,mod,xx,y); ans=(ans*xx%mod+mod)%mod; return ans;&#125;int solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; if(m&gt;n) return puts(&quot;0&quot;); return cout&lt;&lt;C(m,n)&lt;&lt;&#x27;\\n&#x27;,0;&#125;int main()&#123; int _; cin&gt;&gt;_; while(_--) solve();&#125; J: 会长爱旅游题目链接bfs 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 1e5 + 5;vector&lt;int&gt;vv[maxn];int vis[maxn],ans[maxn];void bfs(int s)&#123; queue&lt;int&gt;q; q.push(s); while(!q.empty())&#123; int fr=q.front(); q.pop(); for(int t:vv[fr]) if(!vis[t]) vis[t]=1,ans[t]=fr,q.push(t); &#125;&#125;int main()&#123; int _; cin&gt;&gt;_; while(_--)&#123; int n,s; cin&gt;&gt;n&gt;&gt;s; mst(vv,0); rep(i,1,n)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; vv[x].push_back(y); vv[y].push_back(x); &#125; ans[s]=-1; vis[s]=1; bfs(s); rep(i,1,n+1) cout&lt;&lt;ans[i]&lt;&lt;(char)(i==n?&#x27;\\n&#x27;:&#x27; &#x27;); &#125;&#125; 压行选手是这么牛逼的","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"}]},{"title":"余心往期graffiti归档","slug":"余心graffiti作品集","date":"2019-12-15T04:00:11.000Z","updated":"2021-01-26T16:44:05.395Z","comments":true,"path":"2019/12/15/余心graffiti作品集/","link":"","permalink":"http://example.com/2019/12/15/%E4%BD%99%E5%BF%83graffiti%E4%BD%9C%E5%93%81%E9%9B%86/","excerpt":"持续更新。","text":"持续更新。 不可商用，其他使用请先授权 上海 17.9graffiti初尝试 风格模仿很像土嗨= = MATURITY 17.9风格模仿配色还是ok的 Monster 17.11经 典 配 色 19.3绘制矢量版本// 当时画得离谱 之后补图 浙江 18.7 ZXJ 18.8爱上了cdr HDU 18.12第一次户外涂鸦 Respite 18.12.31第一次真·上墙坐标：31号楼地下车库 HDUART 19.3-19.4和学姐一起的涂墙！自己只做了一小点点点","categories":[{"name":"y","slug":"y","permalink":"http://example.com/categories/y/"}],"tags":[{"name":"design","slug":"design","permalink":"http://example.com/tags/design/"}]},{"title":"余心往期字设归档","slug":"余心字设作品集","date":"2019-12-15T03:59:39.000Z","updated":"2021-01-26T16:44:21.484Z","comments":true,"path":"2019/12/15/余心字设作品集/","link":"","permalink":"http://example.com/2019/12/15/%E4%BD%99%E5%BF%83%E5%AD%97%E8%AE%BE%E4%BD%9C%E5%93%81%E9%9B%86/","excerpt":"持续更新。","text":"持续更新。 不可商用，其他使用请先授权HGAME logo/集训队logo应该随意，自行使用8，当然能说一声更好啦 2017AM 山鬼 Respite 怒放 青山见我 世界和平合唱节 凹凸相关 更多见余心的lofter 林余心 THREE 清平乐 清鹤体“参加方正字体设计比赛是我的梦想，只要参加就够了”很羡慕当时的热情 2018平心静气 扇子高考前的摸鱼 莲子清如水 疏狂 2019HGAME logo HDUACM集训队logo好丑，不想放图 Vidar-Team 2019夏季会服 灵感 Vidar-Team招新海报 D^3CTF相关 Vidar-Team 2019秋冬会服","categories":[{"name":"y","slug":"y","permalink":"http://example.com/categories/y/"}],"tags":[{"name":"design","slug":"design","permalink":"http://example.com/tags/design/"}]},{"title":"Codeforces Round #604解题报告","slug":"Codeforces-Round-604解题报告","date":"2019-12-06T03:53:26.000Z","updated":"2021-01-26T16:41:02.354Z","comments":true,"path":"2019/12/06/Codeforces-Round-604解题报告/","link":"","permalink":"http://example.com/2019/12/06/Codeforces-Round-604%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"突然想更博呗","text":"突然想更博呗 rk553 rating+35一边打一边看学弟改的稿子233 有点小炸下辈子再也不倒开了.jpg A: Beautiful String题目链接题意：希望构造一个邻位不相同的只有abc的字符串 给定一个带有’?’的串 ‘?’可以任意替换为abc 问能不能构造出符合要求的串一开始被卡了一下 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define sc(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;char s[maxn];int solve()&#123; scs(s); int len=strlen(s); if(s[0]==&#x27;?&#x27;&amp;&amp;s[1]!=&#x27;a&#x27;) s[0]=&#x27;a&#x27;; else if(s[0]==&#x27;?&#x27;) s[0]=&#x27;b&#x27;; if(s[len-1]==&#x27;?&#x27;&amp;&amp;s[len-2]!=&#x27;a&#x27;) s[len-1]=&#x27;a&#x27;; else if(s[len-1]==&#x27;?&#x27;) s[len-1]=&#x27;b&#x27;; rep(i,1,len-1) if(s[i]==&#x27;?&#x27;)&#123; if(s[i-1]==&#x27;a&#x27;)&#123; if(s[i+1]!=&#x27;b&#x27;) s[i]=&#x27;b&#x27;; else s[i]=&#x27;c&#x27;; &#125; else&#123; if(s[i+1]!=&#x27;a&#x27;) s[i]=&#x27;a&#x27;; else if(s[i-1]==&#x27;b&#x27;) s[i]=&#x27;c&#x27;; else s[i]=&#x27;b&#x27;; &#125; &#125; rep(i,1,len) if(s[i-1]==s[i]) return puts(&quot;-1&quot;); pf(&quot;%s\\n&quot;,s); return 0;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; B: Beautiful Numbers题目链接题意：给定n和初始序列 问在1到n中的i有哪些满足在初始序列中存在区间长度为i且区间内只有1-i的数真好写啊 我为什么不先写B判一下左右就行 写得复杂了一点 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define sc(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[maxn],ans[maxn];pii p[maxn];int solve()&#123; int n,pos; sc(n); rep(i,1,n+1)&#123; sc(a[i]); p[i].first=a[i]; p[i].second=i; &#125; sort(p+1,p+n+1); ans[1]=1; int l=1e9,r=0; rep(i,1,n+1)&#123; l=min(l,p[i].second); r=max(r,p[i].second); if(r-l&gt;=i) ans[i]=0; else if(r-l&lt;i) ans[i]=1; else ans[i]=0; &#125; rep(i,1,n+1) pf(&quot;%d&quot;,ans[i]); pf(&quot;\\n&quot;);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; C: Beautiful Regional Contest题目链接题意：分金银铜牌 规则是获得金牌的人题数严格大于得银牌的 银牌的严格大于铜牌的 金牌数严格小于银牌数和铜牌数 三个牌子的总和不多于总人数的一半 给定人数和过题数 希望牌子尽量多 输出方案贪心 金牌只取最多过题数的人数 银牌取到比金牌多就break 铜剩下 判是否符合要求 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;int a[maxn],vis[maxn];int main()&#123; int _; sc(_); while(_--)&#123; int n,a0; sc(n); sc(a0); rep(i,0,a0+1) vis[i]=0; a[1]=a0; vis[a0]++; rep(i,2,n+1) sc(a[i]),vis[a[i]]++; int mid=n/2; if(a[mid]==a[mid+1])&#123; while(a[mid]==a[mid+1]) mid--; &#125; int aa,b=0,c=0; aa=vis[a0]; dep(i,a0-1,0) if(vis[i])&#123; b+=vis[i]; if(b&gt;aa) break; &#125; if(b&lt;=aa||aa+b&gt;=mid)&#123; pf(&quot;0 0 0\\n&quot;); continue; &#125; c=mid-aa-b; if(c&lt;=aa)&#123; pf(&quot;0 0 0\\n&quot;); continue; &#125; pf(&quot;%d %d %d\\n&quot;,aa,b,c); &#125;&#125; D: Beautiful Sequence题目链接题意：给abcd四个数 代表有a个0 b个1 c个2 d个3 问能不能构成相邻位差值绝对值为1的序列本来以为是细节题 思维还是不够缜密很多请况没考虑到233看了dls代码 写的是按题意模拟 真好看啊 wxhtxdytxdy 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[5],b[5];vector&lt;int&gt;vv; int main()&#123; rep(i,0,4) sc(a[i]); rep(i,0,4)&#123; rep(j,0,4) b[j]=a[j]; if(!b[i]) continue; int x=i; vv.clear(); while(1)&#123; vv.push_back(x); b[x]--; if(x&amp;&amp;b[x-1]) x--; else if(x!=3&amp;&amp;b[x+1]) x++; else break; &#125; if(!b[0]&amp;&amp;!b[1]&amp;&amp;!b[2]&amp;&amp;!b[3])&#123; pf(&quot;YES\\n&quot;); rep(i,0,vv.size()) pf(&quot;%d &quot;,vv[i]); return pf(&quot;\\n&quot;),0; &#125; &#125; return pf(&quot;NO\\n&quot;),0;&#125; E: Beautiful Mirrors题目链接文字先咕了 好困 随缘更 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1) ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;ll a[maxn],q1[maxn],q2[maxn];int main()&#123; int n; sc(n); rep(i,0,n) scl(a[i]); ll t=qpow(100,mod-2); q1[n]=q2[n]=0; dep(i,n-1,0)&#123; q1[i]=a[i]*t%mod*q1[i+1]%mod; q1[i]++; q1[i]%=mod; q2[i]=a[i]*t%mod*q2[i+1]%mod; q2[i]+=t*(100-a[i])%mod; q2[i]%=mod; &#125; ll ans=q1[0]*qpow((1-q2[0]+mod)%mod,mod-2)%mod; pf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"Codeforces Round #598解题报告","slug":"Codeforces-Round-598解题报告","date":"2019-11-06T05:35:17.000Z","updated":"2021-01-26T16:40:56.175Z","comments":true,"path":"2019/11/06/Codeforces-Round-598解题报告/","link":"","permalink":"http://example.com/2019/11/06/Codeforces-Round-598%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"全绿的第一场不好意思说是题解 就解题报告吧（天哪稳赚终于更博了","text":"全绿的第一场不好意思说是题解 就解题报告吧（天哪稳赚终于更博了 先反思一下 B这个傻逼暴力场上没调出来 真的弟弟这场+11 我什么时候上蓝啊555贪心场√ A: Payment Without Change题目链接题意：有a个n b个1 问能不能凑到s以为会炸int 赛后想了想好像也不会233 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)using namespace std;typedef long long ll;ll a,b,n,s;int solve()&#123; if(a*n+b&lt;s) return puts(&quot;NO&quot;),0; int x=min(a,s/n); if(x*n+b&gt;=s) return puts(&quot;YES&quot;),0; else return puts(&quot;NO&quot;),0;&#125;int main()&#123; int _; sc(_); while(_--)&#123; scl(a); scl(b); scl(n); scl(s); solve(); &#125;&#125; B: Minimize the Permutation题目链接题意：给定一个1~n的排列 要操作最多n-1次相邻位交换且每个位置只能交换一次 使最终结果序列字典序最小 输出此序列暴力莽 写得有点丑 一个活脱脱的&gt;号我开始压行后就没写过这么丑的代码 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[105],v[105];int main()&#123; int _; sc(_); while(_--)&#123; int n; sc(n); rep(i,1,n+1) sc(a[i]),v[i]=0; int c(0); rep(i,1,n+1)&#123; rep(j,1,n+1)&#123; if(a[j]==i)&#123; int k=j; while(k&gt;1)&#123; if(v[k]) break; if(a[k]&lt;a[k-1])&#123; swap(a[k],a[k-1]); c++; v[k]++; &#125; else break; k--; &#125; break; &#125; &#125; if(c==n) break; &#125; rep(i,1,n+1) pf(&quot;%d &quot;,a[i]); pf(&quot;\\n&quot;); &#125;&#125; C: Platforms Jumping题目链接题意：一道河长n 有m个木板 第i个木板长c[i] 人一次可以跳d格 问这个人能否过河 能的话输出方案贪心 判完YES后先让这个人一直跳尽量远 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[1005],s;int main()&#123; int n,m,k; sc(n); sc(m); sc(k); rep(i,1,m+1) sc(a[i]),s+=a[i]; if(n-s&gt;(m+1)*(k-1)) pf(&quot;NO\\n&quot;); else&#123; int n1=n; pf(&quot;YES\\n&quot;); n-=s; n++; rep(i,1,m+2)&#123; int t=min(k,n); rep(j,0,t-1) pf(&quot;0 &quot;); rep(j,0,a[i]) pf(&quot;%d &quot;,i); n-=t-1; &#125; &#125;&#125; D: Binary String Minimizing题目链接题意：给定一个长度为n的01串 问交换最多k次后字典序最小的串是什么贪心 直接for一遍 不过还是写麻烦了233k没开ll wa了一次 qswl 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;const int maxn = 1e6 + 5;char s[maxn];vector&lt;int&gt;v;int main()&#123; int _; sc(_); while(_--)&#123; int n; ll k; sc(n); scl(k); scs(s); v.clear(); rep(i,0,n) if(s[i]==&#x27;0&#x27;) v.push_back(i); int pos(0); rep(i,0,n) if(s[i]==&#x27;0&#x27;) pos++; else break; rep(i,0,v.size())&#123; if(v[i]&lt;pos) continue; int t=min(1ll*v[i]-1ll*pos,k); if(t&lt;k) swap(s[v[i]],s[pos]); else swap(s[v[i]],s[v[i]-k]); k-=t; pos++; if(k&lt;=0) break; &#125; pf(&quot;%s\\n&quot;,s); &#125;&#125; E: Yet Another Division Into Teams题目链接题意：n个人每个人能力为a[i] 一个队的差距指最大值减最小值 要把这些人划分成k个至少3人的队 希望每个队差异总和最小 求总和 队数 成员划分是个dp 我看题解写的呜呜呜 没什么好说的 官方题解更好懂 wtcl 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define pf printf#define INF 0x3f3f3f3f#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;const int maxn = 2e5 + 5;pair&lt;int,int&gt;a[maxn];int dp[maxn],t[maxn],r[maxn];int main()&#123; int n,cnt(0); sc(n); rep(i,0,n) sc(a[i].first),a[i].second=i; sort(a,a+n); rep(i,1,n+1) dp[i]=INF; rep(i,0,n) rep(j,3,6)&#123; if(i+j&gt;n) break; if(dp[i+j]&gt;dp[i]+a[i+j-1].first-a[i].first)&#123; dp[i+j]=dp[i]+a[i+j-1].first-a[i].first; r[i+j]=i; &#125; &#125; int now=n; while(now)&#123; dep(i,now-1,r[now]) t[a[i].second]=cnt; cnt++; now=r[now]; &#125; pf(&quot;%d %d\\n&quot;,dp[n],cnt); rep(i,0,n) pf(&quot;%d &quot;,t[i]+1); pf(&quot;\\n&quot;);&#125; F: Equalizing Two Strings题目链接题意：给定串s和t 每次可以在s和t中翻转长度相同的子串 问是否有可能使s和t相同问施老师的 11-nb！翻转长度为len的区间可以等价为多次相邻交换 将字符串换成递增的 需要逆序对次 如果逆序对数相同或者差为偶数（换两次等同于不变）则可以 如果有一个串的字母有两个以上 这就可以和这个字母不受限地交换 所以也可以啊我说的啥啊 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 2e5 + 5;int n,c[30],d[30];char s[maxn],t[maxn];int solve()&#123; int t1(0),t2(0); rep(i,0,n)&#123; c[s[i]-&#x27;a&#x27;]++,d[t[i]-&#x27;a&#x27;]++; rep(j,s[i]-&#x27;a&#x27;+1,26) t1+=c[j]; rep(j,t[i]-&#x27;a&#x27;+1,26) t2+=d[j]; &#125; rep(i,0,26) if(c[i]!=d[i]) return 0; rep(i,0,26) if(c[i]&gt;=2||d[i]&gt;=2) return 1; return (t1-t2)%2==0;&#125;int main()&#123; int _; sc(_); while(_--)&#123; sc(n); scs(s); scs(t); mst(c,0); mst(d,0); if(solve()) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"Java大数基本操作","slug":"Java大数基本操作","date":"2019-05-10T09:32:07.000Z","updated":"2021-01-26T16:41:15.222Z","comments":true,"path":"2019/05/10/Java大数基本操作/","link":"","permalink":"http://example.com/2019/05/10/Java%E5%A4%A7%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"试着整理我看Java的过程嗷","text":"试着整理我看Java的过程嗷 一直知道Java大数nb 一直口嗨学Java 一直没动机缘巧合之下 看到我rank10058 想快乐rank四位数 又懒得开新题 干脆Java搞个1042（求N!）先搜题解一行行搜看懂什么意思后交了我看的题解是BigDecimal 但这题BigInteger就行我后来也BigInteger过了下面就放BigInteger的ac代码了=。= 1234567891011121314151617181920212223import java.math.BigInteger; import java.util.Scanner;// 大数头文件和输入头文件public class Main &#123; public static void main(String[] args) &#123; // 格式吧 Scanner sc = new Scanner(System.in); // Scanner输入 这应该就是一句标准格式吧233 while(sc.hasNext())&#123; // while(有输入) BigInteger n = sc.nextBigInteger(); // 格式 BigInteger m=new BigInteger(&quot;1&quot;); // 格式 for(int i=2;i&lt;=n.intValue();i++)&#123; // 一个挺c的for m = m.multiply(BigInteger.valueOf(i)); // 函数格式 &#125; System.out.println(m.toString()); // 转成字符串输出 不过不转也行 &#125; &#125;&#125; 真·一行一注释了！看懂了就 快乐交题 ac++; rank=9949;然后去魔改代码 用在线编译跑 整自闭了 还是下了IDEA配了环境 啊要死不过当时没选好题 没选水的然后搜索关键词：hdoj 大数 Javaget到hdoj上的Java大数水题 BigInteger的有1002 // 两个大数相加1047 // 大数累加1715 // 求斐波那契 直接大数相加1316 // 求区间有几个斐波那契数 大数加完for一遍1297 // 递推+大数加法然后 BigInteger基本函数： 1234567891011121314151617181920212223242526BigInteger a, b;a = BigInteger.valueOf(b); // a=b;int c;a = BigInteger.valueOf(c); // 类型转换String s = &quot;111&quot;;a = BigInteger.valueOf(s); // 运行后a==111;a = BigInteger(&quot;111&quot;); // 赋值常量a = sc.nextInteger(); // 赋值输入a = a.add(b); // a+=b;a = a.subtract(b); // a-=b;a = a.multiply(b); // a*=b;a = a.divide(b); // a/=b;/* 函数里的值也是BigInteger 如果是具体数值 格式：a.add(new BigInteger(&quot;1&quot;));是前面变量 格式：a.add(BigInteger.valueOf(i));特殊的 0 1 10 可以用BigInteger.ZERO\\ONE\\TEN;*/if(a.compareTo(b)&gt;0) System.out.println(a&gt;b); if(a.compareTo(b)==0) System.out.println(a==b);if(a.compareTo(b)&lt;0) System.out.println(a&lt;b);remainder(); mod(); // 都是a%bpow(); gcd(); // a^b 最大公约数abs(); negate(); // 绝对值 相反数max(); min();// 定义数组格式BigInteger array[]=new BigInteger[maxn]; 然后BigDecimal 12345678import java.math.BigDecimal; // 头文件BigDecimal a, b;a = sc.nextBigDecimal();a = new BigDecimal(111);a = new BigDecimal(b);// 函数和BigInteger差不太多嗷 就有的语法有的小小区别System.out.println(a.stripTrailingZeros().toPlainString());// 这个是 输出时去除多余末尾0 好用！！ hdoj BigDecimal水题首先BigInteger的用BigDecimal应该也能做？1753 // 加法2054 // 比较1063 // a^b问题然后说点题外话？配完Java环境后我发现我的hexo命令不能用辽 Google后跟着教程是 在高级系统设置中的环境变量的PATH加了node_modules\\.bin和nodejs的路径 就可以辣！","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"杭师校赛I题-Little Sub and Enigma AC代码","slug":"Little-Sub-and-Enigma题解","date":"2019-03-18T02:13:12.000Z","updated":"2021-01-26T16:41:23.120Z","comments":true,"path":"2019/03/18/Little-Sub-and-Enigma题解/","link":"","permalink":"http://example.com/2019/03/18/Little-Sub-and-Enigma%E9%A2%98%E8%A7%A3/","excerpt":"不难 听了出题人讲思路马上就会 但我就是要搞题解 纪念我的赛场自闭四小时","text":"不难 听了出题人讲思路马上就会 但我就是要搞题解 纪念我的赛场自闭四小时 最坑的是25对推第26对双向映射一一对应直接数组存感觉也许是输在英语不好？ 题目：Little Sub and Enigma DescriptionLittle Sub builds a naive Enigma machine of his own. It can only be used to encrypt/decrypt lower-case letters by giving each letter a unique corresponding lower-case letter. In order to ensure the accuracy, no contradiction or controversy is allowed in both the decryption and the encryption, which means all lower-case letters can only be decrypted/encrypted into a distinct lower-case letter.Now we give you a string and its encrypted version. Please calculate all existing corresponding relationship which can be observed or deducted through the given information.InputThe first line contains a string S, indicating the original message.The second line contains a string T , indicating the encrypted version.The length of S and T will be the same and not exceed 1000000.Outputwe use a string like ’x-&gt;y’ to indicate that letter x will be encrypted to letter y.Please output all possible relationships in the given format in the alphabet order.However, if there exists any contradiction in the given information, please just output Impossible in one line.AuthorYE, Zicheng 放一下出题人，zjunb AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int a[27], b[27];string s1, s2;int main() &#123; while (cin &gt;&gt; s1 &gt;&gt; s2) &#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); int flag = 0; for (int i = 0; i &lt; s1.length(); i++) &#123; int t1, t2; t1 = s1[i] - &#x27;a&#x27; + 1; t2 = s2[i] - &#x27;a&#x27; + 1; if (!a[t1]) a[t1] = t2; else if (a[t1] != t2) &#123; cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; flag = 1; break; &#125; if (!b[t2]) b[t2] = t1; else if (b[t2] != t1) &#123; cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; flag = 1; break; &#125; //复读，双向存 &#125; if (flag) continue; //上面break的是for，还需要一个continue，晕了 int ai, bi = 0; int cnt = 0; for (int i = 1; i &lt;= 26; i++) &#123; if (a[i] == 0) cnt++, ai = i; if (cnt &gt;= 2) continue; &#125; if (cnt == 1) for (int i = 1; i &lt;= 26; i++) if (b[i] == 0) bi = i; if (bi) a[ai] = bi;//25推26 for (int i = 1; i &lt;= 26; i++) &#123; if (a[i] ) &#123; char tmp1, tmp2; tmp1 = i - 1 + &#x27;a&#x27;; tmp2 = a[i] - 1 + &#x27;a&#x27;; cout &lt;&lt; tmp1 &lt;&lt; &quot;-&gt;&quot; &lt;&lt; tmp2 &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 其他题莫得了 太菜了","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"ZSTUoj 4433-Suffix Zeroes（暴力枚举）","slug":"Suffix-Zeroes题解","date":"2019-03-16T13:01:55.000Z","updated":"2021-01-26T16:41:37.760Z","comments":true,"path":"2019/03/16/Suffix-Zeroes题解/","link":"","permalink":"http://example.com/2019/03/16/Suffix-Zeroes%E9%A2%98%E8%A7%A3/","excerpt":"这两天和队友聊了一下理工新生赛，提到我暴力枚举A掉的这题，干脆搞个题解了时效性确实是 过了","text":"这两天和队友聊了一下理工新生赛，提到我暴力枚举A掉的这题，干脆搞个题解了时效性确实是 过了 题目：Suffix Zeroes Description这个游戏超休闲的~。现在你需要找一个自然数n，你找的自然数需要满足n!的末尾恰好有k个0（当然我们都是十进制下的数，n! = 123…n）。比如：5！= 120，尾部恰好有一个0。Input 先输入T，代表有T组数据（T ≤10000）接下来的T行每一行都包括一个数字k（1≤k≤108）。具体含义请见题意。Output 如果能找到这样的数，请输出满足条件的最小的自然数n，如果不存在这样的自然数，请输出impossible。Sample Input215Sample OutputCase 1: 5Case 2: impossible 首先，题目意思就是找5（2比5多很多所以不必考虑2），有几个0就是有几个5 25算两个5，50算两个，125算三个 所以可以很直接地得到一个式子 max等于10其实差不多了，我下面代码写得花里胡哨的max是一开始因为tle的改动，现在想想就10能改变什么 再整理得 即有max越大，ans越接近4×k（用星号会用奇奇怪怪的问题所以不用了） 等max=10的时候，5^max接近1e8，这个时候ans也不会比4×k大多少，所以可直接暴力枚举： AC代码12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main() &#123; int T, b = 1, max, d = 1; long k, k1 = 0, flag = 0, ans; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%ld&quot;, &amp;k); printf(&quot;Case %d: &quot;, d++); max = floor(log(k * 5) / log(5)); for (long i = k * 4; i &lt;= k * 4 + 100; i++) &#123; for (int j = 1; j &lt;= max; j++) &#123; b = b * 5; k1 += (i / b); &#125; b = 1; if (k1 == k) &#123; printf(&quot;%ld\\n&quot;, i); flag = 1; break; &#125; k1 = 0; &#125; if (flag == 0) printf(&quot;impossible\\n&quot;); flag = k1 = 0; &#125; return 0;&#125; 类似有一题，是在HDU的HelloWorld社团的比赛上（但是这题贼简单）： 题目2：这是一道简单的数学题 Problem Description“今晚你会成为我的人！”电视里传出这样的声音，小明和小红执手相看，含情脉脉，四目相对。小红红着脸：“你爱我吗？”小明：“当然！”小红：“那你能告诉我你有多少个前女友吗？”小明：“别问，问就爆炸。”小红：“老娘给你脸了，说！！！”小明脑补着该说有几个比较合适，他知道小红有个习惯，就是特别喜欢不断重复计算n∗n∗n里有多少个9，于是，他开始不断枚举n，以便让小红沉迷于计算，而不追究。小红对于n里有多少个9的定义：从1到n的每一个数能整除9的次数相加，如：9里有一个9（9/9），18里有两个9（9/9，18/9），81里有10个9（9/9，18/9，27/9，36/9，45/9，54/9，63/9，72/9，81/9/9）Input多组测试数据，每组占一行。每行一个n（1&lt;=n&lt;=100000）Output每行输出一个整数，表示n∗n∗n中有多少个9Sample Input134Sample Output037 AC代码123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;int main() &#123; long n; long long c, a = 1,ans=0; while (~scanf(&quot;%ld&quot;, &amp;n)) &#123; c = pow(n, 3); for (int i = 1; i &lt; 18; i++) &#123; a *= 9; ans = ans + (c / a); &#125; printf(&quot;%lld\\n&quot;, ans); a = 1; ans = 0; &#125; return 0;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"zstuoj","slug":"zstuoj","permalink":"http://example.com/tags/zstuoj/"}]},{"title":"noip模拟-确定的位置（map + vector）","slug":"确定的位置-题解","date":"2019-03-16T03:19:23.000Z","updated":"2021-01-26T16:43:25.834Z","comments":true,"path":"2019/03/16/确定的位置-题解/","link":"","permalink":"http://example.com/2019/03/16/%E7%A1%AE%E5%AE%9A%E7%9A%84%E4%BD%8D%E7%BD%AE-%E9%A2%98%E8%A7%A3/","excerpt":"想清楚了就不难这题还是在c程上机课的时候a掉的","text":"想清楚了就不难这题还是在c程上机课的时候a掉的 还是aaa和vv的命名，本家独创还是只会举例论证，wztcl 题目：确定的位置 描述hzy很喜欢了解歌曲的排行榜，他每次都从XX网站获知。由于这个网站想对这个歌曲的排行榜含蓄的告诉大家，组织了一个“猜榜大赛”。这个网站宣布一些歌曲的信息，那些歌曲在歌曲榜上的前几名，例如：·”qianlizhiwai” 是在榜上的前三名·”qianlizhiwai”,”dachengxiaoai” 是在歌曲榜的前两名网站不会把歌曲的名次十分明确的告诉你，他就是想让你通过这些信息，推出一部分歌曲的名次，现在困惑的hzy找您帮忙，想让您推出所有确定名次的歌曲。输入第一行包括一个整数n, 1≤n≤500，表示网站给你的信息的条数。下面n行包括一条信息，形式为”A and B song1 song2 song3 … songA”,1≤A≤B≤100，表示”song1”,”song2”,…,”songA”是在歌曲榜的前B位。每一首歌都是一个string,由最多25个小写字母组成。输出输出可以知道的所有的歌的排名，形式:”Position Song”位置必须有序。输入样例 121 and 3 lonely2 and 2 trebami jasekonja输出样例 13 lonely输入样例 232 and 2 pjesma1 pjesma23 and 4 pjesma1 pjesma3 pjesma41 and 3 pjesma4输出样例 23 pjesma44 pjesma3 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#define INF 0xfffffffusing namespace std;int n, m, k;int a, b, c, d;int sum, ans, num, cnt[105];string s, sa, sb;map&lt;string, int&gt;aaa;vector&lt;string&gt;vv[105];vector&lt;string&gt;::iterator it;int main() &#123; num = 0; aaa.clear(); for (int i = 1; i &lt; 105; i++) vv[i].clear(); cin &gt;&gt; n; int tmp = INF; while (n--) &#123; cin &gt;&gt; k &gt;&gt; s &gt;&gt; m; while (k--) &#123; cin &gt;&gt; s; if (!aaa[s]) aaa[s] = m, vv[m].push_back(s); else if (aaa[s] &gt; m)&#123; for(it=vv[aaa[s]].begin();it!=vv[aaa[s]].end();) if(*it==s) it=vv[aaa[s]].erase(it); else it++; vv[m].push_back(s); aaa[s] = m; &#125; &#125; &#125; for (int i = 1; i &lt; 105; i++)&#123; num+=vv[i].size(); //没有num遇到1 1 and 3 lonely这种情况会输出3 lonely（正确是没有输出） if (vv[i].size() == 1&amp;&amp;num==i) cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; vv[i][0] &lt;&lt; endl; &#125; return 0;&#125; 感觉没什么太难理解的不必要打什么注释= =","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"队内训练","slug":"队内训练","permalink":"http://example.com/tags/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%83/"}]},{"title":"震惊！原来这就是万恶之源！","slug":"是题解哦","date":"2019-03-14T14:11:59.000Z","updated":"2020-03-02T07:19:13.238Z","comments":true,"path":"2019/03/14/是题解哦/","link":"","permalink":"http://example.com/2019/03/14/%E6%98%AF%E9%A2%98%E8%A7%A3%E5%93%A6/","excerpt":"G题正确率跌破5%，ID为HDU8的用户刷屏提交记录四页，这一切的背后，到底是人性的灭亡，还是道德的沦丧……","text":"G题正确率跌破5%，ID为HDU8的用户刷屏提交记录四页，这一切的背后，到底是人性的灭亡，还是道德的沦丧…… 因为这道题没有出现在除去我们比赛的其他oj里（至少我没搜到），来看的估计都是熟人，我就放飞自我辽。 这题我交了六十多次……太倔强了，我为自己鼓鼓掌 A掉的时候贼高兴，所以就想搭个博客，所以G题就是万恶之源（严肃） WARNING：有用map，map名字叫aaa，可能引起阅读不适（但我就是不改这多有特点啊）；只会举例论证，语言逻辑不太行 题目：化学方程式 描述102班每天要写化学方程式，现在要想办法批改方程式。方程式中反应物的顺序可以不一样，中间可以有空格。不会出现沉淀和气体符号和反应条件。错误有系数不对（下标不对，如CO2为CO3也算系数不对。反应物或生成物中不会出现元素相同，系数不同的化学式，如：CO和CO2不会一起出现在反应物或生成物中），化学式错误，缺少反应物，两边元素不守恒。输入第一排输入N,M第二排输入长度为N的字符串为正确方程式第三排输入长度为M的字符串为要批改方程式输出正确输出RIGHT错误第一排输出WRONG，第二排输出错误原因（只系数不对为1，其他错误和有两个以上错误为2）输入样例 134 292Na O H + H2S O4 = Na 2 S O4+2H2OH2S O4 +2NaO H =Na2 S O4+2H2O输出样例 1RIGHT输入样例 234 252Na O H + H2S O4 = Na 2 SO4 +2H2OH2S O4 +NaO H=2H2O +2 K Cl输出样例 2WRONG2 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#define INF 0xfffffffusing namespace std;int n, m, k;int a, b, c, d;int sum, ans, num, cnt;string s, sa, sb;map&lt;string, int&gt;aaa;int main() &#123; cin &gt;&gt; n &gt;&gt; m; getchar(); cnt = 1; aaa.clear(); string s1[100], s2[100]; for (int i = 0; i &lt; 100; i++) s1[i] = &quot;&quot;, s2[i] = &quot;&quot;; while (1) &#123; s = getchar(); if (s == &quot;\\n&quot;) break; else if (s != &quot;+&quot;&amp;&amp;s != &quot;=&quot;&amp;&amp;s != &quot; &quot;) s1[cnt] += s; else if (s == &quot;+&quot;) cnt++; else if (s == &quot;=&quot;) a = cnt, cnt++;//a是存反应物和生成物的分隔 &#125; int tt = cnt; for (int i = 1; i &lt;= cnt; i++) &#123; sa = &quot;&quot;; aaa[s1[i]] = i; for (int j = 0; j &lt; s1[i].length(); j++) if (s1[i][j] &lt;= &#x27;0&#x27;||s1[i][j] &gt;= &#x27;9&#x27;) sa += s1[i][j];//去数字 if (!aaa[sa]) aaa[sa] = ++tt;//系数去掉后也存一下 &#125; int cnt2 = 1; int flag = 1;//flag设置为1是因为全对全错都比半对好考虑 sum = 0; int p[100]; memset(p, 0, sizeof(p)); while (1) &#123; s = getchar(); if (s == &quot;\\n&quot;) break; else if (s != &quot;+&quot;&amp;&amp;s != &quot;=&quot;&amp;&amp;s != &quot; &quot;) s2[cnt2] += s; else if (s == &quot;+&quot;) cnt2++; else if (s == &quot;=&quot;) b = cnt2, cnt2++; &#125;//复读机 if (cnt2 != cnt) flag = 2;//一二式方程式里物质数目不同直接错 for (int i = 1; i &lt;= cnt2; i++) &#123; sb = &quot;&quot;; if (flag == 2) break; for (int j = 0; j &lt; s2[i].length(); j++) if (s2[i][j] &lt;= &#x27;0&#x27;||s2[i][j] &gt;= &#x27;9&#x27;) sb += s2[i][j]; if (aaa[s2[i]] &amp;&amp; aaa[s2[i]] &lt;= cnt &amp;&amp; !p[aaa[s2[i]]]) sum++, p[aaa[s2[i]]] = 1;//包含系数物质的直接比较 和一式一样计数+标记 // aaa[s2[i]] &lt;= cnt的存在必要：如一式是2HCl二式是HCl // p[aaa[s2[i]]] = 1的存在必要：一式CO+CuO=Cu+CO2二式CO+CuO=Cu+CO else if (!aaa[sb]) flag = 2;//去掉系数了还没有存过肯定是错的了 if (aaa[s2[i]] &gt; a &amp;&amp; aaa[s2[i]] &lt;= cnt &amp;&amp; i &lt;= b) flag = 2; //判断生成物和反应物有没有跑错位子 &#125; if (flag == 1 &amp;&amp; sum == cnt) flag = 0; if (!flag) cout &lt;&lt; &quot;RIGHT&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;WRONG&quot; &lt;&lt; endl; if (flag) cout &lt;&lt; flag &lt;&lt; endl; return 0;&#125; 其实这题走了好多弯路，怪自己太瞎题目没看清（反思） 删删改改，从五六十加加加到百来行再删删删到七十行（然后再加加加注释） 这个解系数为1不能判断，不过讲道理化学方程式系数为1确实不写 CO2和CO3只是系数错了能把化学老师气死（也把我气死了，所以一开始是开了vector的） 比较常规而且又稳的解法应该是四个map+一个vector，顾老师好像就是这样不过他还分了单质啊什么的我也没细看= =反正我这个能A嘻嘻","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"队内训练","slug":"队内训练","permalink":"http://example.com/tags/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%83/"}]},{"title":"相 逢 即 是 缘","slug":"一个置顶","date":"2019-03-13T09:13:12.000Z","updated":"2021-01-26T11:09:50.281Z","comments":true,"path":"2019/03/13/一个置顶/","link":"","permalink":"http://example.com/2019/03/13/%E4%B8%80%E4%B8%AA%E7%BD%AE%E9%A1%B6/","excerpt":"Like the meeting of the seagulls and the waves we meet and come near. The seagulls fly off, the waves roll away and we depart. ——《Stray Birds》Rabindranath Tagore","text":"Like the meeting of the seagulls and the waves we meet and come near. The seagulls fly off, the waves roll away and we depart. ——《Stray Birds》Rabindranath Tagore wz&amp;yx 平时用的id是稳赚，HDU就读，专业是工设 菜鸡acmer一个，秃头敲代码中 HDUACM集训队底层队员，随时可能被经费警告 Vidar Team美工，但是不会画看板娘只会表情包（逃） 圈名是余心，画画写字剪纸都会一点，平时一般搞搞字设 研究瘦金+做瘦金相关字体（但是一直咕咕咕） 在杭州的graffiti活动请！叫！上！我！ 目前低于100r的稿子不接（理直气壮） 初心 我两周前还说不想搞博客，飞快真香 搞这个博客的契机是写了一个题感觉自己tql想再搞个题解 应该以后就会开始做题解和发作品 一是对自己成长的一个纪念吧 二是督促自己好好写题好好画画 三是希望更多人看到这么优秀的我 许几个愿 最希望8要被经费警告 然后希望在2020能把宋金体（名字暂定）做出来 清鹤不急做辽！等我有时间了慢慢再去研究吧233 没辽！太贪心8好","categories":[{"name":"w&y","slug":"w-y","permalink":"http://example.com/categories/w-y/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"},{"name":"w&y","slug":"w-y","permalink":"http://example.com/categories/w-y/"},{"name":"y","slug":"y","permalink":"http://example.com/categories/y/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"素材","slug":"素材","permalink":"http://example.com/tags/%E7%B4%A0%E6%9D%90/"},{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"},{"name":"pintia","slug":"pintia","permalink":"http://example.com/tags/pintia/"},{"name":"hdoj","slug":"hdoj","permalink":"http://example.com/tags/hdoj/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"},{"name":"板子","slug":"板子","permalink":"http://example.com/tags/%E6%9D%BF%E5%AD%90/"},{"name":"design","slug":"design","permalink":"http://example.com/tags/design/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"zstuoj","slug":"zstuoj","permalink":"http://example.com/tags/zstuoj/"},{"name":"队内训练","slug":"队内训练","permalink":"http://example.com/tags/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%83/"}]}