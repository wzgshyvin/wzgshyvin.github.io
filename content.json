{"meta":{"title":"V1n","subtitle":"","description":"I have suffered and despaired and known death and I am glad that I am in this great world.","author":"V1n","url":"http://example.com","root":"/"},"pages":[{"title":"Friends","date":"2019-03-18T03:34:17.000Z","updated":"2021-01-26T11:24:10.683Z","comments":true,"path":"Friends/index.html","permalink":"http://example.com/Friends/index.html","excerpt":"","text":"ç»“ç¼˜äºACMArya_Erin ç¥ç¥Axiomofchoice hjt æ°¸è¿œæ»´ç¥BearChild å¤©å¤©CallmeChallenger çˆ¬çˆ¬Chenboluo ct å‰é˜Ÿå‹Chenfu1234 é£é£Codgician å¼ å­¦é•¿Colin é‡‘ç‰Œå­¦å¼ŸCulaccino cby å‰é˜Ÿå‹Dddfaker ä¸ç‹—DeaphetS å‰å“¥Dreaming2019 å°å½­Edwiv éƒ‘è€å¸ˆEricXia å¤å®Garvey é™†è€å¸ˆILLLZKQF æ–½å·¨Jiedai æ±¤æ±¤Kaizyn å‡¯å‡¯K0u1e ç‡•å®MaJorieL å°ä»» æˆ‘æ»´å®REXWind å°æ–½Tommy1123 è¾£å®UniverseofHK å‰è€å¸ˆV4yne å½­è€å¸ˆWillingox åˆ˜è€å¸ˆZarathu å°¹å® æ¥è‡ªVidar-Team357 WebAnnevi WebBrownFly é£å“¥Cosmos é˜¿C PwnCyris cyå­¦é•¿ Web å‰ç«¯ ç¾å·¥Danis Jiang è’‹å…¬å­ BinE99p1ant 199 WebFeather è¯­å®Fl0a1e å³¥å®Kevin Web å‰ç«¯Matrix BinObjectNotFound MiscOyiadin oyyRin1ang ç››å® WebRosetta é±¼å®Y æ­ªå® Re å…¶ä»–æœ‹å‹AYang å°è€å¼ŸCaesar BaoXiaoyuyu æ¥¼å“¥"},{"title":"About","date":"2019-03-15T16:44:19.000Z","updated":"2019-03-20T16:14:48.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Man goes into the noisy crowd to drown his own clamour of silence. â€”â€”ã€ŠStray Birdsã€‹"},{"title":"tags","date":"2019-03-16T02:27:12.000Z","updated":"2019-03-16T13:00:52.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-16T02:26:48.000Z","updated":"2019-03-16T02:34:46.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"å„ç§æ’åºå­¦ä¹ ç¬”è®°","slug":"å„ç§æ’åºå­¦ä¹ ","date":"2021-01-27T07:11:59.000Z","updated":"2021-01-26T16:45:44.428Z","comments":true,"path":"2021/01/27/å„ç§æ’åºå­¦ä¹ /","link":"","permalink":"http://example.com/2021/01/27/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/","excerpt":"å› ä¸ºå­¦äº†å†’æ³¡åå°±ä¼šç”¨ sort äº†ï¼Œå®Œå…¨æ²¡æœ‰å­¦è¿‡å„ç§æ’åºï¼Œç¬¬ä¸€æ¬¡é¢è¯•å› ä¸ºä¸ä¼šæ‰‹å†™å¿«æ’ GG ï¼Œç—›å®šæ€ç—›ï¼Œå†³å®šè®¤çœŸå†™ç¯‡å­¦ä¹ åšå®¢ QAQ","text":"å› ä¸ºå­¦äº†å†’æ³¡åå°±ä¼šç”¨ sort äº†ï¼Œå®Œå…¨æ²¡æœ‰å­¦è¿‡å„ç§æ’åºï¼Œç¬¬ä¸€æ¬¡é¢è¯•å› ä¸ºä¸ä¼šæ‰‹å†™å¿«æ’ GG ï¼Œç—›å®šæ€ç—›ï¼Œå†³å®šè®¤çœŸå†™ç¯‡å­¦ä¹ åšå®¢ QAQ å†’æ³¡æ’åºæ—¶é—´å¤æ‚åº¦ $O(n^2)$ ï¼Œç©ºé—´å¤æ‚åº¦ $O(1)$ ï¼Œä¸æ–­ swap æŠŠå¤§çš„æ’åˆ°åé¢ï¼Œå’•å™œå’•å™œå†’æ³¡æ³¡ 123456789101112void BubbleSort(int *a,int len)&#123; for(int i=1;i&lt;len;++i)&#123; int ff(0); for(int j=0;j&lt;len-i;++j)&#123; if(a[j]&gt;a[j+1])&#123; swap(a[j],a[j+1]); ff++; &#125; &#125; if(!ff) break; // å°å‰ªæ &#125;&#125; æ’å…¥æ’åºæ—¶é—´å¤æ‚åº¦ $O(n^2)$ ï¼Œç©ºé—´å¤æ‚åº¦ $O(1)$ ï¼Œæ¯æ¬¡å°†æ–°å…ƒç´ æ’å…¥å·²æ’åºçš„æ•°ç»„ä¸­ã€‚ 12345void InsertSort(int *a,int len)&#123; for(int i=1;i&lt;len;++i) for(int j=i;j&gt;0;--j) if(a[j]&lt;a[j-1]) swap(a[j],a[j-1]);&#125; é€‰æ‹©æ’åºæ—¶é—´å¤æ‚åº¦ $O(n^2)$ ï¼Œç©ºé—´å¤æ‚åº¦ $O(1)$ ï¼Œæ¯æ¬¡å°†æœ€å€¼æ”¾åœ¨å½“å‰å¯æ“ä½œçš„é¦–ä½ã€‚ 12345678void SelectSort(int *a,int len)&#123; for(int i=0;i&lt;len;++i)&#123; int mn=i; for(int j=i+1;j&lt;len;++j) if(a[j]&lt;a[mn]) mn=j; swap(a[i],a[mn]); &#125;&#125; å½’å¹¶æ’åºæ—¶é—´å¤æ‚åº¦ $O(nlogn)$ ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ ï¼Œé€’å½’ï¼Œæ¯æ¬¡å°†è¦æ’åºçš„å­æ•°ç»„åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†æ’åºã€‚ 1234567891011121314151617void MergeSort(int *a,int l,int r)&#123; if(l&gt;=r) return; int mid=l+r&gt;&gt;1; MergeSort(a,l,mid); MergeSort(a,mid+1,r); int i=l,j=mid+1,tlen=l,tmp[maxn]; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(a[i]&lt;=a[j]) tmp[tlen++]=a[i++]; else tmp[tlen++]=a[j++]; &#125; while(i&lt;=mid) tmp[tlen++]=a[i++]; while(j&lt;=r) tmp[tlen++]=a[j++]; for(int i=l;i&lt;=r;++i) a[i]=tmp[i];&#125;void solve()&#123; MergeSort(a,0,len-1); &#125; å¿«é€Ÿæ’åºæ—¶é—´å¤æ‚åº¦ $O(nlogn)$ ï¼Œç©ºé—´å¤æ‚åº¦ $O(logn)$ ï¼Œæ¯æ¬¡æ‰¾ä¸€ä¸ªæ¯”è¾ƒåˆé€‚çš„ pivot ï¼Œæ ¹æ®è¿™ä¸ªå€¼å¯¹æ•°ç»„è¿›è¡Œè°ƒæ•´ã€‚ 123456789101112131415161718192021int findmiddle(int a,int b,int c)&#123; int tmp=a^b^c; int mx=max(&#123;a,b,c&#125;); int mn=min(&#123;a,b,c&#125;); return tmp^mx^mn;&#125;void QuickSortAdjust(int *a,int l,int r)&#123; if(l&gt;=r) return; int pivot=findmiddle(a[l],a[r],a[l+r&gt;&gt;1]); int i=l,j=r; while(i&lt;=j)&#123; while(i&lt;=j&amp;&amp;a[i]&lt;pivot) i++; while(i&lt;=j&amp;&amp;a[j]&gt;pivot) j--; if(i&lt;=j) swap(a[i++],a[j--]); &#125; QuickSortAdjust(a,l,j); QuickSortAdjust(a,i,r);&#125;void QuickSort(int *a,int len)&#123; QuickSortAdjust(a,0,len-1);&#125; å †æ’åºæ—¶é—´å¤æ‚åº¦ $O(nlogn)$ ï¼Œç©ºé—´å¤æ‚åº¦ $O(1)$ ï¼Œæ¯æ¬¡å¯¹æ— åºçš„å­æ•°ç»„è¿›è¡Œå †è°ƒæ•´ï¼Œå°†æœ€å€¼ç½®äºå †é¡¶ï¼Œç„¶åæŠŠæœ€å€¼ç§»åˆ°æ•°ç»„æœ«å°¾ï¼Œå†å¯¹å‰©ä¸‹çš„å­æ•°ç»„è¿›è¡Œæ“ä½œã€‚ 1234567891011121314151617181920212223242526272829303132void HeapAdjust(int *a,int len)&#123; for(int i=len-1;i&gt;0;--i)&#123; if((i&amp;1)&amp;&amp;(a[i]&gt;a[i/2])) swap(a[i],a[i/2]); else if(!(i&amp;1)&amp;&amp;(a[i]&gt;a[i/2-1])) swap(a[i],a[i/2-1]); &#125;&#125;void HeapSort(int *a,int len)&#123; while(len)&#123; HeapAdjust(a,len--); swap(a[0],a[len]); &#125;&#125;// åŠ é€Ÿç‰ˆvoid _HeapAdjust(int *a,int x,int len)&#123; int fa=x,son=(fa&lt;&lt;1)|1; while(son&lt;len)&#123; if(son+1&lt;len&amp;&amp;a[son]&lt;a[son+1]) son++; // å“ªä¸ªå°å­© if(a[fa]&gt;=a[son]) break; swap(a[fa],a[son]); fa=son; son=(fa&lt;&lt;1)|1; &#125;&#125;void _HeapSort(int *a,int len)&#123; for(int i=(len&gt;&gt;1)-1;i&gt;=0;--i) _HeapAdjust(a,i,len); for(int i=len-1;i&gt;=0;--i)&#123; swap(a[0],a[i]); _HeapAdjust(a,0,i); &#125;&#125; æ¡¶æ’åºæ—¶é—´å¤æ‚åº¦ $O(n+k)$ ï¼Œç©ºé—´å¤æ‚åº¦ $O(n+k)$ ï¼Œå°†å…ƒç´ æ”¾è¿›æ¡¶é‡Œï¼ŒæŒ‰æ¡¶çš„å¤§å°å–å‡ºã€‚ 12345678910void BucketSort(int *a,int len)&#123; int vis[maxn]=&#123;0&#125;; // å€¼åŸŸ for(int i=0;i&lt;len;++i)&#123; vis[a[i]]++; &#125; int cnt(0); for(int i=0;i&lt;maxn;++i)&#123; while(vis[i]) vis[i]--,a[cnt++]=i; &#125;&#125; åŸºæ•°æ’åºæ—¶é—´å¤æ‚åº¦ $O(n*k)$ ï¼Œç©ºé—´å¤æ‚åº¦ $O(n+k)$ ã€‚ä¸¤ç§ï¼šä¸€ç§ï¼ˆLSDï¼‰ä»ä½ä½åˆ°é«˜ä½æ”¾è¿›æ¡¶é‡Œï¼ˆæ¯æ¬¡ 10 ä¸ªï¼‰ã€‚ä¸€ç§ï¼ˆMSDï¼‰ä»é«˜ä½åˆ°ä½ä½æ”¾è¿›æ¡¶é‡Œï¼Œä¸€ä½å¤„ç†å®Œåï¼Œç›´æ¥åœ¨å½“å‰æ¡¶é‡Œåˆ†ä¸‹ä¸€ä½çš„ç±»ã€‚å¤æ‚åº¦ç•¥é«˜è€Œä¸”ä»£ç è¿‡é•¿ï¼Œæ„Ÿè§‰èƒ½å˜´å°±è¡Œ 233","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"é¢è¯•","slug":"é¢è¯•","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"æŠ‘éƒå°è®°","slug":"æŠ‘éƒå°è®°","date":"2020-06-28T07:08:01.000Z","updated":"2021-01-26T16:43:57.879Z","comments":true,"path":"2020/06/28/æŠ‘éƒå°è®°/","link":"","permalink":"http://example.com/2020/06/28/%E6%8A%91%E9%83%81%E5%B0%8F%E8%AE%B0/","excerpt":"éƒ½ä¼šå¥½èµ·æ¥çš„","text":"éƒ½ä¼šå¥½èµ·æ¥çš„ ä¸ºä»€ä¹ˆçªç„¶å°±æŠ‘éƒäº†ï¼Ÿç¡¬è¦è§£é‡Šçš„è¯ï¼Œå»å¹´åæœˆå°±æœ‰ç‚¹è‹—å¤´äº†ï¼Œç–«æƒ…æœŸé—´é•¿æœŸåœ¨å®¶è¿‡äºå‹æŠ‘ï¼Œé›†è®­é˜Ÿå’Œè¯¾ä¸šçš„å‹åŠ›ä¹Ÿå¾ˆå¤§ï¼Œè¿˜æœ‰ä¸€äº›æˆ‘ä¸æƒ³å¤šæçš„äº‹ï¼Œç§ç§äº‹æƒ…å †ç§¯åœ¨ä¸€èµ·ä»è€Œé€ æˆçš„è¿™ç§ç»“æœå§ã€‚æˆ‘ä¹Ÿä¸æƒ³å˜›ã€‚å¯ä»¥ç®—æ˜¯çªå‘ï¼Œæœ‰ä¸€å¤©æ—©ä¸Šççœ¼çªç„¶ä¸§å¤±äº†å¯¹å„ç§ç¾å¥½è¿½æ±‚çš„å…´è¶£ï¼Œè€Œå‰ä¸€å¤©æˆ‘è¿˜çŠ¶æ€å¾ˆå¥½åœ°åœ¨è®­ç»ƒã€‚æŠ‘éƒæ—¶å€™æˆ‘éƒ½å¹²äº†ä»€ä¹ˆï¼Ÿé™¤äº†æ¶ˆç£¨æ—¶é—´çš„ä¸åŠ¡æ­£ä¸šï¼Œè¿˜æœ‰èº«ä½“æœ¬èƒ½çš„è®­ç»ƒã€‚3.10æˆ‘åœ¨cfçš„é¢˜æ•°åˆšå¥½è¾¾åˆ°300ï¼Œç°åœ¨å¿«åˆ°500ï¼Œä¸­é—´æœ‰ä¸‰æ¬¡ç´«çš„æœºä¼šï¼Œä¸€æ¬¡å¼€å°å·ç¿»è½¦äº†ï¼ˆå¯¹ä¸èµ·å¯¹ä¸èµ·å¯¹ä¸èµ·ï¼‰ä½†å…¶å®ä¹Ÿå…¨æ˜¯1Aï¼Œä¸€æ¬¡å’Œæ™šè¯¾å†²çªå°å·æ‰“äº†å››é¢˜ï¼Œä¸€æ¬¡å°±æ™®æ™®é€šé€šåœ°ç´«äº†ã€‚è™½ç„¶æˆ‘æ€¯å¼±ã€ç•ç¼©ã€å¿ƒæ€ä¸å®šï¼Œä½†æˆ‘è¿˜æ˜¯æœ‰å¯èƒ½æ€§ã€‚æœŸé—´å–œæ¬¢ä¸Šäº†å°é©¬ï¼Œå¬ç€ä»–çš„ç›´æ’­ä¼šå¾ˆå®‰å¿ƒï¼Œåä¹‹å¦‚æœæœ‰äº‹å¬ä¸äº†ä¼šå¾ˆç„¦è™‘ã€‚å¹³æ—¶å¬ä»–çš„æ­Œã€å¬ä»–å¬çš„æ­Œã€çœ‹ä»–åšçš„è§†é¢‘ï¼Œç°åœ¨ç”µè„‘æ¡Œé¢å’Œæ‰‹æœºå£çº¸ä¹Ÿå…¨æ˜¯ä»–ï¼Œè€è¿½æ˜Ÿäº†233ã€‚å¯ä»¥æ‡‚è¿™ä¸€ç§å¿ƒç†å¯„æ‰˜å§ï¼Œå–œæ¬¢ç»ˆå½’æ˜¯å¾ˆæ­£é¢çš„æƒ…ç»ªã€‚å’Œzxjåˆæ¢å¤äº†å¾ˆå¥½çš„å…³ç³»ï¼Œè™½ç„¶æœ¬èº«å°±æ˜¯å¾ˆé€‚åˆå½“æœ‹å‹çš„äºº233ã€‚åæœŸçš„è°ƒèŠ‚å’Œä»–ä»¬å…³ç³»ä¹Ÿå¾ˆå¤§ã€‚è™½ç„¶éƒ½çœ‹ä¸åˆ°ã€‚ä½†è¿˜æ˜¯ã€‚è°¢è°¢è°¢è°¢ã€‚åˆ†æ‰‹æ˜¯å†³å®šäº†å¾ˆä¹…çš„ã€‚ç»™ä»–ä¸¤ä¸‰æ¬¡æœºä¼šäº†å§ï¼Œå› ä¸ºæ˜¯ä¸€ä¸ªå¾ˆæ€•éº»çƒ¦çš„äººï¼Œä¹Ÿå¾ˆå¿ƒè½¯çš„äººã€‚æœ€åæ·±å¤œç†æŠ‘éƒæ—¶é—´çº¿çš„æ—¶å€™è¿˜æ˜¯ç»·ä¸ä½ï¼Œæˆ‘è§‰å¾—æˆ‘è¯¥å¯¹æˆ‘è‡ªå·±å¥½ä¸€ç‚¹ï¼Œå°±æäº†åˆ†æ‰‹ã€‚åŒç†åœ¨ä¸€èµ·ä¹Ÿæ˜¯å†³å®šäº†å¾ˆä¹…çš„ï¼Œæ²¡æœ‰éšéšä¾¿ä¾¿ï¼Œæ›¾ç»ä¹Ÿç»™äº†æˆ‘å¾ˆå¤šæ­£é¢å½±å“ã€‚è°æ²¡æœ‰çœŸæƒ…å®æ„Ÿè¿‡å‘¢ï¼Œæ‹çˆ±å°±è¿™ã€‚æ„Ÿè°¢å°ä»»åŒå­¦ç»™æˆ‘çš„è¯å’Œç»™æˆ‘çš„é¼“åŠ±ã€‚æ„Ÿè°¢æƒ…æ„Ÿé—®é¢˜è°ƒèŠ‚å¤§å¸ˆç››å®ã€‚è¿˜æœ‰è¯·æˆ‘åƒä»Ÿè¯šå’Œé²œèŠ‹ä»™çš„xyã€‚è¿˜æœ‰æ€»æ˜¯åŠæˆ‘å»çœ‹ç—…ä½†æ˜¯æ€»æ°”æˆ‘çš„æ­ªå®å’Œå¯å¯çˆ±çˆ±å¦¹æœ‰è„‘è¢‹çš„ç‡•å®ã€‚è¿˜æœ‰åˆ—è¡¨å„ä¸ªæœ‹å‹ç»™æˆ‘å‘çš„è¯å’Œå°ä½œæ–‡ã€‚ç¤¾äº¤è¾¾åˆ°è¿™ä¸ªç¨‹åº¦å¾ˆå¼€å¿ƒäº†233ã€‚è¿˜åœ¨å®¶çš„æ—¶å€™æ„Ÿè§‰å¤ªé—·äº†å°±ä¼šå‡ºå»ç©ï¼Œè€è°ƒèŠ‚æƒ…ç»ªäº†ã€‚å’Œåª³å¦‡å„¿å»é€›è¡—ï¼Œå»åƒåƒå–å–ï¼Œå»æ±Ÿè¾¹å¹æ³¡æ³¡ï¼Œæ‹ç…§å‘ç©ºé—´ã€‚çœŸçš„åœ¨åŠªåŠ›åº·å¤å•Šã€‚ä¹‹å‰åœ¨å®éªŒå®¤å‘†ç€çš„æ—¶å€™æœ‰éå¸¸ä¸¥é‡çš„ç„¦è™‘ï¼Œå€ŸæœºæŠŠé˜Ÿæœç”»äº†ã€‚è¯´å®è¯ï¼Œåœ¨å·¥è®¾è¿˜æ˜¯å‹åŠ›å¾ˆå¤§ä¸”æ¯«æ— è§£å†³åŠæ³•ï¼Œå¸Œæœ›å°è½¬æ²¡äº‹ã€‚ä¸‹å­¦æœŸæƒ³å’Œè€å¸ˆè°ˆåˆ¤ä¸€æ³¢ï¼Œå¸Œæœ›å°è½¬æ²¡äº‹ã€‚è¦æ˜¯æŒ‚äº†æˆ‘å¤§å››è¿˜å¾—ä¿®ï¼Œå†ä¿®å†æŒ‚ä¹Ÿæ²¡å•¥æ„æ€å§ï¼Œé‚£è¿˜æ˜¯ä¸€æ ·çš„æ°´ï¼Œå¹²å˜›ä¸ä¸€æ¬¡ç»™æˆ‘è¿‡äº†æ˜¯å§ï¼Œå¸Œæœ›å°è½¬æ²¡äº‹ã€‚â€œæˆ‘åªæ˜¯æƒ³è¿½æ±‚æˆ‘çš„å‰é€”ã€‚æˆ‘çš„å‰é€”ä¸åœ¨å·¥ä¸šè®¾è®¡ã€‚â€é€¼é€¼èµ–èµ–åˆ°ä¸çŸ¥é“è¯´å•¥äº†ã€‚å°è½¬å¾ˆæ£’å°è½¬è¯¥æœ‰å…‰æ˜çš„å‰é€”çš„ã€‚å°è½¬è¿˜æ²¡å¥½å…¨å°è½¬ä¹Ÿä¸çŸ¥é“èƒ½ä¸èƒ½å¥½ã€‚åƒè¨€ä¸‡è¯­æ±‡æˆä¸€å¥è¯ï¼šå¸Œæœ›å°è½¬æ²¡äº‹ğŸ™ã€‚","categories":[{"name":"w&y","slug":"w-y","permalink":"http://example.com/categories/w-y/"}],"tags":[{"name":"éšç¬”","slug":"éšç¬”","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"å¿ƒå¿ƒå¥‡æ€ªç´ æç½‘ç«™æ”¶é›†","slug":"å¿ƒå®ç½‘ç«™ç´ æ","date":"2020-06-27T15:08:01.000Z","updated":"2021-01-26T16:43:45.583Z","comments":true,"path":"2020/06/27/å¿ƒå®ç½‘ç«™ç´ æ/","link":"","permalink":"http://example.com/2020/06/27/%E5%BF%83%E5%AE%9D%E7%BD%91%E7%AB%99%E7%B4%A0%E6%9D%90/","excerpt":"åŠªåŠ›å½“ä¸€ä¸ªå¥½ç¾å·¥ï¼Ÿ","text":"åŠªåŠ›å½“ä¸€ä¸ªå¥½ç¾å·¥ï¼Ÿ æ–‡ç« å¤´å›¾æ¥æº èƒŒæ™¯ç´ æå…‰çƒçº¿æ¡ç‚«å…‰æ¸å˜å±‚æ¶²æ€æµä½“èƒŒæ™¯ç”Ÿæˆå‘æ•£å…‰çº¿èŠ±é‡Œèƒ¡å“¨ä¸¾ç‰Œå°äººè€é»‘å®¢äº†ç”Ÿæˆä»£ç å›¾ç‰‡ PNG ç´ æé…è‰²å‚è€ƒé…è‰²é…è‰²é…è‰²è‡ªç”±é€‰è‰²æ¸å˜é…è‰²æ¿å—é…è‰²æ—¥æœ¬ä¼ ç»Ÿè‰² å›¾ç‰‡å¤„ç†åŒè‰²å›¾ç‰‡æ•…éšœè‰ºæœ¯","categories":[{"name":"y","slug":"y","permalink":"http://example.com/categories/y/"}],"tags":[{"name":"ç´ æ","slug":"ç´ æ","permalink":"http://example.com/tags/%E7%B4%A0%E6%9D%90/"}]},{"title":"wzåˆ·é¢˜æ±‡æ€»","slug":"wzåˆ·é¢˜æ±‡æ€»","date":"2020-03-25T05:28:38.000Z","updated":"2021-02-22T14:03:32.096Z","comments":true,"path":"2020/03/25/wzåˆ·é¢˜æ±‡æ€»/","link":"","permalink":"http://example.com/2020/03/25/wz%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"ä¸ªäººåˆ·é¢˜è®°å½•ï¼ˆä¸å®Œå…¨ï¼‰","text":"ä¸ªäººåˆ·é¢˜è®°å½•ï¼ˆä¸å®Œå…¨ï¼‰ cf-contestså­˜ä¸€äº›è®©æˆ‘å†å†™ä¸ä¸€å®šå†™å¾—æ¥çš„æˆ–è€…æˆ‘å¯èƒ½å»æ‰’åŸé¢˜çš„?1202D d3çº¿ä¸‹æƒ³çš„æ•°å­¦é¢˜1214D dfså¯ä»¥æ ä¸¤æ¬¡dfs ç¬¬ä¸€æ¬¡æŠŠèµ°è¿‡çš„è·¯å µä¸Š(â€œDä¸æ˜¯dinicæ¿å­é¢˜?â€)1217B æ˜¯æˆ‘æœ€è®¨åŒçš„æ‰“æ€ªå…½ ä½†æ˜¯åšå¤ªå¤šè¿™ç§äº†â€¦ è¦ç‰¹åˆ¤ä¸€æ¬¡æ‰“æ­»(wcyèµ›æ—¶å››é¢˜ç¡å‰ä¸‰é¢˜é†’æ¥ä¸¤é¢˜é‚£åœº)1209D å¥‡æ€ªçš„å¹¶æŸ¥é›†1220B æ¯ä¸ªans[i]ä¸ºsqrt(a[i][j]*a[i][k]/a[j][k])1221D dp å¢é«˜æ æ†ä½¿æ²¡æœ‰ç›¸åŒé«˜åº¦ åªå¯èƒ½å¢0121251C a[i]å’Œa[j]å¥‡å¶æ€§ä¸åŒå¯ä»¥äº¤æ¢ é—®å­—å…¸åºæœ€å° å¥‡å¶åˆ†åˆ«å­˜ä¸€ä¸ªæ•°ç»„é‡Œ sort ç„¶åè´ªå¿ƒè¾“å‡º1252H è¿™bå¡doubleç²¾åº¦1256A-F è‡ªå·±åšå®¢1257D è´ªå¿ƒæ‰“æ€ªå…½1253D dfsæ±‚æ¯ä¸ªç‚¹èƒ½åˆ°mnå’Œmx å†forä¸€éè¡¥1265A-E è‡ªå·±åšå®¢â€¦1295C æˆ‘æœ€æ€•çš„äºŒåˆ†é¢˜ å¤šæ¬¡é€‰sçš„å­åºåˆ—åŠ èµ·æ¥ä½¿æœ€åç»“æœç­‰äºt é—®æœ€å°‘å‡ æ¬¡ å¼€ä¸ªcnt[26][maxn]å»äºŒåˆ†1295D é—®æœ‰å¤šå°‘0&lt;=x&lt;=m-1%%gcd(a,m)==gcd(a+x,m) ç»“è®ºé¢˜ æ±‚gcd(a,m)çš„phi1300E ä»»æ„é€‰åŒºé—´ä½¿åŒºé—´ä¸­æ‰€æœ‰æ•°å˜æˆåŒºé—´å¹³å‡æ•° é—®å­—å…¸åºæœ€å°ä»€ä¹ˆæ · è´ªå¿ƒ+ç®—ä¸ç®—å•è°ƒæ ˆ? forä¸€ä¸‹é‡åˆ°å°çš„å°±å»å’Œå‰é¢çš„å¹³å‡1301D è‡ªå·±åšå®¢1303C dfs ç»™ä½ sé—®æœ‰æ²¡æœ‰åˆé€‚çš„å•è¡Œé”®ç›˜åºåˆ—ä½¿æ¯æ¬¡æŒ‰éƒ½åªç”¨ç§»ä¸€æ ¼1303D è¢‹å­å®¹é‡n ç»™ä½ mä¸ª2^kiçš„ç‰©ä½“ é—®æœ€å°‘æ‹†å‡ æ¬¡èƒ½å¡«æ»¡1304D æ„é€  ç»™ä½ &lt;å’Œ&gt;ä»£è¡¨æ•°ç»„é€’å¢æˆ–è€…é€’å‡ æ±‚LISçš„æœ€å°/æœ€å¤§æƒ…å†µ æœ€å°æƒ…å†µå°±å¢å¾—å°‘å‡å¾—å¤š æœ€å¤§åè¿‡æ¥ ç¦»æ•£åŒ–åå°±æ˜¯ç­”æ¡ˆ1305E æ„é€  é€’å¢æ•°åˆ—ä¸”åˆšå¥½kä¸ªä¸‰å…ƒç»„(i,j,k)æ»¡è¶³ai+aj=ak1307D åŠ ä¸€æ¡è¾¹ä½¿åŠ åçš„1åˆ°næœ€çŸ­è·¯æœ€é•¿ è·‘ä¸€éæ‰€æœ‰ç‚¹åˆ°1/nçš„æœ€çŸ­è·¯ æ ¹æ®å·®å€¼æ’åº ç„¶åfor1311D æš´åŠ›æšä¸¾ èŒƒå›´æ˜¯å‘ ç»™abcé—®æœ€å°‘åŠ å‡ä¸€æ¬¡ä½¿b%a==0&amp;&amp;c%b==01312E åŒºé—´dp ä¸¤é¡¹ç›¸é‚»çš„ç›¸åŒå¯ä»¥åˆå¹¶æˆä¸€é¡¹æ¯”åŸæ¥å¤§1çš„å€¼ é—®æœ€å°‘å‰©ä¸‹1315D å¥‡æ€ªçš„å¹¶æŸ¥é›† æ ¹æ®æ—¶é—´å¤§åˆ°å°sort å¹¶æŸ¥é›†åˆ¤ç‚¹æ˜¯å¦å‡ºç°è¿‡1316D å¸¦æ¨¡æ‹Ÿ1316E çŠ¶å‹dp æ¯ä¸ªäººå¯ä»¥é€‰ä¸¤ç§èº«ä»½ è´¡çŒ®æ˜¯aå’Œb é€‰pä¸ª1èº«ä»½å’Œkä¸ª2èº«ä»½çš„äººä½¿æ€»è´¡çŒ®æœ€å¤§1321A-D è‡ªå·±åšå®¢1326D2 è‡ªå·±åšå®¢1327D ç½®æ¢ç¾¤ ç»™pæ‰¾æœ€å°kä½¿p^kå­˜åœ¨é¢œè‰²ç›¸åŒçš„ç¯ æ‰¾ç¯åæšä¸¾å› æ•°å†æšä¸¾æ‰€åœ¨ç¯æ˜¯ä¸æ˜¯é¢œè‰²ç›¸åŒ cf-strings/hashing5C å¸¸è§æ‹¬å·åŒ¹é… å•è°ƒæ ˆæ¿å­é¢˜7D è‡ªå·±åšå®¢8A implementation é¢˜æ„æœ‰ç‚¹éš¾æ‡‚ æ­£ç€findå€’ç€findå°±å®Œäº†25E kmp/hashæ¿å­é¢˜ å¤šä¸ªä¸²çœç•¥é‡å¤åœ°ç›¸è¿31B implementation+greedy?åˆæ³•åªè¦æ˜¯ä¸¤ä¸ª@ç›¸å·®2 æ³¨æ„é¦–å°¾34C æ–­å¥é¢˜ æ–­å®Œäº†å°±implementation39J ç»™å®šä¸²så’Œt é—®sèƒ½ä¸èƒ½åˆ ä¸€ä¸ªå­—ç¬¦å¾—åˆ°t hashå®Œäº†forä¸€ä¸‹58D sorté¢˜ sortå®Œæš´åŠ›æ‰¾åŒ¹é…70B æ¶å¿ƒäººçš„é¢˜ å¸¦æ¨¡æ‹Ÿ75B æ–­å¥+sort æ¨¡æ‹Ÿå°±å®Œäº†432D kmpé¢„å¤„ç†åo1æŸ¥æŸä¸ªå‰ç¼€å‡ºç°å‡ æ¬¡471D å·®åˆ†åkmpä¸€é526D kmp å¾ˆè€ƒå¯¹nexçš„ç†è§£?985F ç»™å‡ºä¸²s æ¯æ¬¡è¯¢é—®ä»¥xå’Œyä¸ºèµ·ç‚¹é•¿åº¦lençš„så­ä¸²å­—ç¬¦èƒ½å¦å½¢æˆä¸€ä¸€æ˜ å°„ hash[maxn][26]è®°å½• æ¯æ¬¡æ±‚å‡ºä¸¤ä¸ªæ®µæ¯ä¸ªå­—ç¬¦çš„hashå€¼ sortå®Œä¸€ä¸€æ¯”è¾ƒ1200E å­—ç¬¦ä¸²åˆå¹¶ hash/kmpæ¿å­1204D2 æ¯”è¾ƒç²¾å¦™çš„æ„é€ ? cf-string suffix structures19C è‡ªå·±åšå®¢123D æ±‚æ‰€æœ‰å­ä¸²å‡ºç°æ¬¡æ•°å’Œ samæ¿å­128B æ±‚ç¬¬kå°å­—å…¸åºå­ä¸²çš„sa/samæ¿å­ cf-geometry1C æµ·ä¼¦å…¬å¼+æ­£å¼¦å®šç†+ä½™å¼¦å®šç†+doubleæ±‚gcd14C ç»™å››ä¸ªçº¿æ®µé—®èƒ½ä¸èƒ½ç»„æˆçŸ©å½¢ è®°ä¸ªæ•°18A ç»™ä¸‰ä¸ªç‚¹é—®èƒ½ä¸èƒ½ç»„æˆæˆ–è€…ç§»ä¸€ä¸ªç‚¹ç»„æˆç›´è§’ä¸‰è§’å½¢ forforfor183B è¿™æ‰1700?è™½ç„¶æ˜¯n3æš´åŠ›190B æ±‚å’Œä¸¤ä¸ªåœ†ç›¸åˆ‡çš„åœ†çš„åŠå¾„ cf-number theory7C exgcd10C æ±‚å‡ºæ¯ä½æ•°æœ‰å‡ ä¸ª ç„¶ååŠ ä¸Šæ‰€æœ‰ç»„åˆ å†æ‰£æ‰åˆæ³•ç»„åˆ16C å°±è¿™?æ²¡æœ‰binary search æ‰€è°“number theoryåªæ˜¯gcdç½¢äº†17A é—®2-næœ‰å‡ ä¸ªç¬¦åˆé¢˜æ„çš„æ•° ç­›å‡ºç´ æ•°ç„¶åæš´åŠ›17D åè¿›åˆ¶ksmæ¿å­é¢˜26A å°±è¿™2400?æš´åŠ›å®Œäº‹27E åç´ æ•°æ¿å­é¢˜45G å“¥å¾·å·´èµ«çŒœæƒ³(ä¸€ä¸ªå¶æ•°ä¸ºä¸¤ä¸ªè´¨æ•°ç›¸åŠ )?å…ˆåˆ¤å•è‰² æšä¸¾è´¨æ•°çœ‹èƒ½ä¸èƒ½åŒè‰² ä¸èƒ½çš„è¯è‚¯å®šæ˜¯å¥‡æ•° -3 å‰©ä¸‹çš„å†æšä¸¾55D æ•°ä½dp+ç¦»æ•£åŒ– dpå¼€[20][48][2520] 2520æ˜¯1-9çš„lcm æœ‰48ä¸ªå› æ•° å¯¹æ¯ä¸ªlcmç¦»æ•£åŒ– æœåˆ°æœ€ååˆæ³•æƒ…å†µå°±æ˜¯mod%lcm==066D ç®€å•æ„é€ 71C æšä¸¾iåˆ°n/3(ä¸‰è§’å½¢) æ¯ä¸ªn%i==0åˆ¤åˆä¸åˆæ³•73E æœ‰1é€‰1 æ²¡1é€‰nå†…æ‰€æœ‰è´¨æ•°(ä¸åŒ…å«) å¤ªå¤§ç‰¹åˆ¤75C æ±‚å®Œgcdå› æ•°å¯¹äºæ¯ä¸ªè¯¢é—®æŸ¥æ‰¾ æš´åŠ›å°±è¡Œ74C å¾ˆç„å­¦åæ­£æ±‚ä¸ªgcdå°±æ²¡äº†78C å•æ ¹æœ¨å¤´èƒ½åˆ†è§£å¹¶ä¸”æœ¨å¤´æ€»æ•°æ˜¯å¥‡æ•° å…ˆæ‰‹èƒœ pta-problemsetL1-064 è‡ªå·±åšå®¢ çŒ›ç”·å¸¦æ¨¡æ‹Ÿ hdoj-problemset1439 ç½®æ¢ç¾¤ æ‰¾ç¯è®°å½•ç¯é•¿ æ¯æ¬¡è·³kä½™å½“å‰ä½æ‰€åœ¨ç¯é•¿æ¬¡åçš„ä½ç½®èµ‹å€¼si2838 æ ‘çŠ¶æ•°ç»„ è®°å½•é€†åºå¯¹æ•°å’Œå‰ç¼€å’Œ æ¯æ¬¡å­˜åœ¨é€†åºå¯¹çš„æ—¶å€™ç´¯åŠ 2486 kå€åšå¼ˆæ¿å­1402 å¤§æ•°ç›¸ä¹˜ fftæ¿å­ Javaå¿«è¯»æ¿å­2065 é€’æ¨ æ¨ä¸å‡ºå…·ä½“å…¬å¼èƒ½æ‰¾è§„å¾‹ å¾ªç¯èŠ‚ä¸º204609 fftæ¿å­ é€šè¿‡fftç®—å‡ºæ‰€æœ‰ä¸¤ä¸ªæ•°å’Œçš„å¯èƒ½ä¸ªæ•°(?è¡¨è¿°å¯èƒ½ä¸æ˜¯å¾ˆæ¸… æƒ³ä¸èµ·æ¥å¯ä»¥çœ‹kuangbinåšå®¢) å‡å»é€‰ç›¸åŒçš„ å†æ€»æ–¹æ¡ˆå‡å¯ä»¥æ„æˆä¸‰è§’å½¢çš„1403 sa/samæ¿å­ lcs","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"},{"name":"pintia","slug":"pintia","permalink":"http://example.com/tags/pintia/"},{"name":"hdoj","slug":"hdoj","permalink":"http://example.com/tags/hdoj/"}]},{"title":"Codeforces 1326D2. Prefix-Suffix Palindrome (Hard version)","slug":"Codeforces-1326D2","date":"2020-03-19T22:37:40.000Z","updated":"2021-01-26T16:40:49.713Z","comments":true,"path":"2020/03/20/Codeforces-1326D2/","link":"","permalink":"http://example.com/2020/03/20/Codeforces-1326D2/","excerpt":"æ¯”èµ›ç¡è¿‡å»äº†=ã€‚=æ›´ä¸€ä¸‹D2çš„å„ç§å†™æ³•","text":"æ¯”èµ›ç¡è¿‡å»äº†=ã€‚=æ›´ä¸€ä¸‹D2çš„å„ç§å†™æ³• é¢˜ç›®é“¾æ¥manacher hash paméƒ½èƒ½æupd:kmpä¹Ÿè¡Œæ€è·¯è¿˜æ˜¯æ¯”è¾ƒæ¸…æ™°çš„å…ˆæŠŠåŸä¸²åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼šå‰ç¼€ åç¼€ ä¸­é—´æ¯”å¦‚acbba åˆ†æˆa+cbb+aç„¶åå¯¹ä¸­é—´è¿™ä¸ªéƒ¨åˆ†æ‰¾æœ€é•¿çš„ä»¥0å¼€å¤´æˆ–è€…ä»¥len-1ç»“å°¾çš„å›æ–‡ä¸²ç­”æ¡ˆå°±æ˜¯å‰ç¼€+æœ€é•¿å›æ–‡ä¸²+åç¼€ manacher1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;int che[2*maxn];string s,ma;void manacher(string s,int len0)&#123; ma=&quot;$#&quot;; rep(i,0,len0) ma+=s[i],ma+=&#x27;#&#x27;; // åˆ«å†™æˆma+=s[i]+&#x27;#&#x27;;äº† æ¢æˆ&quot;#&quot;åº”è¯¥å°±è¡Œ å‘œå‘œå‘œè¡€æ³ªæ•™è®­ int maxx=0,num=0,len=ma.size(); rep(i,0,len)&#123; che[i]=maxx&gt;i?min(che[2*num-i],maxx-i):1; while(ma[i+che[i]]==ma[i-che[i]]) che[i]++; if(i+che[i]&gt;maxx) maxx=i+che[i],num=i; &#125;&#125;void solve()&#123; cin&gt;&gt;s; int l=0,r=s.size()-1; while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); manacher(s,s.size()); int len=ma.size(),p(0),q(0),r1(0),r2(0); rep(i,0,len) if(p&lt;che[i]&amp;&amp;i-che[i]&lt;2) p=che[i],r1=i; dep(i,len-1,0) if(q&lt;che[i]&amp;&amp;i+che[i]==len) q=che[i],r2=i; // è¿™éƒ¨åˆ†æ¯”è¾ƒè€ƒå¯¹manacheræ•°ç»„çš„ç†Ÿç»ƒ?hhhè‡ªå·±æ‰‹å†™ä¸€ä¸‹åº”è¯¥å°±è¡Œ if(p&gt;=q) cout&lt;&lt;t1+s.substr(0,p-1)+t2&lt;&lt;&#x27;\\n&#x27;; else cout&lt;&lt;t1+s.substr(s.size()-q+1)+t2&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; hashè¿˜æ˜¯seedå’Œmodä¸å…¬å¼€ è™½ç„¶æˆ‘è¿™æ¬¡æ²¡æœ‰ç”¨å¸¸ç”¨çš„ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;string s; int n;int seed,mod,hs1[maxn],hs2[maxn],bas[maxn]; // hsçœ‹æƒ…å†µå¼€void init(int* hs)&#123; s=&#x27; &#x27;+s; bas[0]=1; rep(i,1,n+1)&#123; bas[i]=1ll*bas[i-1]*seed%mod; hs[i]=1ll*hs[i-1]*seed%mod+s[i]; if(hs[i]&gt;=mod) hs[i]-=mod; &#125; &#125;int getsum(int *h,int l,int r)&#123; int res=h[r]-1ll*h[l-1]*bas[r-l+1]%mod; if(res&lt;0) res+=mod; return res;&#125;void hash_init()&#123; seed=?,mod=?; init(hs1); reverse(s.begin(),s.end()); init(hs2);&#125;void solve()&#123; cin&gt;&gt;s; int l=0,r=s.size()-1,p(0),q(0); while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); n=s.size(); hash_init(); rep(i,1,n+1) if(getsum(hs1,1,i/2)==getsum(hs2,n-i+1,n-(i+1)/2)) p=i; rep(i,1,n+1) if(getsum(hs2,1,i/2)==getsum(hs1,n-i+1,n-(i+1)/2)) q=i; if(p&gt;q)&#123; reverse(s.begin(),s.end()); // ç°åœ¨çš„sæ˜¯&#x27; &#x27;+s+&#x27; &#x27; æ‰€ä»¥è¦ä»1å¼€å§‹ cout&lt;&lt;t1+s.substr(1,p)+t2&lt;&lt;&#x27;\\n&#x27;; &#125; else cout&lt;&lt;t1+s.substr(1,q)+t2&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; pamå‘œå‘œå‘œå¥½éš¾å•Špamå¥½éš¾ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;string s;struct PAM&#123; struct node&#123; int child[26],cnt,fail,num,len,pos; &#125;tt[maxn]; int last,n,tot; char s[maxn]; inline void clear()&#123; rep(i,0,tot+1)&#123; mst(tt[i].child,0); tt[i].cnt=tt[i].fail=tt[i].len=tt[i].num=tt[i].pos=0; &#125; last=n=0; tt[0].fail=tot=1; tt[1].len=-1; &#125; inline int getfail(int x)&#123; while(s[n-tt[x].len-1]!=s[n]) x=tt[x].fail; return x; &#125; inline void add(char ch)&#123; s[n]=ch; int cur=getfail(last); if(!tt[cur].child[ch-&#x27;a&#x27;])&#123; int now=++tot; tt[now].len=tt[cur].len+2; int p=getfail(tt[cur].fail); tt[now].fail=tt[p].child[ch-&#x27;a&#x27;]; tt[cur].child[ch-&#x27;a&#x27;]=now; tt[now].num=tt[tt[now].fail].num+1; &#125; last=tt[n].pos=tt[cur].child[ch-&#x27;a&#x27;]; ++tt[last].cnt; ++n; &#125; inline void count()&#123; dep(i,tot,0) tt[tt[i].fail].cnt+=tt[i].cnt; &#125;&#125;pam;int getpos(int n,int l,int r)&#123; int t=pam.tt[r].pos; while(l*2+pam.tt[t].len&gt;n) t=pam.tt[t].fail; return pam.tt[t].len;&#125;void solve()&#123; cin&gt;&gt;s; int l=0,r=s.size()-1,n=s.size(),p(0),q(0); while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; pam.clear(); dep(i,n-1,0) pam.add(s[i]); p=getpos(n,l,r); reverse(s.begin(),s.end()); pam.clear(); dep(i,n-1,0) pam.add(s[i]); q=getpos(n,l,r); reverse(s.begin(),s.end()); if(max(p,q)+2*l&gt;=n) cout&lt;&lt;s&lt;&lt;&#x27;\\n&#x27;; else if(p&gt;q) cout&lt;&lt;s.substr(0,p+l)+s.substr(r+1)&lt;&lt;&#x27;\\n&#x27;; else cout&lt;&lt;s.substr(0,l)+s.substr(r-q+1)&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; kmp12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e6 + 5;int nex[maxn];int getnext(string s)&#123; int i=0,j=-1,len=s.size(); nex[0]=-1; while(i&lt;len)&#123; if(j==-1||s[i]==s[j])&#123; i++; j++; nex[i]=j; &#125; else j=nex[j]; &#125; return nex[len];&#125;void solve()&#123; string s,t; cin&gt;&gt;s; int l=0,r=s.size()-1; while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); t=s; reverse(t.begin(),t.end()); string a=s+&#x27;*&#x27;+t,b=t+&#x27;*&#x27;+s; string p=a.substr(0,getnext(a)); string q=b.substr(0,getnext(b)); cout&lt;&lt;t1&lt;&lt;(p.size()&gt;q.size()?p:q)&lt;&lt;t2&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"Codeforces 19C. Deletion of Repeats","slug":"Codeforces-19C","date":"2020-03-17T04:27:40.000Z","updated":"2021-01-26T16:39:14.996Z","comments":true,"path":"2020/03/17/Codeforces-19C/","link":"","permalink":"http://example.com/2020/03/17/Codeforces-19C/","excerpt":"äº‹æƒ…ä¸ºä»€ä¹ˆä¼šå‘å±•æˆè¿™æ ·.jpg","text":"äº‹æƒ…ä¸ºä»€ä¹ˆä¼šå‘å±•æˆè¿™æ ·.jpg é¢˜ç›®é“¾æ¥ä¸€å¼€å§‹æ„Ÿè§‰æ˜¯æ±‚æœ€çŸ­ä¸åŒ…å«é‡å¤æ®µçš„åç¼€ å¡äº†å¥½ä¹…qwq åæ¥å‘ç°forforå°±å®Œäº‹äº†æœ¬æ¥æƒ³å†™sa hash æš´åŠ›ä¸‰ç§å†™æ³•çš„ ç»“æœå†™å®Œæš´åŠ›å‘ç°æ¯”saè¿˜å¿« ç¬é—´ç´¢ç„¶æ— å‘³ æˆ‘å†™saå¹²å˜›å‘¢ç¦»æ•£åŒ–ä¸€ä¸‹ç„¶åæšä¸¾å°±è¡Œ å°±å½“å¤ä¹ saäº†555 åç¼€æ•°ç»„248 ms 25400 KB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int s[maxn];int sa[maxn],rk[maxn];int height[maxn];int t1[maxn],t2[maxn],c[maxn];int best[20][maxn];int a[maxn],b[maxn];vector&lt;int&gt;vv[maxn];void getsa(int *s,int n,int m)&#123; int *x=t1,*y=t2; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[i]=s[i]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[i]]]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p=0; rep(i,n-k,n) y[p++]=i; rep(i,0,n) if(sa[i]&gt;=k) y[p++]=sa[i]-k; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[y[i]]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[y[i]]]]=y[i]; swap(x,y); p=1; x[sa[0]]=0; rep(i,1,n) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++; if(p&gt;=n) break; m=p; &#125;&#125;void getheight(int n)&#123; int k=0; rep(i,1,n+1) rk[sa[i]]=i; rep(i,0,n)&#123; if(k) k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k]) k++; height[rk[i]]=k; &#125;&#125;void RMQ(int n)&#123; int lg=(int)(log(n*1.0)/log(2.0)); rep(i,1,n+1) best[0][i]=height[i]; rep(i,1,lg+1) for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++) best[i][j]=min(best[i-1][j],best[i-1][j+(1&lt;&lt;i&gt;&gt;1)]); &#125;int lcp(int x,int y)&#123; x=rk[x]; y=rk[y]; if(x&gt;y) swap(x,y); x++; int lg=(int)(log(1.0*(y-x+1))/log(2.0)); return min(best[lg][x],best[lg][y-(1&lt;&lt;lg)+1]);&#125; // è´´æ¿å­struct node&#123; int l,r,len; &#125;p[maxn*10]; // åå€æ˜¯å› ä¸ºé¢˜ç›®çš„&quot;ä¿è¯é‡å¤ä¸è¿‡åæ¬¡&quot;int cmp(node a,node b)&#123; return a.len&lt;b.len||a.len==b.len&amp;&amp;a.l&lt;b.l; &#125; // æŒ‰é¢˜æ„sortint solve()&#123; int n,cnt(0),ans(0); sc(n); rep(i,0,n) sc(a[i]),b[i]=a[i]; sort(b,b+n); int bn=unique(b,b+n)-b; rep(i,0,n)&#123; s[i]=lower_bound(b,b+bn,a[i])-b+1; vv[s[i]].push_back(i); &#125; getsa(s,n+1,maxn); getheight(n); RMQ(n); rep(i,0,maxn) rep(j,0,vv[i].size()) rep(k,j+1,vv[i].size())&#123; if(vv[i][k]-vv[i][j]&gt;n-vv[i][k]) continue; if(vv[i][k]-vv[i][j]&lt;=lcp(vv[i][j],vv[i][k])) p[cnt++]=&#123;vv[i][j],vv[i][k],vv[i][k]-vv[i][j]&#125;; // åªè¦ç®—ä¸€ä¸‹è¿™ä¸€æ®µæ˜¯ä¸æ˜¯é‡å¤çš„å°±å¯ä»¥ æ”¹æˆhashä¹Ÿå·®ä¸å¤š &#125; sort(p,p+cnt,cmp); rep(i,0,cnt) if(p[i].l&gt;=ans) ans=p[i].r; pf(&quot;%d\\n&quot;,n-ans); rep(i,ans,n) pf(&quot;%d &quot;,a[i]); return 0;&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; æš´åŠ›186 ms 5000 KBæ€è·¯å·®ä¸å¤šçš„ ä¸è¿‡ç®—æ˜¯ä¼˜åŒ–äº†ä¸€ä¸‹qwq 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;map&lt;int,int&gt;aaa;vector&lt;int&gt;vv[maxn];int a[maxn],q[maxn];int solve()&#123; int n,cnt(0),ans(0); sc(n); rep(i,0,n)&#123; sc(a[i]); if(!aaa.count(a[i])) aaa[a[i]]=++cnt; q[i]=aaa[a[i]]; vv[aaa[a[i]]].push_back(i); &#125; rep(i,0,n) for(auto x:vv[q[i]])&#123; if(x&gt;=i) break; if(i-x&gt;n-i||x&lt;ans) continue; int ff(0); rep(j,0,i-x) if(a[i+j]!=a[x+j])&#123; ff++; break; &#125; if(!ff)&#123; ans=i; break; &#125; &#125; pf(&quot;%d\\n&quot;,n-ans); rep(i,ans,n) pf(&quot;%d &quot;,a[i]);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; upd:ylhæŠŠæˆ‘æš´åŠ›å¡äº† æ›´æ²¡æ„æ€äº†æ•°æ®: 1234567#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int main()&#123; cout&lt;&lt;100000&lt;&lt;&#x27;\\n&#x27;; rep(i,0,10) rep(j,0,10000) cout&lt;&lt;(j==9999?10001+i:j+1)&lt;&lt;&#x27;\\n&#x27;;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"Codeforces 7D. Palindrome Degree","slug":"Codeforces-7D","date":"2020-03-11T05:27:40.000Z","updated":"2021-01-26T16:39:08.071Z","comments":true,"path":"2020/03/11/Codeforces-7D/","link":"","permalink":"http://example.com/2020/03/11/Codeforces-7D/","excerpt":"æœ€è¿‘åœ¨å†™string è¿™é¢˜manacherå’Œhashå„å†™äº†ä¸€é","text":"æœ€è¿‘åœ¨å†™string è¿™é¢˜manacherå’Œhashå„å†™äº†ä¸€é é¢˜ç›®é“¾æ¥ä¹ä¸€çœ‹ä»¥ä¸ºæ˜¯pam åæ¥å‘ç°pamå†™ä¸äº†233 ä¸ç„¶è¦å†™ä¸‰ç§çš„åªè¦æ ¹æ®dp[i]=dp[i/2]+1;æ¥æ¨å°±è¡Œäº† æ€è·¯è¿˜æ˜¯æ¯”è¾ƒæ¸…æ™°çš„qwq manacher1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e6 + 5;char s[maxn],ma[2*maxn];int che[2*maxn],ww[2*maxn];void manacher(char* s,int len0)&#123; int len=0; ma[len++]=&#x27;$&#x27;; ma[len++]=&#x27;#&#x27;; rep(i,0,len0) ma[len++]=s[i],ma[len++]=&#x27;#&#x27;; ma[len]=0; int maxx=0,num=0; rep(i,0,len)&#123; che[i]=maxx&gt;i?min(che[2*num-i],maxx-i):1; while(ma[i+che[i]]==ma[i-che[i]]) che[i]++; if(i+che[i]&gt;maxx) maxx=i+che[i],num=i; &#125;&#125;void solve(int len)&#123; ll ans(0); rep(i,1,len+1)&#123; int l=2,r=2*i,m=l+r&gt;&gt;1; if(che[m]*2&gt;r-l+1) ww[r]=ww[m-1-(m-1)%2]+1; ans+=ww[r]; &#125; pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; scs(s); int len=strlen(s); manacher(s,len); solve(len);&#125; hashæˆ‘çš„hashå¸¸æ•°å¾ˆå¤§å•Š æŠ æŠ æ‰è¿‡è¿˜æ˜¯seedå’Œmodä¸å…¬å¼€äº†å§qwq 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e6 + 5;char s[maxn]; int n;struct haash&#123; int seed,mod,hs[maxn],bas[maxn]; // hsçœ‹æƒ…å†µå¼€ void init()&#123; bas[0]=1; rep(i,1,n+1)&#123; bas[i]=1ll*bas[i-1]*seed%mod; hs[i]=1ll*hs[i-1]*seed%mod+s[i]; if(hs[i]&gt;=mod) hs[i]-=mod; &#125; &#125; int getsum(int *h,int l,int r)&#123; int res=h[r]-1ll*h[l-1]*bas[r-l+1]%mod; if(res&lt;0) res+=mod; return res; &#125;&#125;hh[2];void hash_init()&#123; hh[0].seed=?,hh[0].mod=?; hh[0].init(); reverse(s+1,s+n+1); hh[1].seed=?,hh[1].mod=?; hh[1].init();&#125;int ww[maxn];void solve()&#123; ll ans=1; ww[1]=1; rep(i,2,n+1)&#123; if(hh[0].getsum(hh[0].hs,1,i/2)==hh[1].getsum(hh[1].hs,n-i+1,n-(i+1)/2)) ww[i]=ww[i/2]+1; ans+=ww[i]; &#125; pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; scs(s+1); n=strlen(s+1); hash_init(); solve();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"Codeforces Round #625è§£é¢˜æŠ¥å‘Š","slug":"Codeforces-Round-625è§£é¢˜æŠ¥å‘Š","date":"2020-03-02T01:42:16.000Z","updated":"2021-01-26T16:41:08.395Z","comments":true,"path":"2020/03/02/Codeforces-Round-625è§£é¢˜æŠ¥å‘Š/","link":"","permalink":"http://example.com/2020/03/02/Codeforces-Round-625%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"è®°å½•ä¸¢äººç‚¹æ»´","text":"è®°å½•ä¸¢äººç‚¹æ»´ è™½ç„¶çœŸçš„å¾ˆä¸¢äºº ä½†æ˜¯çœ‹äº†ä¸€ä¸‹å¤§å®¶ä»£ç å‘ç°æˆ‘è‡³å°‘ä»£ç è¿˜æ˜¯çŸ­(? A: Contest for Robotsé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šä¸¤ç§æœºå™¨äººå¯¹äºnä¸ªé—®é¢˜æœ‰ä¼šå’Œä¸ä¼š(1å’Œ0) å¸Œæœ›ç¬¬ä¸€ç§çš„å¾—åˆ†æ¯”ç¬¬äºŒç§é«˜ è¦å¦‚ä½•å®‰æ’é—®é¢˜åˆ†æ•°åˆ†å¸ƒ è¦æ±‚åˆ†æ•°ä¸­æœ€å¤§çš„å°½é‡å°ç®—ä¸€ä¸‹ç¬¬ä¸€ç§æ¯”ç¬¬äºŒç§å¤šçš„1å’Œ0 é™¤ä¸€ä¸‹å¯èƒ½ä¼šé™¤é›¶ è¦å…ˆåˆ¤æ‰å†é™¤ 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[105],b[105];int main()&#123; int n,c1(0),c2(0); sc(n); rep(i,0,n) sc(a[i]); rep(i,0,n)&#123; sc(b[i]); if(a[i]==b[i]) continue; else if(a[i]&gt;b[i]) c1++; else c2++; &#125; if(!c1) return pf(&quot;-1\\n&quot;),0; int ans=(c2+c1)/c1; pf(&quot;%d\\n&quot;,ans&gt;0?ans:0);&#125; B: Journey Planningé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šå¸Œæœ›é€‰æ‹©bçš„æ€»å’Œå°½é‡å¤§ä¸”æ»¡è¶³é€‰ä¸­çš„bi,bjæœ‰i-j==bi-bjæ¯ä¸ªbå»å‡å»i æ‰¾ç›¸åŒçš„æ•°ç»„å­˜çš„è¯åŠ ä¸Šnä¹Ÿè¡Œ ä½†æ˜¯mapå°±æ˜¯é¦™å•Šè¦ll èµ›æ—¶æ¯”è¾ƒè‰ç‡qwq 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;#define int lltypedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[maxn];map&lt;int,int&gt;ans;signed main()&#123; int n,mx(0); sc(n); rep(i,1,n+1)&#123; sc(a[i]); int t=a[i]-i; ans[t]+=a[i]; &#125; for(auto&amp; x:ans) mx=max(mx,x.second); pf(&quot;%lld\\n&quot;,mx);&#125; C: Remove Adjacenté¢˜ç›®é“¾æ¥é¢˜æ„ï¼šç»™ä¸€ä¸ªå­—ç¬¦ä¸² å¯¹äºæ¯ä¸ªå­—ç¬¦ å¦‚æœç›¸é‚»å­—ç¬¦æœ‰asciiç åˆšå¥½æ¯”è‡ªå·±å°‘1çš„ åˆ™å¯ä»¥åˆ é™¤ é—®æœ€å¤šèƒ½åˆ å¤šå°‘ä¸ªæšä¸¾zåˆ°a æ¯æ¬¡forä¸€éåˆ  O(26*n^3) 1234567891011#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;int main()&#123; ios::sync_with_stdio(0); int n,cnt(0); string s; cin&gt;&gt;n&gt;&gt;s; s+=&#x27; &#x27;; dep(k,25,1) rep(i,0,n) if(s[i]==k+&#x27;a&#x27;)&#123; if(s[i+1]==s[i]-1||(i&amp;&amp;s[i-1]==s[i]-1)) s.erase(i,1),n--,cnt++,i=i?i-2:-1; &#125; cout&lt;&lt;cnt;&#125; D: Navigation Systemé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šé«˜å¾·åœ°å›¾æŒç»­ä¸ºæ‚¨è§„åˆ’è·¯çº¿nä¸ªç‚¹mæ¡è¾¹çš„æœ‰å‘æ— æƒå›¾ ç»™kä¸ªç‚¹æ˜¯å¿…é¡»ç»è¿‡çš„ å¯¼èˆªæ¯æ¬¡è·¯çº¿ä¼šé€‰æ‹©æœ€çŸ­è·¯ å¦‚æœä¸æ˜¯æœ€çŸ­è·¯å°±rebuildé‡æ–°æ‰¾æœ€çŸ­è·¯ é—®rebuildçš„æœ€å°‘å’Œæœ€å¤šæ¬¡æ•°æ— æƒå›¾ bfs/dij/spfaå•¥çš„éƒ½è¡Œqwqåˆ¤æ˜¯ä¸æ˜¯æœ€çŸ­è·¯ç”¨diså°±è¡Œmxå’Œmnå°±å·®åœ¨æœ‰å¤šæ¡æœ€çŸ­è·¯çš„æ—¶å€™ è¿™æ—¶å€™è®°ä¸€ä¸‹å°±å¥½äº† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;struct node&#123; int id,dt; bool operator &lt; (const node a) const&#123; return dt&gt;a.dt; &#125;&#125;;priority_queue&lt;node&gt;q;int n,m,k,s,t,tot;int dis[maxn],vis[maxn],head[maxn],cnt[maxn];int nex[maxn&lt;&lt;1],to[maxn&lt;&lt;1],val[maxn&lt;&lt;1];void addedge(int u,int v,int w)&#123; nex[++tot]=head[u]; head[u]=tot; to[tot]=v; val[tot]=w;&#125;void dij(int s)&#123; rep(i,1,n+1) dis[i]=1e9; dis[s]=0; q.push(&#123;s,0&#125;); while(!q.empty())&#123; int fr=q.top().id; q.pop(); if(vis[fr]) continue; vis[fr]++; for(int j=head[fr];j;j=nex[j]) if(dis[to[j]]&gt;val[j]+dis[fr]&amp;&amp;!vis[to[j]])&#123; dis[to[j]]=val[j]+dis[fr]; q.push(&#123;to[j],dis[to[j]]&#125;); &#125; else if(dis[to[j]]==val[j]+dis[fr]) cnt[to[j]]=1; &#125;&#125; // æ¿å­é—­ç€çœ¼ä¸€å¥—int p[maxn];int main()&#123; int mn(0),mx(0); sc(n); sc(m); while(m--)&#123; int u,v; sc(u); sc(v); addedge(v,u,1); &#125; sc(k); rep(i,1,k+1) sc(p[i]); dij(p[k]); rep(i,1,k+1)&#123; if(i!=k&amp;&amp;dis[p[i]]!=dis[p[i+1]]+1) mn++; else mx+=cnt[p[i]]; &#125; pf(&quot;%d %d\\n&quot;,mn,mn+mx);&#125; E: World of Darkraft: Battle for Azathothé¢˜ç›®é“¾æ¥è¡¥äº†åŠ qwq","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"ç¨³èµšè¿·æƒ‘ä»£ç é›†","slug":"ç¨³èµšè¿·æƒ‘ä»£ç é›†","date":"2020-03-01T08:55:33.000Z","updated":"2021-01-26T16:43:38.925Z","comments":true,"path":"2020/03/01/ç¨³èµšè¿·æƒ‘ä»£ç é›†/","link":"","permalink":"http://example.com/2020/03/01/%E7%A8%B3%E8%B5%9A%E8%BF%B7%E6%83%91%E4%BB%A3%E7%A0%81%E9%9B%86/","excerpt":"è‡ªé»‘å‘ é•¿æœŸæ›´æ–°","text":"è‡ªé»‘å‘ é•¿æœŸæ›´æ–° äº‹æƒ…çš„èµ·å› æ˜¯æ‰“äº†ä¸€åœºå¾ˆä¸¢äººçš„å‘¨èµ› èµ›åçœ‹è‡ªå·±ä»£ç è¯´äº†ä¸€å¥ æˆ‘èµ›æ—¶ä»£ç å¯ä»¥å…¥é€‰ç¨³èµšè¿·æƒ‘ä»£ç é›†äº† å¥½ è¯´æå°±æä»å°åˆ°å¤§å¥½åƒä¸ºACMå“­å¾—æœ€å¤šäº† æ‰“ä¸ªcfæ²¡æ‰“å¥½è§‰å¾—è‡ªå·±å¥½ç¬¨ å“­ æš‘å‡é€‰æ‹”ä»¥ä¸ºè‡ªå·±æ²¡è¿› å“­ å‘ç°è¢«ä¿é€äº† å“­å¾—æ›´å†å®³äº†â€¦ çŸ¥é“è‡ªå·±è¿™èµ›å­£æ²¡æ¯”èµ›æ—¶å€™å¿˜äº†å“­æ²¡å“­äº† åæ­£è¿‡äº†å¾ˆä½è°·çš„ä¸€æ®µæ—¶é—´ è¿˜æœ‰ä¸€é˜Ÿecäºšå†› æˆ‘å“­å¾—å¥½å¤§å£°â€¦ç¨³èµšç¬¨ç¬¨çš„ å­¦ä¸œè¥¿å¾ˆæ…¢ æ‰‹é€Ÿå¾ˆæ…¢ æ€è·¯å¾ˆå®¹æ˜“è¢«å¡ ä¸€ç‚¹ç‚¹æ²¡å‘æŒ¥å¥½å°±å®¹æ˜“æ•´åœºæ‰“å´© ç®€ç›´æ˜¯é˜Ÿé‡Œè›€è™«(ç¡®ä¿¡ è¿·æƒ‘*1ä¸çŸ¥é“åœ¨å¹²å˜› å¤šæ•´äº†ä¸€ä¸ªæ˜æ˜èƒ½ç”¨iåˆ¤æ–­çš„f 1rep(i,0,t) pf(&quot;%c&quot;,(f?&#x27;z&#x27;:&#x27;a&#x27;)),f^=1; è¿·æƒ‘*21ans=ans*min(a[i],(n-i)%mod); è¿·æƒ‘*31int n,l=0,r=n+1; sc(n); è¿·æƒ‘*4CF1283Cè¿™ä¹Ÿèƒ½è¿‡?.jpgå‡å‡åœ°å€’ç€forä¸€éè¿™ä¸ªæ˜¯åˆèœåˆç‰›é€¼å§(?ç¿»äº†ä¸€ä¸‹å¤§å®¶çš„å†™çš„éƒ½æŒºé•¿çš„(å°å£°bb 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;const int maxn = 2e5 + 5;int a[maxn],b[maxn],v[maxn];int main()&#123; int n,t=-1,pos=1,tp=0,tp2=0; sc(n); rep(i,1,n+1) sc(a[i]),v[a[i]]++; dep(i,n,1) if(a[i]) b[i]=a[i]; else&#123; if(t!=-1)&#123; b[i]=t; t=-1; continue; &#125; rep(j,pos,n+1) if(!v[j]&amp;&amp;j==i) t=j,tp2=i; else if(!v[j]&amp;&amp;j!=i)&#123; b[i]=j; v[j]++; pos=j; tp=i; break; &#125; &#125; if(t!=-1) b[tp2]=b[tp],b[tp]=t; rep(i,1,n+1) pf(&quot;%d &quot;,b[i]);&#125; è¿·æƒ‘*5å™” å™” å’šä½  åœ¨ å¹² ä»€ ä¹ˆ 123typedef long long ll;#define int ll#define %lld %d Canâ€™t compile file:program.cpp:12:9: error: macro names must be identifiers#define %lld %d 123typedef long long ll;#define int ll#define lld d Test: #1, time: 2000 ms., memory: 180992 KB, exit code: -1, checker exit code: 0, verdict: TIME_LIMIT_EXCEEDEDä¸æ„§æ˜¯æˆ‘ è¿·æƒ‘*6æˆ‘:æˆ‘å‹è¡Œäº† æˆ‘çˆ½äº†é˜Ÿå‹:? ä½  åœ¨ å¹² ä»€ ä¹ˆ 1pf(&quot;%lld\\n&quot;,dfs(m,1,0,0,0,p[i],sum[1]-a[i]*p[i],sum[0]-(1-a[i])*p[i],a[i]*2-1)); æ‰“ä¸ªæ­£å¸¸ç‰ˆ 12if(a[i]) pf(&quot;%lld\\n&quot;,dfs(m,1,0,0,0,p[i],sum[1]-p[i],sum[0],1));else pf(&quot;%lld\\n&quot;,dfs(m,1,0,0,0,p[i],sum[1],sum[0]-p[i],-1)); è¿·æƒ‘*7æœ‰æ—¶å€™å‹äº†è¡Œä¹Ÿä¼šå“­ç€å–Šæˆ‘å†ä¹Ÿä¸å‹äº†CF1312E","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Codeforces 1301D. Time to Run","slug":"Codeforces-1301D","date":"2020-02-13T20:47:40.000Z","updated":"2021-01-26T16:39:21.704Z","comments":true,"path":"2020/02/14/Codeforces-1301D/","link":"","permalink":"http://example.com/2020/02/14/Codeforces-1301D/","excerpt":"å‹è¡Œå¸¦å¸ˆèˆ¹æ–°å¤§ä½œ","text":"å‹è¡Œå¸¦å¸ˆèˆ¹æ–°å¤§ä½œ é¢˜ç›®é“¾æ¥27è¡Œå°±é—®ä½ ç‰›ä¸ç‰›é€¼ 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int qaq[5005]; string s=&quot;RDU&quot;,ans[5005];int main()&#123; int n,m,k,cnt(0); sc(n); sc(m); sc(k); int num=4*n*m-2*n-2*m; if(k&gt;num) return puts(&quot;NO&quot;),0; puts(&quot;YES&quot;); if(m==1)&#123; pf(&quot;%d\\n&quot;,k&gt;n-1?2:1); pf(&quot;%d %c\\n&quot;,min(k,n-1),&#x27;D&#x27;); k-=min(k,n-1); if(k) pf(&quot;%d %c\\n&quot;,k,&#x27;U&#x27;); return 0; &#125; rep(i,1,2*n+1)&#123; if(!k) break; if(i&amp;1)&#123; if(i==2*n-1) qaq[cnt]=min(k,m-1),ans[cnt++]=&quot;R&quot;,k-=min(k,m-1); else if(k/3&gt;=m-1) qaq[cnt]=m-1,ans[cnt++]=s,k-=3*m-3; else&#123; if(k/3) qaq[cnt]=k/3,ans[cnt++]=s; if(k%3)&#123; qaq[cnt]=1; rep(j,0,k%3) ans[cnt][j]=s[j]; cnt++; &#125; k=0; &#125; &#125; else&#123; int t=min(k,m-1); qaq[cnt]=t,ans[cnt++]=&quot;L&quot;,k-=t; if(t==m-1&amp;&amp;k&amp;&amp;i!=2*n) qaq[cnt]=1,ans[cnt++]=&quot;D&quot;,k--; &#125; &#125; if(k) qaq[cnt]=k,ans[cnt++]=&quot;U&quot;; pf(&quot;%d\\n&quot;,cnt); rep(i,0,cnt) pf(&quot;%d %s\\n&quot;,qaq[i],ans[i].c_str());&#125; è¦è®²æ¸…æ¥šéœ€è¦é…å›¾8 æˆ‘æ‡’ æˆ‘å°±çºªå¿µä¸€ä¸‹æˆ‘çŸ­çš„epçš„ä»£ç å°±å¥½äº†","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"PTA L1-064ä¼°å€¼ä¸€äº¿çš„AIæ ¸å¿ƒä»£ç ","slug":"PTA-L1-064ä¼°å€¼ä¸€äº¿çš„AIæ ¸å¿ƒä»£ç ","date":"2020-02-05T21:09:57.000Z","updated":"2021-01-26T16:41:29.786Z","comments":true,"path":"2020/02/06/PTA-L1-064ä¼°å€¼ä¸€äº¿çš„AIæ ¸å¿ƒä»£ç /","link":"","permalink":"http://example.com/2020/02/06/PTA-L1-064%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/","excerpt":"çŒ›ç”·å°±è¯¥å†™çŒ›é¢˜","text":"çŒ›ç”·å°±è¯¥å†™çŒ›é¢˜ åº”è¯¥æ˜¯è¿‡çš„ä»£ç ä¸­å¾ˆçŸ­çš„ä¸€ä¸ªäº†é‡Œé¢ä¹Ÿæœ‰å¾ˆå¤šå°å¿ƒæ€ ç®—æ˜¯ç”Ÿæ¶¯ä¸­æ¯”è¾ƒä¼˜ç§€çš„ä»£ç å§é¢˜ç›®é“¾æ¥ 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int main()&#123; int _; cin&gt;&gt;_; getchar(); while(_--)&#123; string s; getline(cin,s); cout&lt;&lt;s&lt;&lt;&quot;\\nAI:&quot;; while(s[0]==&#x27; &#x27;) s.erase(0,1); int len=s.length(); s=&#x27; &#x27;+s+&#x27; &#x27;; rep(i,1,len+1)&#123; if(s[i]!=&#x27;I&#x27;&amp;&amp;isupper(s[i])) s[i]=tolower(s[i]); else if(!isalnum(s[i])&amp;&amp;s[i]!=&#x27; &#x27;) s.insert(i,&quot; &quot;),s.insert(i+2,&quot;*&quot;),len+=2,i+=2; &#125; while(s.find(&quot;?&quot;)!=string::npos) s.replace(s.find(&quot;?&quot;),1,&quot;!&quot;); while(s.find(&quot; &quot;)!=string::npos) s.replace(s.find(&quot; &quot;),2,&quot; &quot;); while(s.find(&quot; I &quot;)!=string::npos) s.replace(s.find(&quot; I &quot;),3,&quot; You &quot;); while(s.find(&quot;*I &quot;)!=string::npos) s.replace(s.find(&quot;*I &quot;),3,&quot;*You &quot;); while(s.find(&quot; me &quot;)!=string::npos) s.replace(s.find(&quot; me &quot;),4,&quot; You &quot;); while(s.find(&quot;*me &quot;)!=string::npos) s.replace(s.find(&quot;*me &quot;),4,&quot;*You &quot;); while(s.find(&quot; can you &quot;)!=string::npos) s.replace(s.find(&quot; can you &quot;),9,&quot; I can* &quot;); while(s.find(&quot;*can you &quot;)!=string::npos) s.replace(s.find(&quot;*can you &quot;),9,&quot;*I can &quot;); while(s.find(&quot; could you &quot;)!=string::npos) s.replace(s.find(&quot; could you &quot;),11,&quot; I could &quot;); while(s.find(&quot;*could you &quot;)!=string::npos) s.replace(s.find(&quot;*could you &quot;),11,&quot;*I could &quot;); len=s.length(); rep(i,0,len) if(s[i]==&#x27;Y&#x27;) s[i]=&#x27;y&#x27;; else if(s[i]==&#x27;*&#x27;) s.erase(i,1),len--,i--; rep(i,2,len) if(!isalnum(s[i])&amp;&amp;s[i]!=&#x27; &#x27;&amp;&amp;s[i-1]==&#x27; &#x27;) s.erase(i-1,1),len--,i--; while(s[len-1]==&#x27; &#x27;) s.erase(len-1,1),len--; if(!len) cout&lt;&lt;&#x27; &#x27;; cout&lt;&lt;s&lt;&lt;&#x27;\\n&#x27;; &#125;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"pintia","slug":"pintia","permalink":"http://example.com/tags/pintia/"}]},{"title":"ç‰›å®¢å°ç™½æœˆèµ›21è§£é¢˜æŠ¥å‘Š","slug":"ç‰›å®¢å°ç™½æœˆèµ›21è§£é¢˜æŠ¥å‘Š","date":"2020-01-25T05:56:31.000Z","updated":"2021-01-26T16:43:18.842Z","comments":true,"path":"2020/01/25/ç‰›å®¢å°ç™½æœˆèµ›21è§£é¢˜æŠ¥å‘Š/","link":"","permalink":"http://example.com/2020/01/25/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B21%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"namo æ€ä¹ˆakä¸€åœºå°ç™½æœˆèµ›è¿™ä¹ˆéš¾å•Š","text":"namo æ€ä¹ˆakä¸€åœºå°ç™½æœˆèµ›è¿™ä¹ˆéš¾å•Š æ¯”èµ›é“¾æ¥é™¤äº†ä»£ç çŸ­åº¦ä¸€æ— æ˜¯å¤„äº† Audioæ‰¾å¤–å¿ƒ 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;double x1,y11,x2,y2,x3,y3,x,y;int main()&#123; cin&gt;&gt;x1&gt;&gt;y11&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3; double A1=2*(x2-x1),B1=2*(y2-y11),C1=x2*x2+y2*y2-x1*x1-y11*y11; double A2=2*(x3-x2),B2=2*(y3-y2),C2=x3*x3+y3*y3-x2*x2-y2*y2; x=((C1*B2)-(C2*B1))/((A1*B2)-(A2*B1)); y=((A1*C2)-(A2*C1))/((A1*B2)-(A2*B1)); printf(&quot;%.3lf %.3lf\\n&quot;,x,y);&#125; Bits12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;int n,t[5],s[15][5];void print()&#123; rep(i,1,3*(2*n+1)+5) putchar(&#x27;.&#x27;); putchar(&#x27;\\n&#x27;); dep(i,n+1,1)&#123; rep(j,1,4)&#123; rep(k,0,n-s[i][j]+1) putchar(&#x27;.&#x27;); rep(k,0,s[i][j]) putchar(&#x27;*&#x27;); putchar(s[i][j]?&#x27;*&#x27;:&#x27;|&#x27;); rep(k,0,s[i][j]) putchar(&#x27;*&#x27;); rep(k,0,n-s[i][j]) putchar(&#x27;.&#x27;); &#125; putchar(&#x27;.&#x27;); putchar(&#x27;\\n&#x27;); &#125;&#125;void move(int a,int b)&#123; s[++t[b]][b]=s[t[a]][a]; s[t[a]--][a]=0; rep(i,1,3*(2*n+1)+5) putchar(&#x27;-&#x27;); putchar(&#x27;\\n&#x27;); print();&#125;void solve(int n,int a,int b,int c)&#123; if(n==1) return move(a,c); solve(n-1,a,c,b); move(a,c); solve(n-1,b,a,c);&#125;int main()&#123; cin&gt;&gt;n; rep(i,1,n+1) s[++t[1]][1]=n-i+1; print(); solve(n,1,2+(n&amp;1),3-(n&amp;1));&#125; Channels123456#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll a,b; while(cin&gt;&gt;a&gt;&gt;b) cout&lt;&lt;b/60*50+min(50ll,b%60)-(a-1)/60*50-min(50ll,(a-1)%60)&lt;&lt;&#x27;\\n&#x27;;&#125; DDoS12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)using namespace std;const int maxn = 1e5 + 5;int in[maxn],vis[maxn];vector&lt;int&gt;vv[maxn];int main()&#123; int n,m; sc(n); sc(m); while(m--)&#123; int u,v,w; sc(u); sc(v); sc(w); vv[u].push_back(v); in[v]++; &#125; vis[1]=1; queue&lt;int&gt;q; q.push(1); while(!q.empty())&#123; int fr=q.front(); q.pop(); for(int t:vv[fr])&#123; vis[t]=(vis[t]+vis[fr])%20010905; if(!--in[t]) q.push(t); &#125; &#125; pf(&quot;%d\\n&quot;,vis[n]);&#125; Exams1234567#include&lt;bits/stdc++.h&gt;int main()&#123; int n; double a1(0),a2(0); std::cin&gt;&gt;n; while(n--)&#123; int a; double b,c,d,e,f,g,h; std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f&gt;&gt;g&gt;&gt;h; if(a==2) continue; a1+=b*(int)(c*d+e*f+g*h+0.5); a2+=b; &#125; printf(&quot;%.2lf&quot;,a1/a2);&#125; Fool Problem12345#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; cin&gt;&gt;s; puts((s[s.size()-1]-&#x27;0&#x27;)&amp;1?&quot;-1&quot;:&quot;1&quot;);&#125; Game1234567#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)int main()&#123; int n,cnt(0); std::cin&gt;&gt;n; rep(i,2,n+1) while(n%i==0) n/=i,cnt++; puts(cnt&amp;1?&quot;Nancy&quot;:&quot;Johnson&quot;);&#125; â€Happy New Year!â€œphp 1&quot;Happy New Year!&quot; I love you1234567891011#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[10],mod=20010905;int main()&#123; string s,q=&quot; iloveyou&quot;; a[0]=1; cin&gt;&gt;s; int len=s.length(); rep(i,0,len)&#123; s[i]=tolower(s[i]); rep(j,1,9) a[j]=(a[j]+(s[i]==q[j])*a[j-1])%mod; &#125; cout&lt;&lt;a[8];&#125; Jellyæˆ‘çœŸçš„æœäº† è¿™éƒ½èƒ½wa 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;char mp[105][105][105];int dir[6][3]=&#123;1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1&#125;;struct node&#123; int x,y,z,cnt;&#125;;int n,cnt;int vis[105][105][105];queue&lt;node&gt;q;int bfs()&#123; q.push(node&#123;0,0,0,1&#125;); vis[0][0][0]++; while(!q.empty())&#123; node fr=q.front(); q.pop(); rep(i,0,6)&#123; node c=fr; c.x+=dir[i][0],c.y+=dir[i][1],c.z+=dir[i][2]; if(c.x&lt;0||c.y&lt;0||c.z&lt;0||c.x&gt;=n||c.y&gt;=n||c.z&gt;=n) continue; if(vis[c.x][c.y][c.z]||mp[c.x][c.y][c.z]==&#x27;*&#x27;) continue; vis[c.x][c.y][c.z]++; c.cnt++; q.push(c); if(c.x==n-1&amp;&amp;c.y==n-1&amp;&amp;c.z==n-1) return cout&lt;&lt;c.cnt,0; &#125; &#125; return cout&lt;&lt;-1,0;&#125;int main()&#123; cin&gt;&gt;n; rep(i,0,n) rep(j,0,n) cin&gt;&gt;mp[i][j]; bfs();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"}]},{"title":"Wannafly Winter Camp 2020-Day7","slug":"Wannafly Winter Camp 2020-Day7","date":"2020-01-18T11:46:10.000Z","updated":"2021-01-26T16:42:40.468Z","comments":true,"path":"2020/01/18/Wannafly Winter Camp 2020-Day7/","link":"","permalink":"http://example.com/2020/01/18/Wannafly%20Winter%20Camp%202020-Day7/","excerpt":"ä»Šå¤©ä¹Ÿè¿˜å¥½ï¼Ÿé˜Ÿä¼EHKä¸‰é¢˜ æˆ‘EH è™½ç„¶è¯´Eæ˜¯æ‰“è¡¨çš„ï¼ˆ","text":"ä»Šå¤©ä¹Ÿè¿˜å¥½ï¼Ÿé˜Ÿä¼EHKä¸‰é¢˜ æˆ‘EH è™½ç„¶è¯´Eæ˜¯æ‰“è¡¨çš„ï¼ˆ å‰ä¸€ä¸ªå°æ—¶çŠ¶æ€æå·® å±äºçœ‹ä»€ä¹ˆä»€ä¹ˆä¸ä¼š çœ‹Hæ²¡æœ‰ä¸€ç‚¹æ€è·¯ æ„Ÿæ…¨ï¼šä»–ä»¬æ€ä¹ˆéƒ½ä¼šå•Šæ‰‹æ¨äº†ä¸€ä¸‹Hå‰5é¡¹çš„æƒ…å†µ å¿ƒé‡Œå¤§æ¦‚æœ‰äº†çŒœæƒ³ çœ‹äº†çœ‹acé˜Ÿä¼çš„ç”¨æ—¶ä¹Ÿå’Œæƒ³çš„å¼å­ä¸€æ · ä¸ºäº†ä¿é™©åˆæ‰‹æ¨äº†6 æœç„¶æƒ³çš„æ˜¯å¯¹çš„ æ—©çŸ¥é“è½äº†.jpgä½†è¿˜æ˜¯å› ä¸ºè®¡ç®—èŒƒå›´é”™äº†ç‚¸intäº†waäº†ä¸€å‘ æˆ‘æ˜¯åºŸç‰©è¿‡äº†Hçš„ç”Ÿæ´»å› ä¸ºKä¸¤ä¸ªé˜Ÿå‹éƒ½åœ¨çœ‹ å°±å»çœ‹æ–°é¢˜äº†ï¼ˆåŠ ä¸Šæˆ‘ä¹Ÿä¸æ˜¯å¾ˆæƒ³æ¨ å¼€äº†E åˆæ˜¯æ‰‹æ¨äº†å‰å‡ é¡¹ çŒœæƒ³äº†ä¸€ä¸ªç»“è®º é¡ºåˆ©waç„¶åè€ƒè™‘åˆ°äº†å…¶ä»–æƒ…å†µ ç»§ç»­æ¨å¼å­ ä½†é˜Ÿå‹Kè¿˜æ²¡è¿‡ é‚å¸®å€’å¿™åœ°çœ‹äº†çœ‹K å› ä¸ºçœŸçš„æ‡’å¾—æ¨ é˜Ÿå‹æ¨äº†å¥½å‡ éæˆ‘ç›¸ä¿¡å¼å­æ²¡é—®é¢˜ï¼åˆå»çœ‹Eå‘ç°Eåœ¨oeisç›´æ¥æœ‰è¡¨ æ¢Javaå†™ å› ä¸ºè¯­æ³•ä¸ç†Ÿå’Œæ”¹å¾—å¤ªæ€¥æˆåŠŸwa*2é˜Ÿå‹ä¹ŸæŠŠKè¿‡äº† +10 æ’åä»100å¼€å¤–å˜æˆ50+ æœ€ç»ˆæ’å60+å§ è¿˜è¡Œï¼ˆ 7E. ä¸Šå‡ä¸‹é™å­åºåˆ—123456789101112import java.math.*;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); int n=sc.nextInt(); BigInteger m=sc.nextBigInteger(); if(n==1)&#123; System.out.println(0); return; &#125; String[] s=&#123;&quot;2&quot;,&quot;6&quot;,&quot;22&quot;,&quot;86&quot;,&quot;340&quot;,&quot;1340&quot;,&quot;5254&quot;,&quot;20518&quot;,&quot;79932&quot;,&quot;311028&quot;,&quot;1209916&quot;,&quot;4707964&quot;,&quot;18330728&quot;,&quot;71429176&quot;,&quot;278586182&quot;,&quot;1087537414&quot;,&quot;4249391468&quot;,&quot;16618640836&quot;,&quot;65048019092&quot;,&quot;254814326164&quot;,&quot;998953992728&quot;,&quot;3919041821896&quot;,&quot;15385395144092&quot;,&quot;60438585676636&quot;,&quot;237563884988120&quot;,&quot;934311596780040&quot;,&quot;3676495517376184&quot;,&quot;14474185732012088&quot;,&quot;57011153530262480&quot;,&quot;224656915621201776&quot;,&quot;885652912419210822&quot;,&quot;3492861836026915782&quot;,&quot;13780479845245611084&quot;,&quot;54388113081432337380&quot;,&quot;214729932989712917668&quot;,&quot;848052809484541707556&quot;,&quot;3350334574655466140216&quot;,&quot;13239822072430180232232&quot;,&quot;52335808270599440879284&quot;,&quot;206934571189982074002548&quot;,&quot;818425886045480073365896&quot;,&quot;3237673398479042349060632&quot;,&quot;12811192923571669467870664&quot;,&quot;50704290989642196738527048&quot;,&quot;200721767558683308700217776&quot;,&quot;794758327136359419952519952&quot;,&quot;3147480247103506996680796444&quot;,&quot;12467371711588974170827212188&quot;,&quot;49393251191799570968275635832&quot;,&quot;195721323613651013964116220008&quot;,&quot;775681930753017847189773247816&quot;,&quot;3074691375740439617836809788744&quot;,&quot;12189592067181565816702419563248&quot;,&quot;48333049189844665620128143125968&quot;,&quot;191674487676565550273850199554424&quot;,&quot;760234106384599142912931614646008&quot;,&quot;3015721572748589992463595600401200&quot;,&quot;11964485381977151314836595373090960&quot;,&quot;47473780481353767802050510461474416&quot;,&quot;188394767873878618122620614886243696&quot;,&quot;747717213262848575274466080605467552&quot;,&quot;2967958428851480386917331132533607136&quot;,&quot;11782259592346823520686656131742782022&quot;,&quot;46778706886870096588550881954439021894&quot;,&quot;185744202455399051984941117140485426188&quot;,&quot;737612707907218431744486755161165283876&quot;,&quot;2929451267263567016070637982850089264452&quot;,&quot;11635570442457473175795713890168152798404&quot;,&quot;46220155055609632689452725735280292076408&quot;,&quot;183618435592218742042711461696686422730216&quot;,&quot;729526765909664873244748736973027445604932&quot;,&quot;2898712749488697136757456372292134404034564&quot;,&quot;11518796733262965478081905854113416167753128&quot;,&quot;45776865583236473399203960989099899119494776&quot;,&quot;181937009594320978873736215406788995917525032&quot;,&quot;723154688965889751097101396443192826411889064&quot;,&quot;2874588225169330729910266250097039087510781168&quot;,&quot;11427560208426660761216674193001922526450403536&quot;,&quot;45432226748523983679867488376304124899523401012&quot;,&quot;180636860154887532842333974035976978875788303284&quot;,&quot;718256924308840704281727251872444612431548985768&quot;,&quot;2856167234882640332177000885696057331411192948216&quot;,&quot;11358398642653256630400822038234943728547172796632&quot;,&quot;45173065721576308057178968529470878470010061869784&quot;,&quot;179667842488623618336093016334593779472760809719248&quot;,&quot;714642491229551839105935178063714692911965481155696&quot;,&quot;2842722058240330382759816822753037594153543736276232&quot;,&quot;11308537787442034315752841106800792975560381040259464&quot;,&quot;44988801505636138725613585002139650894736930818859728&quot;,&quot;178989582482503853042943703302031527717732898643340656&quot;,&quot;712157265987568127773494228152764511315128648488823312&quot;,&quot;2833664093821898191595666210009358256743525029610686224&quot;,&quot;11275728828895114632325888269455044211548265118705668448&quot;,&quot;44870838790971390745360943764893423662680647193816689696&quot;,&quot;178569214591821033028866839352551169428060985661714360092&quot;,&quot;710675533602207732686301380136130771528525107574404678684&quot;,&quot;2828512285392854707326223033551336688181493890435185846968&quot;,&quot;11258130303537041119524653026082830440762998748471762960936&quot;,&quot;44812126024908558505907621010943168569218082391894548561192&quot;&#125;; BigInteger q=new BigInteger(s[n-2]); q=q.mod(m); System.out.println(q); &#125;&#125; 7H. æ¸¸æˆ12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;ll n,cnt,ans,num,g;int main()&#123; scl(n); rep(i,1,n+1) rep(j,i+1,n+1) if(__gcd(i,j)==1) cnt++; if(n==1) return puts(&quot;0/1&quot;),0; if(n==2||n==3) return puts(&quot;1/1&quot;),0; ans=n*(n-1)/2; num=n/2; g=__gcd(num*cnt,ans); pf(&quot;%lld/%lld\\n&quot;,num*cnt/g,ans/g);&#125; 7K. ä¿®ç‚¼1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int n,a1,a2,b1[maxn],b2[maxn];int check(int x)&#123; ll t1=1ll*a1*x,t2=1ll*a2*x,mn=1e18; rep(i,1,n+1)&#123; ll res=0; if(t1&gt;=b1[i]&amp;&amp;t2&gt;=b2[i]) return 0; res+=b1[i]-t1&gt;0?b1[i]-t1:0; res+=b2[i]-t2&gt;0?b2[i]-t2:0; mn=min(mn,res); &#125; return 1ll*x*(x+1)/2&lt;mn;&#125;int main()&#123; cin&gt;&gt;a1&gt;&gt;a2&gt;&gt;n; rep(i,1,n+1) cin&gt;&gt;b1[i]&gt;&gt;b2[i]; int l=-1,r=1e9; while(l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if(check(mid)) l=mid+1; else r=mid-1; &#125; pf(&quot;%d\\n&quot;,l);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day6","slug":"Wannafly Winter Camp 2020-Day6","date":"2020-01-17T11:12:31.000Z","updated":"2021-01-26T16:42:34.080Z","comments":true,"path":"2020/01/17/Wannafly Winter Camp 2020-Day6/","link":"","permalink":"http://example.com/2020/01/17/Wannafly%20Winter%20Camp%202020-Day6/","excerpt":"æ‰‹é€Ÿåœº ä»Šå¤©æ˜¯åºŸç‰©","text":"æ‰‹é€Ÿåœº ä»Šå¤©æ˜¯åºŸç‰© å¼€å±€æŒ‘äº†ä¸ªé¢˜ç›® â€œè‡ªé—­â€ ä¸€çœ‹ å“¦ å°æ¨¡æ‹Ÿ è¿™ä¸ªæˆ‘å­¦å¾—æ¥å’Œé˜Ÿå‹è¯´ æœ‰ä¸ªæ¨¡æ‹Ÿ æˆ‘å»å†™äº† åŒæ—¶ç«‹ä¸‹flagï¼šå‰ä¸‰å°æ—¶å¯èƒ½æ²¡æˆ‘äº†å†™å®Œåå› ä¸ºå‚»é€¼å’Œè¯­æ–‡å¤ªå·®è¢«å…³äº†åŠå°æ—¶è¿™æ—¶å€™å·²ç»å†™å¾—å·®ä¸å¤šäº† æ²¡æˆ‘å•¥äº‹äº†å»æƒ³J ç„¶åè¢«å…³åˆ°æ¯”èµ›ç»“æŸ ç„å­¦åšæ³•æœç„¶ä¸å¯å–èµ›ådpè¡¥äº† 6C. é…’é¦†æˆ˜æ£‹æœ€ä¸çˆ±å†™çš„é¢˜ é˜Ÿå‹ä»£ç  12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;char s[1005];int main()&#123; int _; sc(_); while(_--)&#123; int n,a,b,c,d; sc(n),sc(a),sc(b),sc(c),sc(d),scs(s); int aa=a,bb=b,cc=c,dd=d,mx=0,mn=0; rep(i,0,n)&#123; if(s[i]==&#x27;0&#x27;)&#123; if(dd) dd--,cc++; else if(cc)&#123; &#125; else if(bb) bb--,aa++; &#125; else&#123; if(cc) mx++,cc--; else if(dd) dd--,cc++; else if(aa) aa--,mx++; else if(bb) bb--,aa++; &#125; &#125; aa=a,bb=b,cc=c,dd=d; rep(i,0,n)&#123; if(s[i]==&#x27;0&#x27;)&#123; if(cc)&#123; &#125; else if(dd) dd--,cc++; else if(aa)&#123; &#125; else if(bb) bb--,aa++; &#125; else&#123; if(dd) dd--,cc++; else if(cc) cc--,mn++; else if(bb) bb--,aa++; else if(aa) aa--,mn++; &#125; &#125; pf(&quot;%d %d\\n&quot;,mx,mn); &#125;&#125; 6F. å›¾ä¸ä¸‰è§’å½¢12345678910111213#include&lt;bits/stdc++.h&gt;#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;ll n,a,b,c,p,d,ans;vector&lt;int&gt;vv[5005];int main()&#123; scl(n); scl(a); scl(b); scl(c); scl(p); scl(d); rep(i,1,n+1) rep(j,1,n+1) if(i!=j&amp;&amp;(a*(i+j)*(i+j)+b*(i-j)*(i-j)+c)%p&gt;d) vv[i].push_back(j); rep(i,1,n+1) ans+=vv[i].size()*(n-vv[i].size()-1); ans=n*(n-1)*(n-2)/6-ans/2; printf(&quot;%lld\\n&quot;,ans);&#125; 6K. æœ€å¤§æƒå€¼æ’åˆ—123456789101112#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 1e5 + 5;int a[maxn];int main()&#123; int n,cnt(1); sc(n); rep(i,1,n+1)&#123; if(i&amp;1) a[cnt]=i; else a[n-cnt+1]=i,cnt++; &#125; rep(i,1,n+1) pf(&quot;%d &quot;,a[i]);&#125; 6L. ä½ å“åˆ°æˆ‘çš„é©¬äº†.jpg123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;char mp[105][105];int n,m,vis[105][105],ans[105][105];int dir[8][2]=&#123;2,1,2,-1,-2,1,-2,-1,1,2,1,-2,-1,2,-1,-2&#125;;struct node&#123; int x,y,cnt; &#125;s;void bfs()&#123; ans[s.x][s.y]=0; vis[s.x][s.y]=1; queue&lt;node&gt;q; q.push(s); while(!q.empty())&#123; node fr=q.front(); q.pop(); ans[fr.x][fr.y]=fr.cnt; rep(i,0,8)&#123; node t=fr; t.x+=dir[i][0],t.y+=dir[i][1],t.cnt++; if(t.x&lt;0||t.y&lt;0||t.x&gt;=n||t.y&gt;=m) continue; if(vis[t.x][t.y]||mp[t.x][t.y]==&#x27;X&#x27;) continue; if(mp[fr.x+dir[i][0]/2][fr.y+dir[i][1]/2]==&#x27;X&#x27;) continue; q.push(t); vis[t.x][t.y]++; &#125; &#125;&#125;int main()&#123; sc(n); sc(m); rep(i,0,n)&#123; scs(mp[i]); rep(j,0,m) if(mp[i][j]==&#x27;M&#x27;) s.x=i,s.y=j,s.cnt=0; &#125; mst(ans,-1); bfs(); rep(i,0,n) rep(j,0,m) pf(&quot;%d%c&quot;,ans[i][j],j==m-1?&#x27;\\n&#x27;:&#x27; &#x27;);&#125; 6M. è‡ªé—­12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;int q[105][15][2]; //è®¡æ•°int vis[105],ac[105]; //visè¿™ä¸ªäººæœ‰æ²¡æœ‰äº¤è¿‡ acè¿™ä¸ªäººæœ‰æ²¡æœ‰æäº¤è¿‡int sd[15]; //solvedint wa[105][15];int main()&#123; int n,m,w; sc(n); sc(m); sc(w); rep(i,0,w)&#123; int x,y,c; sc(x); sc(y); sc(c); q[x][y][c]++; vis[x]++; if(c)&#123; //å¦‚æœæ˜¯ac if(q[x][y][0]) wa[x][y]=max(wa[x][y],q[x][y][0]),q[x][y][0]=0; ac[x]++; if(q[x][y][1]==1) sd[y]++; //ä¸é‡å¤è®¡ç®—acäººæ•° &#125; &#125; rep(i,1,n+1) rep(j,1,m+1) if(q[i][j][0]) wa[i][j]=max(wa[i][j],q[i][j][0]); rep(i,1,n+1)&#123; if(!vis[i]) puts(&quot;998244353&quot;); //æ²¡æäº¤ else if(!ac[i]) puts(&quot;1000000&quot;); //çˆ†é›¶ else&#123; int ak(1); rep(j,1,m+1) if(!q[i][j][1]) ak=0; if(ak) puts(&quot;0&quot;); else&#123; //4 æœ‰äººaè‡ªå·±æ²¡a +20 //5 è¿‡åŠäººaè‡ªå·±æ²¡a +10 int ans(0); rep(j,1,m+1) if(!q[i][j][1]&amp;&amp;sd[j])&#123; ans+=20; if(sd[j]&gt;=n/2) ans+=10; &#125; //6 è¿wa kæ¬¡ +k^2 //7 è¿wa kæ¬¡ä¸”æ²¡a +k^2 rep(j,1,m+1)&#123; int k=wa[i][j]; k*=k; ans+=k; if(!q[i][j][1]) ans+=k; &#125; pf(&quot;%d\\n&quot;,ans); &#125; &#125; &#125;&#125; 6N. åˆå¹¶ï¼12345678910111213#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;int a[2005];int main()&#123; int n; ll ans(0); sc(n); rep(i,0,n) sc(a[i]); sort(a,a+n); if(n==1) return pf(&quot;%d\\n&quot;,a[0]),0; rep(i,0,n-1) ans+=1ll*a[i]*a[i+1],a[i+1]+=a[i]; pf(&quot;%lld\\n&quot;,ans);&#125; è¡¥é¢˜ï¼š 6G. å•è°ƒæ ˆ123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;int a[105],ans[105];int main()&#123; int _; sc(_); while(_--)&#123; int n; sc(n); rep(i,0,n) sc(a[i]); int cnt(0),pos(0); mst(ans,0); rep(i,1,n+1)&#123; while(pos&lt;n&amp;&amp;ans[pos]) pos++; if(pos==n) break; if(a[pos]==-1) a[pos]=i; dep(j,n-1,pos) if(a[j]==i) ans[j]=++cnt; &#125; rep(i,0,n) pf(&quot;%d%c&quot;,ans[i],i==n-1?&#x27;\\n&#x27;:&#x27; &#x27;); &#125;&#125; 6J. Ké‡æ’åˆ—123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;int jc[55],inv[55];int dp[55],tmp[55];int q[55][55][55];int qpow(int x,int y)&#123; int ans=1; while(y)&#123; if(y&amp;1) ans=1ll*ans*x%mod; x=1ll*x*x%mod; y&gt;&gt;=1; &#125; return ans;&#125;int C(int s,int x)&#123; return 1ll*jc[x]*inv[s]%mod*inv[x-s]%mod;&#125;void init()&#123; jc[0]=inv[0]=1; rep(i,1,51) jc[i]=1ll*jc[i-1]*i%mod,inv[i]=qpow(jc[i],mod-2); rep(i,1,51) rep(j,i,51) rep(k,1,j/i+1) if(k==1) q[i][j][k]=C(i,j); else q[i][j][k]=1ll*q[i][j-i][k-1]*C(i,j)%mod;&#125;void solve()&#123; int n; ll k; sc(n); scl(k); mst(dp,0); dp[0]=1; rep(i,1,n+1)&#123; if(k%i) continue; memcpy(tmp,dp,sizeof(dp)); rep(j,0,n+1) for(int t=1,a=jc[i-1];j+t*i&lt;=n;++t,a=1ll*a*jc[i-1]%mod) dp[j+t*i]=(1ll*dp[j+t*i]+1ll*tmp[j]*q[i][n-j][t]%mod*a%mod*inv[t])%mod; &#125; pf(&quot;%d\\n&quot;,dp[n]);&#125;int main()&#123; init(); int _; sc(_); while(_--) solve();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day5","slug":"Wannafly Winter Camp 2020-Day5","date":"2020-01-16T10:01:26.000Z","updated":"2021-01-26T16:42:28.349Z","comments":true,"path":"2020/01/16/Wannafly Winter Camp 2020-Day5/","link":"","permalink":"http://example.com/2020/01/16/Wannafly%20Winter%20Camp%202020-Day5/","excerpt":"ä»Šå¤©ä¸è‡ªé—­äº† rk31","text":"ä»Šå¤©ä¸è‡ªé—­äº† rk31 é˜Ÿé‡Œçš„ç½šæ—¶æä¾›è€… éacçš„å…¨æ˜¯æˆ‘äº¤çš„(å¼€åœºå†™G å½“æ—¶èŒƒå›´è¿˜æ˜¯1e16 æ‰“äº†ä¸ªè¡¨ ç­‰è¡¨çš„æ—¶å€™å»çœ‹A(ä¸€çœ‹ å•Š å•¥ç©æ„å•Š å’‹å†™å•Š æˆ‘å­¦ä¸æ¥å•Šå†ä¸€çœ‹ k&lt;=3å•Š é‚£æ²¡äº‹äº†ç„¶åå‚»é€¼é”™è¯¯waäº†3æ¬¡ å“ˆå“ˆç„¶åè¡¨æ‰“å®Œäº† å¯¹ç€2e8æƒ³äº†ä¸€ä¸‹ ç„¶åçœ‹çœ‹ç¾¤ å“¦å“¦æœçˆ¹è¯´æ”¹èŒƒå›´äº†æˆ‘å¯¹é˜Ÿå‹:â€å“¦,æˆ‘ä¼š!â€ç„¶åå¤æ‚åº¦ç®—é”™ -3 å“ˆå“ˆæ•°ç»„å¼€å°reä¸€æ¬¡ æœ€å+4è¿™æ—¶å€™æ˜¯ç¬¬ä¸ƒä¸ªè¿‡çš„!çŒ›çŒ›çŒ›ç”·æˆ‘:â€åæ­£åˆ«äººæœ‰+11çš„!æˆ‘çš„+4ä¹Ÿè¿˜å¥½8â€ç„¶ååˆ’æ°´åˆ’äº†1h(?å¸®é˜Ÿå‹åº·äº†åº·E æ‰¾åˆ°äº†å‡ ä¸ªbug è°ƒäº†ä¸€ä¸‹ è¿‡æ ·ä¾‹äº†!æˆ‘:â€è¦ä¸è¦äº¤?â€é˜Ÿå‹:â€äº¤äº¤äº¤â€wa6æ¼” wz æ¼”ç„¶åå†™ä»£ç çš„é˜Ÿå‹æ‰¾åˆ°äº†çœŸæ­£çš„bug!ac!å¿«ä¹åœ°ç¦»åœºäº† 5A. Alternative Accounts123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int q[3][maxn];vector&lt;int&gt;vv[6];int main()&#123; int n,k,m,a,cnt(0); sc(n); sc(k); rep(i,0,k)&#123; sc(m); rep(j,0,m) sc(a),q[i][a]++; &#125; if(k==1) pf(&quot;%d&quot;,m); else if(k==2)&#123; rep(i,1,n+1)&#123; if(q[0][i]+q[1][i]==2) cnt++; else if(q[0][i]) vv[0].push_back(i); else if(q[1][i]) vv[1].push_back(i); &#125; cnt+=max(vv[0].size(),vv[1].size()); pf(&quot;%d\\n&quot;,cnt); &#125; else if(k==3)&#123; rep(i,1,n+1)&#123; if(q[0][i]+q[1][i]+q[2][i]==3) cnt++; else if(q[0][i]+q[1][i]+q[2][i]==2)&#123; if(q[0][i]&amp;&amp;q[1][i]) vv[0].push_back(i); if(q[0][i]&amp;&amp;q[2][i]) vv[1].push_back(i); if(q[1][i]&amp;&amp;q[2][i]) vv[2].push_back(i); &#125; else if(q[0][i]+q[1][i]+q[2][i]==1)&#123; if(q[2][i]) vv[3].push_back(i); if(q[1][i]) vv[4].push_back(i); if(q[0][i]) vv[5].push_back(i); &#125; &#125; int sz[3]; mst(sz,0); rep(i,0,3) sz[i]=vv[i+3].size(); rep(i,0,3) cnt+=vv[i].size(),sz[i]-=vv[i].size(); rep(i,0,3) if(sz[i]&lt;0) sz[i]=0; cnt+=max(sz[0],max(sz[1],sz[2])); pf(&quot;%d\\n&quot;,cnt); &#125;&#125; 5E. Matching Problem1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int n,ans,a[305],b[5],sum[305][305];map&lt;int,int&gt;aaa;int getsum(int x,int y,int z)&#123; int res=n-x; res-=sum[x+1][a[x]]; if(a[x]!=a[y]) res-=sum[x+1][a[y]]; if(a[x]!=a[z]&amp;&amp;a[y]!=a[z]) res-=sum[x+1][a[y]]; return res;&#125;int main()&#123; sc(n); rep(i,1,n+1) sc(a[i]),aaa[a[i]]++; rep(i,1,5) sc(b[i]); dep(i,n,1)&#123; for(auto &amp;x:aaa) sum[i][x.first]=sum[i+1][x.first]; sum[i][a[i]]++; &#125; int pos(0); rep(i,1,4) if(b[i]==b[4]) pos=i; rep(i,1,n+1) rep(j,i+1,n+1) rep(k,j+1,n+1)&#123; int ff=(pos==1?i:pos==2?j:k); if((a[i]==a[j])==(b[1]==b[2])&amp;&amp;(a[j]==a[k])==(b[2]==b[3])&amp;&amp;(a[i]==a[k])&amp;&amp;(b[1]==b[3])) ans+=ff?sum[k+1][a[ff]]:getsum(k,j,i); &#125; pf(&quot;%d\\n&quot;,ans);&#125; 5G. Cryptographically Secure Pseudorandom Number Generator123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e5 + 5;pii a[2000]; int inv[maxn];int solve()&#123; int p,cnt(0),ff(0),mn; sc(p); if(p==1||p==2) return pf(&quot;0\\n&quot;); inv[0]=0,inv[1]=1,inv[2]=p/2+1,mn=inv[2]; rep(i,2,p)&#123; inv[i]=1ll*(p-p/i)*inv[p%i]%p; if(inv[i]&lt;=mn)&#123; if(inv[i]==a[cnt-1].first) break; mn=inv[i]; a[cnt++]=pii(i,inv[i]); if(i==inv[i])&#123; ff++; break; &#125; &#125; &#125; pf(&quot;%d\\n&quot;,cnt*2-ff); rep(i,0,cnt) pf(&quot;%d %d\\n&quot;,a[i].first,a[i].second); dep(i,cnt-1-ff,0) pf(&quot;%d %d\\n&quot;,a[i].second,a[i].first); return 0;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; è¡¥é¢˜ï¼š 5A. Alternative AccountsçŸ­çš„ 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,k,t,a,b,q[100005];int main()&#123; cin&gt;&gt;n&gt;&gt;k; while(k--)&#123; cin&gt;&gt;m; a=max(a,m); while(m--) cin&gt;&gt;t,q[t]++; &#125; while(n--) if(q[n+1]&gt;1) b++; cout&lt;&lt;max(a,b)&lt;&lt;&#x27;\\n&#x27;; &#125; 5J. Xor on Figures1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;char s[50][50];bitset&lt;1050&gt;p[1050],q;int n,cnt,ans=1,mod=1e9+7;void change(int x,int y)&#123; rep(i,0,n) rep(j,0,n) q[(i+x)%n*n+(j+y)%n]=s[i][j]-&#x27;0&#x27;; rep(i,0,n*n) if(q[i]==1)&#123; if(!p[i].count())&#123; p[i]=q; cnt++; break; &#125; q^=p[i]; &#125;&#125;int main()&#123; sc(n); n=1&lt;&lt;n; rep(i,0,n) scs(s[i]); rep(i,0,n) rep(j,0,n) change(i,j); rep(i,0,cnt) ans=2ll*ans%mod; pf(&quot;%d\\n&quot;,ans); &#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day3","slug":"Wannafly Winter Camp 2020-Day3","date":"2020-01-14T14:55:49.000Z","updated":"2021-01-26T16:41:58.907Z","comments":true,"path":"2020/01/14/Wannafly Winter Camp 2020-Day3/","link":"","permalink":"http://example.com/2020/01/14/Wannafly%20Winter%20Camp%202020-Day3/","excerpt":"èµ›æ—¶çˆ†é›¶äº† è®°çš„æ˜¯è¡¥é¢˜qwq","text":"èµ›æ—¶çˆ†é›¶äº† è®°çš„æ˜¯è¡¥é¢˜qwq 3A. é»‘è‰²æ°”çƒ12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[1005][1005],h[1005];int main()&#123; int n; sc(n); ll sum(0); rep(i,0,n) rep(j,0,n) sc(a[i][j]),sum+=1ll*a[i][j],h[i]+=a[i][j]; if(n==2) return pf(&quot;1 1\\n&quot;),0; sum/=(2ll*n-2); rep(i,0,n) pf(&quot;%d &quot;,(-1*sum+h[i])/(n-2));&#125; 3C. æ— å‘å›¾å®šå‘1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int n,m,ans,c[20];vector&lt;int&gt;vv[20];int judge(int x,int id)&#123; for(int t:vv[x]) if(c[t]==id) return 1; return 0;&#125;void dfs(int x,int num)&#123; if(ans&lt;=num) return; if(x&gt;n) return ans=min(ans,num),(void)0; rep(i,1,num+1) if(!judge(x,i))&#123; c[x]=i; dfs(x+1,num); c[x]=0; &#125; c[x]=num+1; dfs(x+1,num+1); c[x]=0;&#125;int main()&#123; sc(n); sc(m); ans=1e9; while(m--)&#123; int u,v; sc(u); sc(v); vv[u].push_back(v); vv[v].push_back(u); &#125; dfs(1,0); printf(&quot;%d\\n&quot;,ans-1);&#125; 3E. æ£‹æŠ€å“¥123456789101112#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;char s[505],c;int main()&#123; int _; sc(_); while(_--)&#123; int n,m; sc(n); sc(m); scs(s); c=s[0]; rep(i,1,n) scs(s); puts(c==&#x27;0&#x27;?&quot;aoligei&quot;:&quot;call&quot;); &#125;&#125; 3G. ç«å±±å“¥å‘¨æ¸¸ä¸–ç•Œ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; pii;const int maxn = 5e5 + 5;int n,k,vis[maxn];ll num[maxn],sum[maxn];ll mx1[maxn],mx2[maxn];vector&lt;pii&gt;vv[maxn];void upd(int id,ll x)&#123; if(x&gt;=mx1[id]) mx2[id]=mx1[id],mx1[id]=x; else if(x&gt;mx2[id]) mx2[id]=x;&#125;void dfs1(int x,int f)&#123; if(vis[x]) num[x]++; sum[x]=mx1[x]=mx2[x]=0; for(pii t:vv[x])&#123; ll y=t.first,z=t.second; if(y==f) continue; dfs1(y,x); num[x]+=num[y]; sum[x]+=sum[y]+(num[y]&gt;0)*z; upd(x,mx1[y]+(num[y]&gt;0)*z); &#125;&#125;void dfs2(int x,int f)&#123; for(pii t:vv[x])&#123; ll y=t.first,z=t.second; if(y==f) continue; sum[y]=sum[x]-z*(num[y]&gt;0)+z*(n-num[y]&gt;0); if(num[y]!=n&amp;&amp;mx1[y]+z==mx1[x]) upd(y,mx2[x]+z); else if(num[y]!=n) upd(y,mx1[x]+z); dfs2(y,x); &#125;&#125;int main()&#123; sc(n); sc(k); rep(i,1,n)&#123; ll u,v,w; scl(u); scl(v); scl(w); vv[u].push_back(make_pair(v,w)); vv[v].push_back(make_pair(u,w)); &#125; int a0; sc(a0); vis[a0]++; k--; while(k--)&#123; int a; sc(a); vis[a]++; &#125; dfs1(a0,0); dfs2(a0,0); rep(i,1,n+1) pf(&quot;%lld\\n&quot;,sum[i]*2-mx1[i]);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day2","slug":"Wannafly Winter Camp 2020-Day2","date":"2020-01-13T14:55:49.000Z","updated":"2021-01-26T16:41:51.171Z","comments":true,"path":"2020/01/13/Wannafly Winter Camp 2020-Day2/","link":"","permalink":"http://example.com/2020/01/13/Wannafly%20Winter%20Camp%202020-Day2/","excerpt":"çœŸçš„éš”äº†å¥½ä¹…æ‰è¡¥ èµ›æ—¶çˆ†é›¶äº†qwq","text":"çœŸçš„éš”äº†å¥½ä¹…æ‰è¡¥ èµ›æ—¶çˆ†é›¶äº†qwq 2A. æ‰˜ç±³çš„å­—ç¬¦ä¸²123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;char s[maxn];double p[maxn],q[maxn],ans;int judge(char c)&#123; if(c==&#x27;a&#x27;||c==&#x27;e&#x27;||c==&#x27;i&#x27;) return 1; if(c==&#x27;o&#x27;||c==&#x27;u&#x27;||c==&#x27;y&#x27;) return 1; return 0;&#125;int main()&#123; scs(s+1); int len=strlen(s+1); rep(i,1,len+1) p[i]=p[i-1]+1.0/i; rep(i,1,len+1) q[i]=q[i-1]+p[i]; rep(i,1,len+1) if(judge(s[i])) ans+=q[len]-q[len-i]-q[i-1]; pf(&quot;%.9lf\\n&quot;,2.0*ans/(1.0*len*(len+1)));&#125; 2C. çº³æ–°ä¸€ç™¾çš„çŸ³å­æ¸¸æˆ123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;ll x,q[65];int main()&#123; int n; sc(n); rep(i,0,n)&#123; ll a; scl(a); x^=a; int cnt=0; while(a)&#123; cnt++; if(a&amp;1) q[cnt]++; a&gt;&gt;=1; &#125; if(!x) pf(&quot;0\\n&quot;); else&#123; cnt=0; ll x1=x; while(x1)&#123; cnt++; x1&gt;&gt;=1; &#125; pf(&quot;%d\\n&quot;,q[cnt]); &#125; &#125;&#125; 2K. ç ´å¿’å¤´çš„åŒ¿åä¿¡12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;const int maxn = 5e5 + 5;char s[maxn];ll tot,ch[maxn][26],nex[maxn];ll len[maxn],val[maxn],f[maxn];void insert(char* s,ll x)&#123; int n=strlen(s+1),p=1; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!ch[p][tmp]) ch[p][tmp]=++tot,len[tot]=len[p]+1; p=ch[p][tmp]; &#125; if(!val[p]) val[p]=x; else val[p]=min(val[p],x);&#125;void build()&#123; queue&lt;ll&gt;q; q.push(1); nex[1]=0; while(!q.empty())&#123; int fr=q.front(); q.pop(); rep(i,0,26) if(!ch[fr][i]) ch[fr][i]=ch[nex[fr]][i]; else nex[ch[fr][i]]=ch[nex[fr]][i],q.push(ch[fr][i]); &#125;&#125;int find(char* s)&#123; int n=strlen(s+1),p=1; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;,k=ch[p][tmp]; while(k&gt;1)&#123; if(val[k]) f[i]=min(f[i],f[i-len[k]]+val[k]); k=nex[k]; &#125; p=ch[p][tmp]; &#125; if(f[n]&gt;1e18) return puts(&quot;-1&quot;); return pf(&quot;%lld\\n&quot;,f[n]);&#125;int main()&#123; ll n,a; scl(n); mst(f,0x3f); f[0]=0; rep(i,0,26) ch[0][i]=1; tot=1; rep(i,0,n) scs(s+1),scl(a),insert(s,a); build(); scs(s+1); find(s);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day1","slug":"Wannafly Winter Camp 2020-Day1","date":"2020-01-12T14:55:49.000Z","updated":"2021-01-26T16:41:44.005Z","comments":true,"path":"2020/01/12/Wannafly Winter Camp 2020-Day1/","link":"","permalink":"http://example.com/2020/01/12/Wannafly%20Winter%20Camp%202020-Day1/","excerpt":"ç¬¬ä¸€åœºæ¯”èµ›è¿˜ç®—æ¯”è¾ƒé¡ºåˆ©8","text":"ç¬¬ä¸€åœºæ¯”èµ›è¿˜ç®—æ¯”è¾ƒé¡ºåˆ©8 é˜Ÿä¼BCHä¸‰é¢˜ rk55 æˆ‘å†™äº†CHä¸¤é¢˜ ç®—æ˜¯æ²¡ä¸¢æ•°å­¦é€‰æ‰‹å…¼Javaé€‰æ‰‹çš„è„¸å§233å¼€é¢˜æ—¶çœ‹åˆ°Hçš„é¢˜ç›®â€œæœ€å¤§å…¬çº¦æ•°â€å°±ç›´æ¥ç‚¹è¿›å»äº† ç„¶åæœ‰æ€è·¯å¼€å§‹å†™ wa2 é€ äº†å‡ ä¸ªå°æ•°æ®å‘ç°è‡ªå·±æœ‰åœ°æ–¹å‡äº† è°ƒè¿‡äº†ä¸€äº¤è¿˜æ˜¯wa2 ç„¶åæƒ³äº†æƒ³æé™æ•°æ® å•Šå¥½åƒlong longå¿…ç‚¸ å°±æ¢Javaå†™äº† ç„¶åACåœ¨æˆ‘è°ƒHçš„æ—¶å€™é˜Ÿå‹å·²ç»æŠŠBè¿‡äº† ç„¶åå¥½åƒæ˜¯å¯¹ç€Fè‡ªé—­ï¼ŸHè¿‡äº†æƒŠé—»åˆ˜è€å¸ˆæŠŠCç§’äº† æˆ‘:åˆ˜è€å¸ˆèƒ½ç§’æˆ‘ä»¬åº”è¯¥ä¹Ÿèƒ½A! å°±çœ‹çœ‹C å¾ˆå¿«æœ‰äº†æƒ³æ³• æ‰‹æ¨äº†ä¸€ä¸‹æ ·ä¾‹éªŒè¯äº†çŒœæƒ³å¼€å§‹å†™ å› ä¸ºæˆ‘æ˜¯æ²¡æœ‰åŒ–å‡ºå¼å­çš„QAQ å°±ä¸€å †ä¸­é—´è¿‡ç¨‹ å†™å¾—å¤´éƒ½æ²¡äº† å†™å®Œä¸€æµ‹æ ·ä¾‹å››ä¸ªæ²¡è¿‡ å¼€å§‹è‡ªé—­ ç„¶åå½“æ—¶ä»¥ä¸ºäº”ç‚¹åŠå°±ç»“æŸäº†æœ‰ç‚¹æƒ³æ”¾å¼ƒäº† ä¸€çœ‹æ¯”èµ›æ—¶é—´è¿˜ä¸€ä¸ªå°æ—¶ åˆå……æ»¡äº†ä¿¡å¿ƒç»§ç»­è°ƒ ç»ˆäºæŠŠç¬¬å››ä¸ªæ ·ä¾‹è°ƒå¯¹äº† ä¸€æ¯”å¯¹ç¬¬äº”ä¸ªæ ·ä¾‹çš„å¯¹çš„ ç›´æ¥äº¤äº† 1A æ¿€åŠ¨å¾—è¦æ­»æœ€å45minè¯•ç€æƒ³F å®åœ¨æ˜¯æ²¡æ€è·¯QAQ æ¯”èµ›ç»“æŸ!æ™šä¸Šå¬jlsè®²é¢˜ å•ŠjlsçœŸçš„å¤ªå¸…äº† æˆ‘æ°¸è¿œå–œæ¬¢jryé™„èµ›æ—¶ä»£ç  2020 CCPC Wannafly Winter Camp Day1 B. å¯†ç å­¦1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;char s[1005][105];int n,m,x[1005],y[1005];int change(char c)&#123; if(c&gt;=&#x27;a&#x27;) return c-&#x27;a&#x27;; else return c-&#x27;A&#x27;+26;&#125;void solve(int a,int b)&#123; int l1=strlen(s[a]),l2=strlen(s[b]); rep(i,0,l2)&#123; int p=change(s[a][i%l1]),q=change(s[b][i]),t=(q-p+52)%52; if(t&lt;26) s[b][i]=&#x27;a&#x27;+t; else s[b][i]=&#x27;A&#x27;+t-26; &#125;&#125;int main()&#123; sc(n); sc(m); rep(i,1,m+1) sc(x[i]),sc(y[i]); rep(i,1,n+1) scs(s[i]); dep(i,m,1) solve(x[i],y[i]); rep(i,1,n+1) pf(&quot;%s\\n&quot;,s[i]);&#125; 2020 CCPC Wannafly Winter Camp Day1 C. æŸ“è‰²å›¾æƒ³äº†æƒ³å…¬å¼ç¡®å®æ˜¯å¯ä»¥åŒ–å‡ºæ¥çš„ ä½†æˆ‘æ²¡æœ‰(è°ƒå‚»äº†( 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;int main()&#123; int _; sc(_); while(_--)&#123; ll n,l,r; scl(n); scl(l); scl(r); ll ans=n*(n-1)/2%mod,res=0; ans=ans*(r-l+1)%mod; for(ll i=1;i*i&lt;=n;i++)&#123; ll r1=n/i,l1=n/(i+1)+1; if(l1&gt;r1) l1=r1; //ä¸Šä¸‹ç•Œ if(i&gt;=l)&#123; ll ys=n%i,sy=i-ys; //ä½™æ•° å‰©ä½™ res+=ys*(r1*(r1+1)/2)%mod+sy*(r1*(r1-1)/2)%mod; res%=mod; //iæ—¶çš„æ•°é‡ &#125; if(r1==i) break; l1=max(l1,l); r1=min(r1,r); if(l1&gt;r1) continue; ll a1=n%r1,a2=n%l1; ll num=(r1-l1+1),sum=(a1+a2)*num/2%mod; ll rem=(l1+r1)*num/2-sum; rem%=mod; ll t1=i*(i-1)/2%mod,t2=i*(i+1)/2%mod; res+=t1*rem%mod; res%=mod; res+=t2*sum%mod; res%=mod; &#125; ans-=res; ans=(ans+mod)%mod; pf(&quot;%lld\\n&quot;,ans); &#125;&#125; 2020 CCPC Wannafly Winter Camp Day1 H. æœ€å¤§å…¬çº¦æ•°waäº†ä¸¤æ¬¡æ‰æƒ³åˆ°ç”¨Java( 1234567891011121314151617181920212223import java.math.*;import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc=new Scanner(System.in); int t=sc.nextInt(); while(t--&gt;0)&#123; int n=sc.nextInt(); int x=sc.nextInt(); int[] vis=new int[505]; for(int i=1;i&lt;=n;i++) vis[i]=0; if(n&lt;2*x) Syst,em.out.println(x); else&#123; for(int i=2*x;i&lt;=n;i+=x) vis[i]=1; for(int i=2*x;i&lt;=n;i+=x) for(int j=i*2;j&lt;=n;j+=i) if(vis[j]==1) vis[j]=0; BigInteger ans=BigInteger.valueOf(x); ans=ans.multiply(new BigInteger(&quot;2&quot;)); for(int i=2*x+1;i&lt;=n;i++) if(vis[i]==1)&#123; BigInteger tmp=BigInteger.valueOf(i); tmp=tmp.divide(ans.gcd(BigInteger.valueOf(i))); ans=ans.multiply(tmp); &#125; System.out.println(ans); &#125; &#125; &#125;&#125; è¡¥é¢˜: 2020 CCPC Wannafly Winter Camp Day1 A. æœŸæœ›é€†åºå¯¹123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e3 + 5;const int mod = 998244353;pii p[maxn];ll inv[maxn];int cmp(pii a,pii b)&#123; return a.first+a.second&lt;b.first+b.second;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1) ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;ll count(pii a,pii b)&#123; if(b.first&gt;a.second) return 0; int l=max(a.first,b.first),r=min(a.second,b.second); ll ans=1ll*(l-b.first+r-b.first)*(r-l+1)/2%mod; ans=(ans+1ll*(a.second-r)*(b.second-b.first+1))%mod; return ans;&#125;int main()&#123; int n; sc(n); rep(i,0,n) sc(p[i].first),sc(p[i].second); sort(p,p+n,cmp); rep(i,0,n) inv[i]=qpow(p[i].second-p[i].first+1,mod-2); ll ans(0); rep(i,0,n) rep(j,i+1,n) ans=(ans+inv[i]*inv[j]%mod*count(p[i],p[j])%mod)%mod; pf(&quot;%lld\\n&quot;,ans);&#125; 2020 CCPC Wannafly Winter Camp Day1 F. ä¹˜æ³•ç”Ÿ æ¶¯ ä¹‹ è€» 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;ll n,m,k,a[maxn],b[maxn],an[3],bn[3];ll getsum(ll c,ll x)&#123; int l=1,r=m; while(l&lt;=r)&#123; int mid=(l+r)/2; if(b[mid]*c&gt;=x) c&gt;0?r=mid-1:l=mid+1; else c&gt;0?l=mid+1:r=mid-1; &#125; return c&gt;0?m-l+1:r;&#125;int check(ll x)&#123; ll sum(0); rep(i,1,n+1) sum+=getsum(a[i],x); return sum&gt;=k;&#125;ll solve(ll l,ll r)&#123; while(l&lt;=r)&#123; ll mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; return r;&#125;int main()&#123; scl(n); scl(m); scl(k); rep(i,1,n+1) scl(a[i]),an[a[i]?a[i]&gt;0?0:1:2]++; rep(i,1,m+1) scl(b[i]),bn[b[i]?b[i]&gt;0?0:1:2]++; sort(a+1,a+n+1); sort(b+1,b+m+1); ll t=an[0]*bn[0]+an[1]*bn[1]; if(k&lt;=t) return pf(&quot;%lld\\n&quot;,solve(1ll,max(a[1]*b[1],a[n]*b[m]))),0; t+=an[2]*m+bn[2]*n-an[2]*bn[2]; if(k&lt;=t) return puts(&quot;0&quot;),0; return pf(&quot;%lld\\n&quot;,solve(min(a[1]*b[m],b[1]*a[n]),-1ll)),0;&#125; 2020 CCPC Wannafly Winter Camp Day1 I. Kå°æ•°æŸ¥è¯¢namo n2å¯ä»¥è¿‡ 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int a[maxn],p[maxn];int main()&#123; int n,m; sc(n); sc(m); rep(i,1,n+1) sc(a[i]); while(m--)&#123; int op,l,r,x; sc(op); sc(l); sc(r); sc(x); if(op==1) rep(i,l,r+1) a[i]=min(a[i],x); else&#123; mst(p,0); rep(i,l,r+1) p[a[i]]++; int ans(0); rep(i,1,n+1)&#123; int at=ans; ans+=p[i]; if(at&lt;ans&amp;&amp;ans&gt;=x)&#123; pf(&quot;%d\\n&quot;,i); break; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"ä¸€é“å¿«ä¹çš„äº•å­—æ£‹å¸¦æ¨¡æ‹Ÿ","slug":"å¸¦æ¨¡æ‹Ÿ","date":"2020-01-11T03:28:38.000Z","updated":"2021-01-26T16:43:02.633Z","comments":true,"path":"2020/01/11/å¸¦æ¨¡æ‹Ÿ/","link":"","permalink":"http://example.com/2020/01/11/%E5%B8%A6%E6%A8%A1%E6%8B%9F/","excerpt":"æˆ‘è¿‡äº†å¸¦æ¨¡æ‹Ÿ æˆ‘å¥½å¿«ä¹ æˆ‘æ˜¯å¿«ä¹çš„å°ç†Šè½¯ç³–","text":"æˆ‘è¿‡äº†å¸¦æ¨¡æ‹Ÿ æˆ‘å¥½å¿«ä¹ æˆ‘æ˜¯å¿«ä¹çš„å°ç†Šè½¯ç³– é¢˜ç›®é“¾æ¥å‰é¦–å¤§å­¦æ–°ç”Ÿèµ›çš„å¸¦æ¨¡æ‹Ÿ ä¸‹äº•å­—æ£‹é—®è‡ªå·±ä¸¤æ­¥èƒ½ä¸èƒ½èµ¢å…¶å®ä¹Ÿä¸ç®—å¾ˆå¤§233ä»£ç é•¿åº¦3185 ç”Ÿæ¶¯ä¹‹è€»ï¼ˆä¸æ˜¯æ³¨é‡Šåº”è¯¥è›®æ¸…æ¥šçš„ï¼ˆæŒ å¤´è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯å¦‚æœåˆå§‹å±€é¢è‡ªå·±å·²ç»è·èƒœäº† è¿™ä¸ªæ—¶å€™ç®—wrong 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e5 + 5;char mp[3][3],c,d,t,p;map&lt;char,int&gt;aaa;int judge(char x)&#123; rep(i,0,3) if(mp[i][0]==x&amp;&amp;mp[i][1]==x&amp;&amp;mp[i][2]==x) return 1; rep(i,0,3) if(mp[0][i]==x&amp;&amp;mp[1][i]==x&amp;&amp;mp[2][i]==x) return 1; if(mp[0][0]==x&amp;&amp;mp[1][1]==x&amp;&amp;mp[2][2]==x) return 1; if(mp[0][2]==x&amp;&amp;mp[1][1]==x&amp;&amp;mp[2][0]==x) return 1; return 0;&#125;int count(char x)&#123; rep(i,0,3) if((mp[i][0]==x)+(mp[i][1]==x)+(mp[i][2]==x)&gt;=2 &amp;&amp;(mp[i][0]==&#x27;.&#x27;||mp[i][1]==&#x27;.&#x27;||mp[i][2]==&#x27;.&#x27;)) return t=1,p=i,1; rep(i,0,3) if((mp[0][i]==x)+(mp[1][i]==x)+(mp[2][i]==x)&gt;=2 &amp;&amp;(mp[0][i]==&#x27;.&#x27;||mp[1][i]==&#x27;.&#x27;||mp[2][i]==&#x27;.&#x27;)) return t=2,p=i,1; if((mp[0][0]==x)+(mp[1][1]==x)+(mp[2][2]==x)&gt;=2 &amp;&amp;(mp[0][0]==&#x27;.&#x27;||mp[1][1]==&#x27;.&#x27;||mp[2][2]==&#x27;.&#x27;)) return t=3,1; if((mp[2][0]==x)+(mp[1][1]==x)+(mp[0][2]==x)&gt;=2 &amp;&amp;(mp[2][0]==&#x27;.&#x27;||mp[1][1]==&#x27;.&#x27;||mp[0][2]==&#x27;.&#x27;)) return t=4,1; return 0;&#125;int find(char x)&#123; rep(i,0,3) if(mp[i][0]!=x&amp;&amp;mp[i][1]!=x&amp;&amp;mp[i][2]!=x) return t=1,p=i,1; rep(i,0,3) if(mp[0][i]!=x&amp;&amp;mp[1][i]!=x&amp;&amp;mp[2][i]!=x) return t=2,p=i,1; if(mp[0][0]!=x&amp;&amp;mp[1][1]!=x&amp;&amp;mp[2][2]!=x) return t=3,1; if(mp[0][2]!=x&amp;&amp;mp[1][1]!=x&amp;&amp;mp[2][0]!=x) return t=4,1; return 0;&#125;int solve()&#123; getchar(); aaa.clear(); rep(i,0,3) rep(j,0,3)&#123; mp[i][j]=getchar(); aaa[mp[i][j]]++; getchar(); &#125; c=getchar(); d=&#x27;o&#x27;+&#x27;x&#x27;-c; if(aaa[c]!=aaa[d]) return puts(&quot;wrong!&quot;); if(!aaa[&#x27;.&#x27;]||judge(d)||judge(c)) return puts(&quot;wrong!&quot;); if(aaa[&#x27;.&#x27;]==9||aaa[c]==1) return puts(&quot;Cannot win!&quot;); //ä¸€ç§æ˜¯ è‡ªå·±ç¬¬ä¸€æ­¥èƒ½èµ¢ if(count(c)) return puts(&quot;LeeLdler win!&quot;); //ä¸€ç§æ˜¯ è‡ªå·±ä¸èƒ½ä¸€æ­¥èµ¢ äººæœºèƒ½ä¸€æ­¥èµ¢ å…ˆå µäººæœº //count d ç„¶åæ ¹æ®tå»æ”¹mp æ”¹å®Œå†å»count c if(count(d))&#123; if(t==1) rep(i,0,3) if(mp[p][i]==&#x27;.&#x27;) mp[p][i]=c; else if(t==2) rep(i,0,3) if(mp[i][p]==&#x27;.&#x27;) mp[p][i]=c; else if(t==3) rep(i,0,3) if(mp[i][i]==&#x27;.&#x27;) mp[i][i]=c; else rep(i,0,3) if(mp[i][2-i]==&#x27;.&#x27;) mp[i][2-i]=c; return puts(count(c)?&quot;LeeLdler win!&quot;:&quot;Cannot win!&quot;); &#125; //ä¸€ç§æ˜¯ è‡ªå·±å’Œäººæœºä¸èƒ½ä¸€æ­¥èµ¢ ä¸‹è‡ªå·±çš„ äººæœºå»å µ //è¿™æ—¶å€™ä½ é€‰çš„åº”è¯¥æ˜¯ä¸€ä¸ªç©ºåˆ— æŒ‡ä¸€è¡Œåªæœ‰è‡ªå·±å’Œç©ºä½ //å¦‚æœæ²¡æœ‰ç©ºåˆ— è‚¯å®šèµ¢ä¸äº† //ä¸€ä¸ªç©ºåˆ—æœ‰ä¸¤ç§æƒ…å†µ ä¸¤ç§éƒ½åˆ¤ä¸€ä¸‹ if(!find(d)) return puts(&quot;Cannot win!&quot;); else&#123; int tp1,tp2; if(t==1)&#123; rep(i,0,3) if(mp[p][i]==&#x27;.&#x27;)&#123; mp[p][i]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[p][i]==&#x27;.&#x27;)&#123; mp[p][i]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[p][tp1]=d,mp[p][tp2]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; else if(t==2)&#123; rep(i,0,3) if(mp[i][p]==&#x27;.&#x27;)&#123; mp[i][p]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[i][p]==&#x27;.&#x27;)&#123; mp[i][p]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[tp1][p]=d,mp[tp2][p]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; else if(t==3)&#123; rep(i,0,3) if(mp[i][i]==&#x27;.&#x27;)&#123; mp[i][i]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[i][i]==&#x27;.&#x27;)&#123; mp[i][i]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[tp1][tp1]=d,mp[tp2][tp2]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; else&#123; rep(i,0,3) if(mp[i][2-i]==&#x27;.&#x27;)&#123; mp[i][2-i]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[i][2-i]==&#x27;.&#x27;)&#123; mp[i][2-i]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[tp1][2-tp1]=d,mp[tp2][2-tp2]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; &#125; &#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; å“ˆå“ˆæˆ‘è¿‡äº†ï¼å†™æ¨¡æ‹Ÿèƒ½ç›´æ¥açœŸçš„å¥½å¿«ä¹ï¼ï¼","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"}]},{"title":"ACMæ¨¡æ¿-ç¨³èµšä¸ªäººç‰ˆ","slug":"ACMæ¨¡æ¿-ç¨³èµšä¸ªäººç‰ˆ","date":"2020-01-01T12:36:36.000Z","updated":"2021-01-26T16:38:24.090Z","comments":true,"path":"2020/01/01/ACMæ¨¡æ¿-ç¨³èµšä¸ªäººç‰ˆ/","link":"","permalink":"http://example.com/2020/01/01/ACM%E6%A8%A1%E6%9D%BF-%E7%A8%B3%E8%B5%9A%E4%B8%AA%E4%BA%BA%E7%89%88/","excerpt":"ç¨³èµšåˆä¸‘åˆTçš„æ¿å­","text":"ç¨³èµšåˆä¸‘åˆTçš„æ¿å­ å¤´æ–‡ä»¶1234567891011121314151617#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scd(x) scanf(&quot;%lf&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;const double eps = 1e-10;const double PI = acos(-1.0); å­—ç¬¦ä¸²æ“ä½œcharå‡½æ•°1234567891011char s1[maxn], s2[maxn];char c; int n;strcat(s1,s2); // s1+=s2;strncat(s1,s2,n); // åŠ ä¸Šs2çš„å‰nä¸ªå­—ç¬¦strchr(s1,c); // è¿”å›s1ä¸­ç¬¬ä¸€æ¬¡å‡ºç°cçš„ä½ç½®strnchr(s1,c); // è¿”å›s1ä¸­æœ€åä¸€æ¬¡å‡ºç°cçš„ä½ç½®strstr(s1,s2); // è¿”å›s1ä¸­ç¬¬ä¸€æ¬¡å‡ºç°s2çš„ä½ç½®strcmp(s1,s2); // æ¯”è¾ƒ èƒ½æ¯”å¤§å°çš„strncmp(s1,s2,n); // æ¯”å‰nä¸ªstrcpy(s1,s2); // s1=s2;strncpy(s1,s2,n); // s1ä¸ºs2å‰nä¸ªå­—ç¬¦ stringå‡½æ•°1234567891011121314string s1,s2;int pos,len; char c;s1.find(s2);// è¿”å›å€¼ä¸ºs2ç¬¬ä¸€æ¬¡å‡ºç°åœ¨s1çš„ä½ç½® // è‹¥s2ä¸æ˜¯s1å­ä¸²è¿”å› string::nposs1.replace(pos,len,s2);// s1ä»posä½å¼€å§‹é•¿åº¦lençš„å­ä¸²æ›¿æ¢æˆs2s1.substr(pos,len);s1.insert(pos,s2);s1.insert(pos,s2,len);// æ’å…¥s2çš„å‰lenä¸ªå­—ç¬¦s1.insert(pos,len,c);// æ’å…¥lenä¸ªcs1.erase(pos,len); å­—å…¸æ ‘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// æ•°ç»„ç‰ˆint trie[maxn][26];int cnt[maxn];void insert(char *s)&#123; int u=0; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!trie[u][tmp])&#123; trie[u][tmp]=++n; cnt[n]++; &#125; else cnt[trie[u][tmp]]++; u=trie[u][tmp]; &#125;&#125;int find(char *s)&#123; int u=0,len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!trie[u][tmp]) return 0; u=trie[u][tmp]; &#125; return cnt[u];&#125;// æŒ‡é’ˆç‰ˆstruct trie &#123; int cnt; trie *next[26]; trie()&#123; cnt=0; rep(i,0,26) next[i]=NULL; &#125;&#125;;trie *root,*p;void insert(char* s)&#123; p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if (p-&gt;next[tmp]==NULL) p-&gt;next[tmp]=new trie(); p=p-&gt;next[tmp]; p-&gt;cnt++; &#125;&#125;int find(char* s)&#123; p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if (p-&gt;next[tmp] == NULL) return 0; p=p-&gt;next[tmp]; &#125; return p-&gt;cnt;&#125; KMP12345678910111213141516171819202122232425262728293031323334353637int nex[maxn];void getnext(char* s)&#123; int i=0,j=-1,len=strlen(s); nex[0]=-1; while(i&lt;len)&#123; if(j==-1||s[i]==s[j])&#123; i++; j++; nex[i]=j; &#125; else j=nex[j]; &#125;&#125;int kmp(char *s1,char *s2)&#123; int i=0,j=0; getnext(s2); int len1=strlen(s1),len2=strlen(s2); while(i&lt;len1&amp;&amp;j&lt;len2)&#123; if(j==-1||s1[i]==s2[j])&#123; i++; j++; &#125; else j=nex[j]; if(j==len2) return i-j+1; &#125; return 0;&#125;/* å…³äºnextæ•°ç»„åº”ç”¨å¦‚if(nex[pos]&amp;&amp;pos%(pos-nex[pos])==0)å³æœ‰sçš„å‰posä½æœ‰(pos/(pos-nex[pos]))ä¸ªé•¿åº¦ä¸ºpos-nex[pos]çš„å‰ç¼€*///æ±‚æ€»å‰ç¼€æ•° dprep(i,1,len+1)&#123; int tmp=nex[i]; while(tmp) sum++,tmp=nex[tmp];&#125;// æ ¹æ®nexæ±‚s1å’Œs2å°¾å¤´è¡”æ¥é‡å éƒ¨åˆ†s2+=&#x27;*&#x27;+s1; int q=getnext(s2); ans=s2.substr(0,q);// å¥—å¨ƒnexæ±‚å‰ç¼€å’Œåç¼€ç›¸åŒéƒ¨åˆ†// oné¢„å¤„ç†æ±‚æ¯ä¸ªå‰ç¼€åœ¨å­—ç¬¦ä¸²ä¸­å‡ºç°äº†å‡ æ¬¡void getnum(int len)&#123; rep(i,1,len+1) num[nex[i]]++; dep(i,len,1) num[nex[i]]+=num[i]; int t=len; while(t)&#123; vv.push_back(t),t=nex[t]; &#125; pf(&quot;%d\\n&quot;,vv.size()); sort(vv.begin(),vv.end()); for(int x:vv) pf(&quot;%d %d\\n&quot;,x,num[x]+1); // é•¿åº¦å’Œæ¬¡æ•°&#125; EXKMP12345678910111213141516171819202122232425262728293031int nex[maxn], extend[maxn];void getnext(char* s)&#123; int aa=0,len=strlen(s); nex[0]=len; while(aa&lt;len-1&amp;&amp;s[aa]==s[aa+1]) aa++; nex[1]=aa; aa=1; rep(i,2,len)&#123; int p=aa+nex[aa]-1; int l=nex[i-aa]; if(i+l-1&gt;=p)&#123; int j=(p-i+1)&gt;0?p-i+1:0; while(i+j&lt;len&amp;&amp;s[i+j]==s[j]) j++; nex[i]=j; aa=i; &#125; else nex[i]=l; &#125;&#125;void getextend(char* s1,char* s2)&#123; int aa=0; mst(nex,0); getnext(s2); int len1=strlen(s1),len2=strlen(s2); int minl=min(len1,len2); while(aa&lt;minl&amp;&amp;s1[aa]==s2[aa]) aa++; extend[0]=aa; aa=0; rep(i,1,len1)&#123; int p=aa+extend[aa]-1,l=nex[i-aa]; if(i+l-1&gt;=p)&#123; int j=(p-i+1)&gt;0?p-i+1:0; while(i+j&lt;len1&amp;&amp;j&lt;len2&amp;&amp;s1[i+j]==s2[j]) j++; extend[i]=j; aa=i; &#125; else extend[i]=l; &#125;&#125; é©¬æ‹‰è½¦123456789101112int che[2*maxn];char s[maxn],ma[2*maxn];void manacher(char* s,int len0)&#123; int len=0; ma[len++]=&#x27;$&#x27;; ma[len++]=&#x27;#&#x27;; rep(i,0,len0) ma[len++]=s[i],ma[len++]=&#x27;#&#x27;; ma[len]=0; int maxx=0,num=0; rep(i,0,len)&#123; che[i]=maxx&gt;i?min(che[2*num-i],maxx-i):1; while(ma[i+che[i]]==ma[i-che[i]]) che[i]++; if(i+che[i]&gt;maxx) maxx=i+che[i],num=i; &#125;&#125; ACè‡ªåŠ¨æœº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// è®¡æ¯ä¸ªå•è¯æœ‰æ— å‡ºç° æ³¨é‡Šé‡Œå†™è®°å•è¯æ•°çš„ ä»¥*å¼€å¤´int ans;struct node&#123; node* next[26]; // æœ€å¤§100å¤Ÿçš„ æ‰€æœ‰é¢˜ node* fail; int end; // åœ¨å•è¯æœ«å°¾åšæ ‡è®° //* int id; node()&#123; end=0; //* id=0; fail=0; mst(next,0); &#125;&#125;;node* root;// å»ºå­—å…¸æ ‘//* int tot;void insert(char* s)&#123; node* p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if(p-&gt;next[tmp]==NULL) p-&gt;next[tmp]=new node(); p=p-&gt;next[tmp]; &#125; p-&gt;end++; //* p-&gt;id=++tot;&#125;queue&lt;node*&gt;q;// failæ•°ç»„ï¼šrootæŒ‡å‘NULL æ²¡å‡ºç°è¿‡çš„æŒ‡å‘root å‡ºç°è¿‡çš„æŒ‡å‘å‰ä¸€ä¸ªvoid getfail()&#123; root-&gt;fail=NULL; q.push(root); while(!q.empty())&#123; node* fr=q.front(); q.pop(); rep(i,0,26) if(fr-&gt;next[i])&#123; node* tem=fr-&gt;fail; while(tem)&#123; if(tem-&gt;next[i])&#123; fr-&gt;next[i]-&gt;fail=tem-&gt;next[i]; break; &#125; tem=tem-&gt;fail; &#125; if(tem==NULL) fr-&gt;next[i]-&gt;fail=root; q.push(fr-&gt;next[i]); &#125; &#125;&#125;//* num[maxn], mark[maxn], cnt;void ac_auto(char* s)&#123; node* p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; while(!p-&gt;next[tmp] &amp;&amp; p!=root) p=p-&gt;fail; p=p-&gt;next[tmp]; if(!p) p=root; node* tem=p; while(tem!=root)&#123; if(tem-&gt;end&gt;=0)&#123; ans+=tem-&gt;end; tem-&gt;end=-1; // å‡ºç°è¿‡äº†ç¬¬äºŒæ¬¡é‡åˆ°ä¸å†ç»Ÿè®¡ &#125; else break; /* if(tem-&gt;id)&#123; *if(!mark[tem-&gt;id]) *num[cnt++]=tem-&gt;id; // numæŒ‰åœ¨sä¸²ä¸­å‡ºç°é¡ºåºå­˜id *mark[tem-&gt;id]++; //markå­˜å‡ºç°ä¸å¦ é¡ºä¾¿å­˜æ¬¡æ•° &#125;*/ tem=tem-&gt;fail; &#125; &#125;&#125;// è™½ç„¶æŒ‡é’ˆç‰ˆæ€ªå¼±æ™ºçš„ ä½†èˆä¸å¾—äº†struct ACAM&#123; int ch[maxn][26]; int tot,num[maxn],nex[maxn]; void init()&#123; tot=1; rep(i,0,26) ch[0][i]=1; rep(i,0,26) ch[1][i]=0; &#125; void insert(char* s,int x)&#123; int n=strlen(s+1),p=1; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!ch[p][tmp])&#123; ch[p][tmp]=++tot; rep(j,0,26) ch[tot][j]=0; num[tot]=0; &#125; p=ch[p][tmp]; &#125; num[p]++; &#125; void getfail()&#123; queue&lt;int&gt;q; q.push(1); nex[1]=0; while(!q.empty())&#123; int fr=q.front(); q.pop(); rep(i,0,26) if(!ch[fr][i]) ch[fr][i]=ch[nex[fr]][i]; else nex[ch[fr][i]]=ch[nex[fr]][i],q.push(ch[fr][i]); &#125; &#125; void query(char* s)&#123; int n=strlen(s+1),p=1; cnt=0; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;,k=ch[p][tmp]; while(k&gt;1) ...,k=nex[k]; p=ch[p][tmp]; &#125; &#125;&#125;ac; åç¼€æ•°ç»„123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int s[maxn];int sa[maxn],rk[maxn];int height[maxn];int t1[maxn],t2[maxn],c[maxn];int best[20][maxn];char ss[maxn];void getsa(int *s,int n,int m)&#123; int *x=t1,*y=t2; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[i]=s[i]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[i]]]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p=0; rep(i,n-k,n) y[p++]=i; rep(i,0,n) if(sa[i]&gt;=k) y[p++]=sa[i]-k; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[y[i]]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[y[i]]]]=y[i]; swap(x,y); p=1; x[sa[0]]=0; rep(i,1,n) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++; if(p&gt;=n) break; m=p; &#125;&#125;void getheight(int n)&#123; int k=0; rep(i,1,n+1) rk[sa[i]]=i; rep(i,0,n)&#123; if(k) k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k]) k++; height[rk[i]]=k; &#125;&#125;void RMQ(int n)&#123; int lg=(int)(log(n*1.0)/log(2.0)); rep(i,1,n+1) best[0][i]=height[i]; rep(i,1,lg+1) for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++) best[i][j]=min(best[i-1][j],best[i-1][j+(1&lt;&lt;i&gt;&gt;1)]); &#125;int lcp(int x,int y)&#123; x=rk[x]; y=rk[y]; if(x&gt;y) swap(x,y); x++; int lg=(int)(log(1.0*(y-x+1))/log(2.0)); return min(best[lg][x],best[lg][y-(1&lt;&lt;lg)+1]);&#125; åç¼€è‡ªåŠ¨æœº1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374struct SAM&#123; int next[maxn&lt;&lt;1][26],link[maxn&lt;&lt;1],len[maxn&lt;&lt;1]; int a[maxn&lt;&lt;1],id[maxn&lt;&lt;1],right[maxn&lt;&lt;1]; int tot,root,last; inline void init()&#123; rep(i,0,tot+1) mst(next[i],0),right[i]=0; mst(len,0); mst(link,0); tot=last=root=1; &#125; inline void extend(int x)&#123; int p=last,now=++tot; right[now]=1; len[now]=len[p]+1; while(p&amp;&amp;!next[p][x]) next[p][x]=now,p=link[p]; if(!p) link[now]=root; else&#123; int q=next[p][x]; if(len[q]==len[p]+1) link[now]=q; else&#123; int tmp=++tot; memcpy(next[tmp],next[q],sizeof(next[q])); link[tmp]=link[q]; link[q]=link[now]=tmp; len[tmp]=len[p]+1; while(p&amp;&amp;next[p][x]==q) next[p][x]=tmp,p=link[p]; &#125; &#125; last=now; &#125; inline void slove()&#123; // æ‹“æ‰‘æ’åº rep(i,1,tot+1) ++a[len[i]]; rep(i,1,tot+1) a[i]+=a[i-1]; rep(i,1,tot+1) id[a[len[i]]--]=i; // wzå¯èƒ½ä¼šè®°ä¸å¾—çš„samç®€å•è¿ç”¨ï¼š // Â·sæ˜¯å¦åŒ…å«tï¼šè·‘ä¸€étçš„ç‚¹çœ‹nextæ˜¯ä¸æ˜¯éƒ½æœ‰å€¼ // Â·sä¸åŒå­ä¸²ä¸ªæ•°ï¼šç´¯åŠ len[id[i]]-len[link[id[i]]] // Â·sä¸åŒå­ä¸²æ€»é•¿åº¦ï¼šç´¯åŠ (len[id[i]]+1)*len[id[i]]/2-(len[link[id[i]]]+1)*len[link[id[i]]]/2 // Â·sæ‰€æœ‰å­ä¸²å‡ºç°æ¬¡æ•°ï¼š int las=1; rep(i,0,n)&#123; num[next[las][s[i]-&#x27;a&#x27;]]=1; las=next[las][s[i]-&#x27;a&#x27;]; &#125; ll ans(0); dep(i,tot,1)&#123; num[link[id[i]]]+=num[id[i]]; ans+=1ll*(len[id[i]]-len[link[id[i]]])*num[id[i]]; &#125; // Â·å­—å…¸åºç¬¬kå¤§å­ä¸²ï¼š //* opä¸º0æŒ‡è®¡ç®—æœ¬è´¨ä¸åŒå­ä¸² ä¸º1è®¡ç®—å…¨éƒ¨ if(!op) rep(i,1,tot+1) right[i]=1; else dep(i,tot,1)&#123; int t=id[i]; right[fa[t]]+=right[t]; &#125; right[1]=0; dep(i,tot,1)&#123; int t=id[i]; num[t]+=right[t]; rep(j,0,26) if(next[t][j]) num[t]+=num[next[t][j]]; &#125; if(k&gt;num[1]) return (void)pf(&quot;No such line.\\n&quot;); int now=1,cnt=0; while(k&gt;0)&#123; rep(i,0,26) if(next[now][i])&#123; if(k&lt;=num[next[now][i]])&#123; ans[cnt++]=&#x27;a&#x27;+i; now=next[now][i]; k-=right[now]; break; &#125; else k-=num[next[now][i]]; &#125; &#125; ans[cnt]=0; pf(&quot;%s\\n&quot;,ans); // Â·tåœ¨så‡ºç°æ¬¡æ•° // Â·tåœ¨så‡ºç°ä½ç½® // Â·å¤šä¸ªå­—ç¬¦ä¸²é—´çš„æœ€é•¿å…¬å…±å­ä¸² &#125; inline void lcs()&#123; int las=1,mx(0),cnt(0); rep(i,0,m)&#123; if(!next[las][t[i]-&#x27;a&#x27;])&#123; while(las&amp;&amp;!next[las][t[i]-&#x27;a&#x27;]) las=link[las]; if(las) cnt=len[las]+1,las=next[las][t[i]-&#x27;a&#x27;]; else las=1,cnt=0; &#125; else ++cnt,las=next[las][t[i]-&#x27;a&#x27;]; mx=max(mx,cnt); &#125; pf(&quot;%d\\n&quot;,mx); &#125;&#125;sam; æœ€å¤§æœ€å°è¡¨ç¤ºæ³•12345678910111213141516171819202122int getmin(char* s)&#123; int len=strlen(s); int i=0,j=1,k=0; while(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)&#123; int tmp=s[(i+k)%len]-s[(j+k)%len]; if(!tmp) k++; else&#123; if(tmp&gt;0) i+=k+1; else j+=k+1; if(i==j) j++; k=0; &#125; &#125; return min(i,j);&#125;int getmax(char* s)&#123; int len=strlen(s); int i=0,j=1,k=0; while(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)&#123; int tmp=s[(i+k)%len]-s[(j+k)%len]; if(!tmp) k++; else&#123; if(tmp&lt;0) i+=k+1; else j+=k+1; if(i==j) j++; k=0; &#125; &#125; return min(i,j);&#125; å›æ–‡æ ‘123456789101112131415161718192021222324252627282930313233343536373839// å›æ–‡æ ‘åˆå§‹èŠ‚ç‚¹01 è¡¨ç¤ºå¶/å¥‡æ•°é•¿åº¦ä¸²çš„æ ¹èŠ‚ç‚¹struct PAM&#123; struct node&#123; int child[26],cnt,fail,num,len,pos; // lenæ˜¯ä»å¼€å¤´å¼€å§‹æœ€é•¿å›æ–‡ä¸²é•¿åº¦ // numæ˜¯ä»¥è¿™ä¸ªç»“ç‚¹ç»“æŸçš„å›æ–‡ä¸²æ•° // cntæ˜¯èŠ‚ç‚¹è¡¨ç¤ºçš„æœ¬è´¨ä¸åŒå›æ–‡ä¸²æ•° &#125;tt[maxn]; int last,n,tot; char s[maxn]; inline void clear()&#123; rep(i,0,tot+1)&#123; mst(tt[i].child,0); tt[i].cnt=tt[i].fail=tt[i].len=tt[i].num=0; &#125; last=n=0; tt[0].fail=tot=1; tt[1].len=-1; &#125; inline int getfail(int x)&#123; while(s[n-tt[x].len-1]!=s[n]) x=tt[x].fail; return x; &#125; inline void add(char ch)&#123; s[++n]=ch; int cur=getfail(last); if(!tt[cur].child[ch-&#x27;a&#x27;])&#123; int now=++tot; tt[now].len=tt[cur].len+2; int p=getfail(tt[cur].fail); tt[now].fail=tt[p].child[ch-&#x27;a&#x27;]; tt[cur].child[ch-&#x27;a&#x27;]=now; tt[now].num=tt[tt[now].fail].num+1; &#125; last=tt[n].pos=tt[cur].child[ch-&#x27;a&#x27;]; ++tt[last].cnt; &#125; inline void count()&#123; dep(i,tot,0) tt[tt[i].fail].cnt+=tt[i].cnt; &#125;&#125;pam; hash123456789101112131415161718int seed[2]=&#123;27174403,19260817&#125;;// 18052103// 18271131 å°ç‡•å­¦å· ä¸æ˜¯è´¨æ•°int mod; // 998244353 100000007 // å¤§è´¨æ•° 9999999999999937/17int hs[2][maxn],bas[2][maxn];void init()&#123; bas[0][0]=bas[1][0]=1; rep(j,0,2) rep(i,1,n+1)&#123; bas[j][i]=1ll*bas[j][i-1]*seed[j]%mod; hs[j][i]=1ll*hs[j][i-1]*seed[j]%mod+s[i]; if(hs[j][i]&gt;=mod) hs[j][i]-=mod; &#125; &#125;int getsum(int j,int l,int r)&#123; int res=hs[j][r]-1ll*hs[j][l-1]*bas[j][r-l+1]%mod; if(res&lt;0) res+=mod; return res;&#125; è‡ªé—­å›¾è®ºdijkstra1234567891011121314151617181920212223242526struct node&#123; int id,dt; bool operator &lt; (const node a) const&#123; return dt&gt;a.dt; &#125;&#125;;priority_queue&lt;node&gt;q;int n,m,s,t,tot;int dis[maxn],vis[maxn],head[maxn];int nex[maxn&lt;&lt;1],to[maxn&lt;&lt;1],val[maxn&lt;&lt;1];void addedge(int u,int v,int w)&#123; nex[++tot]=head[u]; head[u]=tot; to[tot]=v; val[tot]=w;&#125;void dij(int s)&#123; rep(i,1,n+1) dis[i]=1e9; dis[s]=0; q.push(&#123;s,0&#125;); while(!q.empty())&#123; int fr=q.top().id; q.pop(); if(vis[fr]) continue; vis[fr]++; for(int j=head[fr];j;j=nex[j]) if(dis[to[j]]&gt;val[j]+dis[fr]&amp;&amp;!vis[to[j]])&#123; dis[to[j]]=val[j]+dis[fr]; q.push(&#123;to[j],dis[to[j]]&#125;); &#125; &#125;&#125; åŒä½™æœ€çŸ­è·¯12345678910// nä¸ªæ•°æœ‰Î£ai*xi=b bâˆˆ[b0,b1]void slove()&#123; rep(i,0,a[0]-1) rep(j,0,n) addedge(i,(i+a[j])%a[0],a[j]); dij(0); rep(i,0,a[0]-1)&#123; int t=dis[i]; if(t&lt;b0) ans+=(b1-t)/a[0]-(b0-t-1)/a[0]; else if(t&lt;=b1) ans+=(b1-t)/a[0]+1; &#125;&#125; ç¨³å®šå©šå§»é—®é¢˜12345678910111213141516171819202122232425262728int b[maxn][maxn],g[maxn][maxn];// b æ¯ä¸ªç”·ç”ŸæŒ‰å¥½æ„Ÿä½æ¬¡æ’ä¸‹æ¥çš„å¥³ç”Ÿ// g æ¯ä¸ªå¥³ç”Ÿå¯¹åº”æ¯ä¸ªç”·ç”Ÿçš„å¥½æ„Ÿåº¦int bm[maxn],gm[maxn];// å¯¹åº”å¼‚æ€§å·æ•°int vis[maxn][maxn];void stable_marriage()&#123; mst(bm,-1); mst(gm,-1); mst(vis,0); queue&lt;int&gt; q; rep(i,1,n+1) q.push(i); int fr,nex; while(!q.empty())&#123; fr=q.front(); q.pop(); rep(i,1,m+1)&#123; nex=b[fr][i]; if(vis[fr][nex]) continue; vis[fr][nex]=1; if(gm[nex]==-1)&#123; gm[nex]=fr; bm[fr]=nex; break; &#125; else if(g[nex][gm[nex]]&gt;g[nex][fr])&#123; q.push(gm[nex]); gm[nex]=fr; bm[fr]=nex; break; &#125; &#125; &#125;&#125; äºŒåˆ†åŒ¹é…åŒˆç‰™åˆ©ç®—æ³•1234567891011121314151617int ans;int mp[maxn][maxn];int vis[maxn],line[maxn];void init()&#123; ans=0; mst(mp,0); mst(line,0);&#125;int dfs(int x)&#123; rep(i,1,n+1) if(!vis[i]&amp;&amp;mp[i][x])&#123; vis[i]=1; if(!line[i]||dfs(line[i])) &#123; line[i]=x; return 1; &#125; &#125; return 0;&#125;void slove()&#123; rep(i,1,n+1)&#123; mst(vis,0); if(dfs(i)) ans++; &#125;&#125; å¼ºè¿é€štarjan123456789101112131415161718192021222324252627282930313233int n,m,cnt,id;int dfn[maxn],low[maxn];int ins[maxn],scc[maxn];stack&lt;int&gt;s;vector&lt;int&gt;vv[maxn];void init()&#123; cnt=id=0; rep(i,0,n+1)&#123; vv[i].clear(); dfn[i]=low[i]=ins[i]=scc[i]=0; &#125;&#125;void tarjan(int x)&#123; dfn[x]=low[x]=++id; ins[x]=1; s.push(x); rep(i,0,vv[x].size())&#123; int tmp=vv[x][i]; if(!dfn[tmp])&#123; tarjan(tmp); low[x]=min(low[x],low[tmp]); &#125; else if(ins[tmp]) low[x]=min(low[x],dfn[tmp]); &#125; if(low[x]==dfn[x])&#123; int tmp; cnt++; do&#123; tmp=s.top(); s.pop(); ins[tmp]=0; scc[tmp]=cnt; &#125; while(x!=tmp); &#125;&#125;void slove()&#123; rep(i,1,n+1) if(!dfn[i]) tarjan(i); mst(ins,0); mst(out,0); rep(i,1,n+1) rep(j,0,vv[i].size()) if(scc[i]!=scc[vv[i][j]])&#123; ins[scc[vv[i][j]]]++; out[scc[i]]++; &#125;&#125; åŒè¿é€šåˆ†é‡123456789101112131415161718192021222324252627282930313233343536// å‰²ç‚¹ï¼šè¿™ä¸ªç‚¹ä¸€æ—¦è¢«åˆ é™¤ï¼Œè¿™å¼ å›¾çš„è¿é€šå—æ•°é‡ä¼šå¢åŠ // æ¡¥ï¼šè¿™æ¡è¾¹ä¸€æ—¦è¢«åˆ é™¤ï¼Œè¿™å¼ å›¾çš„è¿é€šå—æ•°é‡ä¼šå¢åŠ // å¸¦*è¾¹åŒint n,m,cnt,id,child;int dfn[maxn],low[maxn],isc[maxn];int num[maxn],ans,sum;vector&lt;int&gt;vv[maxn];//* vector&lt;pii&gt;bri;void init()&#123; cnt=id=child=0; rep(i,0,n+1)&#123; vv[i].clear(); dfn[i]=low[i]=isc[i]=0; &#125;&#125;void tarjan(int x,int f)&#123; dfn[x]=low[x]=++id; int ff(0); rep(i,0,vv[x].size())&#123; int tmp=vv[x][i]; if(tmp==f&amp;&amp;!ff)&#123; ff++; continue; &#125; // é‡è¾¹ if(!dfn[tmp])&#123; child++; tarjan(tmp,x); low[x]=min(low[x],low[tmp]); if(low[tmp]&gt;dfn[x])&#123; isc[x]=1; // åˆ¤æ–­è¿™ä¸ªç‚¹æ˜¯å¦ä¸ºå‰²ç‚¹ //* bri.push_back(pii(x,tmp)); &#125; &#125; else if(dfn[tmp]&lt;dfn[x]) low[x]=min(low[x],dfn[tmp]); &#125; if(f==-1&amp;&amp;child==1) isc[x]=0; // å…³äºæ ¹èŠ‚ç‚¹çš„ç‰¹åˆ¤ // å¸¦ç¼©ç‚¹ if(dfn[x]==low[x])&#123; scc++; do...while...; &#125;&#125;void slove()&#123; rep(i,1,n+1) if(!dfn[i]) tarjan(i,-1);&#125; LCA123456789101112131415161718192021222324252627282930313233343536373839int n,m,tot,best[20][maxn&lt;&lt;1];int dis[maxn],vis[maxn],head[maxn];int nex[maxn&lt;&lt;1],to[maxn&lt;&lt;1],val[maxn&lt;&lt;1];int id[maxn&lt;&lt;1],num[maxn],dep[maxn&lt;&lt;1],cnt;void addedge(int u,int v,int w)&#123; nex[++tot]=head[u]; head[u]=tot; to[tot]=v; val[tot]=w;&#125;void dfs(int x,int f,int d)&#123; id[++cnt]=x; num[x]=cnt; dep[cnt]=d; for(int i=head[x];i;i=nex[i])&#123; int y=to[i],z=val[i]; if(y==f) continue; dis[y]=dis[x]+z; dfs(y,x,d+1); id[++cnt]=x; dep[cnt]=d; &#125;&#125;void ST(int n)&#123; int lg=(int)(log(n*1.0)/log(2.0)); rep(i,1,n+1) best[0][i]=i; rep(i,1,lg+1) for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++)&#123; int t1=best[i-1][j],t2=best[i-1][j+(1&lt;&lt;i&gt;&gt;1)]; best[i][j]=dep[t1]&lt;dep[t2]?t1:t2; &#125;&#125;int RMQ(int x,int y)&#123; if(x&gt;y) swap(x,y); int lg=(int)(log(1.0*(y-x+1))/log(2.0)); int t1=best[lg][x],t2=best[lg][y-(1&lt;&lt;lg)+1]; return dep[t1]&lt;dep[t2]?t1:t2;&#125;int LCA(int x,int y)&#123; int t1=num[x],t2=num[y]; return id[RMQ(t1,t2)];&#125;int getdis(int x,int y)&#123; return dis[x]+dis[y]-2*dis[LCA(x,y)];&#125;void slove()&#123; dfs(1,-1,1); ST(2*n-1);&#125; æ•°æ®ç»“æ„å¹¶æŸ¥é›†1234567int find(int x)&#123; return vis[x]==x?x:vis[x]=find(vis[x]);&#125;void change(int x, int y)&#123; int c=find(x),d=find(y); if(c!=d) vis[c]=d;&#125; æ ‘çŠ¶æ•°ç»„12345678910int tree[maxn];int lowbit(int i)&#123; return i&amp;(-i); &#125;void update(int i,int x)&#123; for(;i&lt;=maxn;i+=lowbit(i)) tree[i]+=x;&#125;int query(int n)&#123; int ans=0; for(int i=n;i&gt;0;i-=lowbit(i)) ans+=tree[i]; return ans;&#125; çº¿æ®µæ ‘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// å•ç‚¹æ›´æ–°ï¼ŒåŠ *åŒºé—´æ›´æ–°#define lson (rt&lt;&lt;1)#define rson ((rt&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)int segtree[4*maxn];//* int lazy[4*maxn];void pushup(int rt)&#123; segtree[rt]=segtree[lson]+segtree[rson];&#125;/** void pushdown(int rt,int begin,int end)&#123; if (!lazy[rt]) return; segtree[lson]+=(mid-begin+1)*lazy[rt]; segtree[rson]+=(end-mid)*lazy[rt]; lazy[lson]+=lazy[rt]; lazy[rson]+=lazy[rt]; lazy[rt]=0;&#125;*/void build(int rt,int begin,int end)&#123; //* lazy[rt]=0; if(begin==end)&#123; sc(segtree[rt]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushup(rt);&#125;void update(int rt,int begin,int end,int pos,int a)&#123; if(pos&lt;begin||pos&gt;end) return; if(begin==end)&#123; segtree[rt]+=a; return; &#125; update(lson,begin,mid,pos,a); update(rson,mid+1,end,pos,a); pushup(rt);&#125;/** void update(int rt,int begin,int end,int left,int right,int a)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; segtree[rt]+=(end-begin+1)*a; lazy[rt]+=a; return; &#125; pushdown(rt,begin,end); update(lson,begin,mid,left,right,a); update(rson,mid+1,end,left,right,a); pushup(rt);&#125;*/int slove(int rt,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segtree[rt]; //* pushdown(rt,begin,end); int ans=0; ans+=slove(lson,begin,mid,left,right); ans+=slove(rson,mid+1,end,left,right); return ans;&#125; DPæ•°ä½dp12345678910111213141516171819202122int a[20]; // ä½æ•° ä¸€èˆ¬é¢˜ç›®æœ€å¤§1e18ll dp[20][state];ll dfs(int pos,int pre,/*int state,*/int limit)&#123; // posä½æ•° preä¹‹å‰çŠ¶æ€ ä¸dpæ•°ç»„å¯¹åº” // stateå„ç§æƒ…å†µåŒ…æ‹¬å‰å¯¼é›¶ å…·ä½“çœ‹é¢˜ç›® limitå‰ä¸€ä½é™åˆ¶ if(pos==-1) return 1; // è®¡æ•°ï¼Œå…·ä½“çœ‹é¢˜ç›® if(!limit&amp;&amp;dp[pos][pre]!=-1/*&amp;&amp;!state*/) return dp[pos][pre]; int last=limit?a[pos]:9; ll ans=0; rep(i,0,last+1)&#123; if(...) ans+=dfs(pos-1,...,/*...,*/limit&amp;&amp;i==a[pos]); else(...) &#125; if(!limit/*&amp;&amp;!state*/) dp[pos][pre]=ans; return ans;&#125;ll slove(ll x)&#123; mst(dp,-1); // å¤šç»„æ•°æ®åªç”¨æœ€å¼€å§‹mstä¸€æ¬¡ å› ä¸ºä¿è¯è¾¹ç•Œå°±å¯ä»¥äº† int pos=0; while(x)&#123; a[pos++]=x%10; x/=10; &#125; return dfs(pos-1,0,/*...,*/1);&#125; æ•°å­¦å¸¸è§å…¬å¼12// 1-nçš„å¹³æ–¹å’Œ n*(n+1)*(2*n+1)/6// 1-nçš„ç«‹æ–¹å’Œ n*n*(n+1)*(n+1)/4 å¿«é€Ÿå¹‚12345678910111213ll qpow(ll a,ll b)&#123; ll ans=1; for(;b&gt;0;b&gt;&gt;=1)&#123; if(b&amp;1) ans=ans*a%mod; a=a*a%mod; &#125; return ans;&#125;// åè¿›åˆ¶ksm å¤§æ•°å¹‚æ¬¡ll qpow(ll a,char* s)&#123; int len=strlen(s); ll res=1,q=1; dep(i,len-1,0)&#123; rep(j,1,s[i]-&#x27;0&#x27;+1) res=res*a%mod; a=a*a%mod; q=a*a%mod; q=q*q%mod; a=q*a%mod; &#125; return res;&#125; å¿«é€Ÿä¹˜123456789101112131415ll qmul(ll a,ll b,ll p)&#123; a%=p; ll ans(0); while(b&gt;0)&#123; if(b&amp;1) ans+=a; if(ans&gt;=p) ans-=p; b&gt;&gt;=1; a+=a; if(a&gt;=p) a-=p; &#125; return ans;&#125; // ologll modMul(ll a,ll b,ll p)&#123; if(p&lt;=1000000000) return a*b%p; else if(p&lt;=1000000000000ll) return (((a*(b&gt;&gt;20)%p)&lt;&lt;20)+(a*(b&amp;((1&lt;&lt;20)-1))))%p; else&#123; ll d=(ll)floor(a*(long double)b/p+0.5); ll ret=(a*b-d*p)%p; if (ret&lt;0) ret+=p; return ret; &#125;&#125; // o1 æ¨¡é€†å…ƒ12345678910111213// exgcdvoid exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1; y=0; return; &#125; exgcd(b,a%b,y,x); y-=(a/b)*x; return;&#125;ll inv(ll a,ll p)&#123; ll x,y; exgcd(a,p,x,y); return (x%p+p)%p;&#125; // å¥½åƒæ¯”ksmå¿«çš„// qpowinv=qpow(a,mod-2,mod);// é€’æ¨inv[i]=(mod-mod/i)*inv[mod%i]%mod; ç»„åˆæ•°12345678910111213141516// é¢„å¤„ç†å†™æ³•int jc[maxn],inv[maxn];void init()&#123; jc[0]=inv[0]=1; rep(i,1,maxn) jc[i]=1ll*jc[i-1]*i%mod; inv[maxn-1]=qpow(jc[maxn-1],mod-2,mod); dep(i,maxn-2,1) inv[i]=1ll*inv[i+1]*(i+1)%mod;&#125;int C(int s,int x)&#123; return 1ll*jc[x]*inv[s]%mod*inv[x-s]%mod;&#125;// lucasll Lucas(ll n,ll m,ll p)&#123; ll ans=1; while(n|m) ans=ans*C(n%p,m%p)%p,n/=p,m/=p; return ans;&#125; ç´ æ•°åˆ¤æ–­12345678910111213141516171819202122232425262728bool isPrime(ll n)&#123; if(n==2||n==3||n==5) return 1; if(n%2==0||n%3==0||n%5==0||n==1) return 0; ll c=7,a[8]=&#123;4,2,4,2,4,6,2,6&#125;; while(c*c&lt;=n) for(auto i:a)&#123; if(n%c==0) return 0; c+=i; &#125; return 1;&#125; // æŠ // næå¤§æ—¶ç´ æ•°æµ‹è¯•ç®—æ³•ll Rand()&#123; static ll x=(srand((int)time(0)),rand()); x+=1000003; if(x&gt;mod) x-=mod; return x;&#125;bool Witness(ll a,ll n)&#123; ll t=0,u=n-1; while(!(u&amp;1)) u&gt;&gt;=1,t++; ll x=fpow(a,u,n),y; while(t--)&#123; y=x*x%n; if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1) return true; x=y; &#125; return x!=1;&#125;bool MillerRabin(ll n,ll s)&#123; if(n==2||n==3||n==5) return 1; if(n%2==0||n%3==0||n%5==0||n==1) return 0; while(s--) if(Witness(Rand()%(n-1)+1,n)) return false; return true;&#125; æ±‚æœ€å°ç´ å› æ•°123456789int p[maxn/3],mpf[maxn],pn;void init()&#123; int tmp; rep(i,2,maxn)&#123; if(!mpf[i]) p[pn++]=i,mpf[i]=i; for(int j=0;(tmp=i*p[j])&lt;maxn;j++)&#123; mpf[tmp]=p[j]; if(!(i%p[j])) break; &#125; &#125;&#125; Pollardâ€™s rho123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// å¯¹äºæ¯”è¾ƒå¤§çš„æ•°åˆ†è§£å› æ•°typedef pair&lt;ll,int&gt; pli;namespace pollard_rho&#123; const int C=2307; const int S=10; mt19937 rd(time(0)); vector&lt;ll&gt;ve; ll gcd(ll a,ll b)&#123; while((a%=b)&amp;&amp;(b%=a)); return a+b; &#125; ll mul(ll a,ll b,ll mod)&#123; return (__int128)a*b%mod; &#125; ll qpow(ll a,ll b,ll mod)&#123; ll res=1; a%=mod; while(b&gt;0)&#123; if(b&amp;1) res=mul(res,a,mod); b&gt;&gt;=1; a=mul(a,a,mod); &#125; return res; &#125; bool check(ll a,ll n)&#123; ll m=n-1,x,y; int j=0; while(!(m&amp;1))m&gt;&gt;=1,j++; x=qpow(a,m,n); for(int i=1;i&lt;=j;x=y,i++)&#123; y=mul(x,x,n); if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1) return 1; &#125; return y!=1; &#125; bool miller_rabin(ll n)&#123; ll a; if(n==1) return 0; if(n==2) return 1; if(!(n&amp;1)) return 0; for(int i=0;i&lt;S;i++) if(check(rd()%(n-1)+1,n)) return 0; return 1; &#125; ll pollard_rho(ll n,int c)&#123; ll i=1,k=2,x=rd()%n,y=x,d; while(1)&#123; i++; x=(mul(x,x,n)+c)%n,d=gcd(y-x,n); if(d&gt;1&amp;&amp;d&lt;n) return d; if(y==x) return n; if(i==k) y=x,k&lt;&lt;=1; &#125; &#125; void findfac(ll n,int c)&#123; if(n==1) return; if(miller_rabin(n))&#123; ve.push_back(n); return; &#125; ll m=n; while(m==n) m=pollard_rho(n,c--); findfac(m,c); findfac(n/m,c); &#125; vector&lt;pli&gt; solve(ll n)&#123; vector&lt;pli&gt;res; ve.clear(); findfac(n,C); sort(ve.begin(),ve.end()); for(auto x:ve)&#123; if(res.empty()||res.back().first!=x) res.push_back(&#123;x,1&#125;); else res.back().second++; &#125; return res; &#125;&#125; ä¸­å›½å‰©ä½™å®šç†123456789101112131415161718192021ll a[maxn],r[maxn];ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1; y=0; return a; &#125; else&#123; ll ans=exgcd(b,a%b,y,x); y-=(a/b)*x; return ans; &#125;&#125;int excrt()&#123; ll m1,r1,m2,r2; ll x,y,t,c,d; m1=a[0],r1=r[0]; rep(i,1,tot)&#123; m2=a[i],r2=r[i]; c=r2-r1; d=exgcd(m1,m2,x,y); if(c%d) return puts(&quot;-1&quot;); t=m2/d; x*=c/d; x=(x%t+t)%t; r1=x*m1+r1; m1=m1*m2/d; r1=(r1%m1+m1)%m1; &#125; return pf(&quot;%d\\n&quot;,r1);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// å¤§æ•°ç‰ˆimport java.math.*;import java.util.*;public class Main &#123; public static BigInteger[] exgcd(BigInteger a,BigInteger b)&#123; BigInteger ans; BigInteger[] result=new BigInteger[3]; if(b.compareTo(BigInteger.ZERO)==0)&#123; result[0]=a; result[1]=BigInteger.ONE; result[2]=BigInteger.ZERO; return result; &#125; BigInteger[] tmp=exgcd(b,a.mod(b)); ans=tmp[0]; result[0]=ans; result[1]=tmp[2]; result[2]=tmp[1].subtract((a.divide(b).multiply(tmp[2]))); return result; &#125; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); BigInteger a[]=new BigInteger[105]; BigInteger r[]=new BigInteger[105]; int n; n=sc.nextInt(); for(int i=0;i&lt;n;i++)&#123; a[i]=sc.nextBigInteger(); r[i]=sc.nextBigInteger(); &#125; BigInteger m1,m2,r1,r2,t,c; BigInteger[] d; m1=a[0]; r1=r[0]; for(int i=1;i&lt;n;i++)&#123; m2=a[i]; r2=r[i]; c=r2.subtract(r1); d=exgcd(m1,m2); if(c.mod(d[0]).compareTo(BigInteger.ZERO)!=0)&#123; System.out.println(&quot;-1&quot;); return; &#125; t=m2.divide(d[0]); d[1]=d[1].multiply(c.divide(d[0])).mod(t); r1=d[1].multiply(m1).add(r1); m1=m1.multiply(t); r1=r1.mod(m1); &#125; d=exgcd(BigInteger.ONE,m1); if(r1.mod(d[0]).compareTo(BigInteger.ZERO)!=0)&#123; System.out.println(&quot;-1&quot;); return; &#125; t=m1.divide(d[0]); d[1]=d[1].multiply(r1.divide(d[0])).mod(t); System.out.println(d[1]); &#125;&#125; (ex)bsgs1234567891011121314// æ±‚è§£a^x=b(mod p)ll bsgs(ll a,ll b,ll p)&#123; unordered_map&lt;ll,ll&gt;tab; tab.clear(); ll u=(ll)ceil(sqrt(p)),ans; rep(i,0,u+1)&#123; if(!i) ans=b%p,tab[ans]=i; else ans=ans*a%p,tab[ans]=i; &#125; ll sum=qpow(a,u,p); ans=1; if(!sum) return b?-1:1; rep(i,1,u+1)&#123; ans=ans*sum%p; if(tab[ans]) return u*i-tab[ans]; &#125; return -1;&#125; æ‰“è¡¨ç´ æ•°åŠè«æ¯”ä¹Œæ–¯å‡½æ•° 1234567891011int p[maxn],u[maxn],vis[maxn],pn;void init()&#123; u[1]=1; rep(i,2,maxn)&#123; if(!vis[i]) p[pn++]=i,u[i]=-1; for(int j=0;j&lt;pn&amp;&amp;i*p[j]&lt;maxn;j++)&#123; vis[i*p[j]]=1; if(i%p[j]) u[i*p[j]]=-u[i]; else &#123; u[i*p[j]]=0; break; &#125; &#125; &#125;&#125; åç´ æ•°123456789101112int n,p[]=&#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53&#125;;ll ans=1e18; // nä¸ªå› æ•°void dfs(int pos,ll v,int num)&#123; if(num&gt;n||pos&gt;15) return; if(num==n) return ans=min(ans,v),(void)0; for(int i=1;i&lt;64;i++)&#123; if(v&gt;ans/p[pos]||num*(i+1)&gt;n) break; v*=p[pos]; if(!(n%(num*(i+1)))) dfs(pos+1,v,num*(i+1)); &#125;&#125;void slove()&#123; dfs(0,1,1); &#125;// ansæ˜¯å› æ•°æœ‰nä¸ªçš„æœ€å°æ­£æ•´æ•° æ¬§æ‹‰å‡½æ•°12345678910ll getphi(ll x)&#123; ll res=x; rep(i,2,x+1)&#123; if(1ll*i*i&gt;x) break; if(x%i==0)&#123; res=res/i*(i-1); while(x%i==0) x/=i; &#125; &#125; if(x&gt;1) res=res/x*(x-1); return res;&#125; æ¬§æ‹‰é™å¹‚1234// æ±‚qpow(a,b,p)æœ‰if(__gcd(a,p)==1) ans=qpow(a,b%phi(p),p);else if(__gcd(a,p)&gt;1&amp;&amp;b&lt;phi(p)) ans==qpow(a,b,p);else ans=qpow(a,b%phi(p)+phi(p),p); BM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657namespace linear_seq&#123; const int N=101100; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt;Md; void mul(ll *a,ll *b,int k)&#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if(_c[i]) rep(j,0,Md.size()) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int slove(ll n,vector&lt;int&gt; a,vector&lt;int&gt; b)&#123; // aç³»æ•° båˆå€¼ b[n+1]=a[0]*b[n]+... ll ans=0,pnt=0; int k=a.size(); assert((int)a.size()==(int)b.size()); Md.clear(); rep(i,0,k) _md[k-1-i]=-a[i]; _md[k]=1; rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while((1ll&lt;&lt;pnt)&lt;=n) pnt++; dep(p,pnt,0)&#123; mul(res,res,k); if((n&gt;&gt;p)&amp;1)&#123; dep(i,k-1,0) res[i+1]=res[i];res[0]=0; rep(j,0,Md.size()) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if(ans&lt;0) ans+=mod; return ans; &#125; vector&lt;int&gt; BM(vector&lt;int&gt; s)&#123; vector&lt;int&gt; C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,s.size())&#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if(d==0) ++m; else if(2*L&lt;=n)&#123; vector&lt;int&gt; T=C; ll c=mod-d*qpow(b,mod-2)%mod; while((int)C.size()&lt;(int)B.size()+m) C.push_back(0); rep(i,0,B.size()) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else&#123; ll c=mod-d*qpow(b,mod-2)%mod; while((int)C.size()&lt;(int)B.size()+m) C.push_back(0); rep(i,0,B.size()) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int qaq(vector&lt;int&gt; a,ll n)&#123; vector&lt;int&gt; c=BM(a); c.erase(c.begin()); rep(i,0,c.size()) c[i]=(mod-c[i])%mod; return slove(n,c,vector&lt;int&gt;(a.begin(),a.begin()+(int)c.size())); &#125;&#125;;int slove()&#123; vector&lt;int&gt;vv; ll tmp(0); rep(i,1,maxn)&#123; tmp=...; vv.push_back(tmp); &#125; ll ans=linear_seq::qaq(vv,n-1); return printf(&quot;%lld\\n&quot;,ans);&#125; äºŒæ¬¡å‰©ä½™12345678910111213141516171819202122bool judge(ll a,ll p)&#123; // åˆ¤æ–­aæ˜¯å¦ä¸ºpçš„äºŒæ¬¡å‰©ä½™ pæ˜¯ç´ æ•° return qpow(a,(p-1)&gt;&gt;1,p)==1;&#125;ll Shanks(ll a,ll p)&#123; // æ±‚è§£äºŒæ¬¡åŒä½™æ–¹ç¨‹x^2=a(mod p) pæ˜¯ç´ æ•° if(a==0) return 0; ll q=p-1,e=0; while(!(q&amp;1)) q&gt;&gt;=1,e++; static mt19937_64 rd(time(0)); ll n=rd()%(p-1)+1; // éšæœºé€‰å–pçš„ä¸€ä¸ªéäºŒæ¬¡å‰©ä½™ï¼Œè‹¥pä¸ºå®šå€¼ï¼Œnä¹Ÿå¯ä¸ºå®šå€¼ while(judge(n,p)) n=rd()%(p-1)+1; ll z=qpow(n,q,p),y=z,r=e,x=qpow(a,(q-1)&gt;&gt;1,p),b=a*x%p*x%p; x=a*x%p; while(b!=1)&#123; ll temp=b*b%p,m=1; while(temp!=1) (temp*=temp)%=p,m++; if(m==r) return -1; ll t=y; rep(i,1,r-m-1)(t*=t)%=p; y=t*t%p,r=m%p,x=x*t%p,b=b*y%p; &#125; return x;&#125; fft123456789101112131415161718192021222324252627282930313233typedef complex&lt;double&gt; cd;const double PI = acos(-1.0);void change(cd* f,int n)&#123; int j=n&gt;&gt;1; rep(i,1,n-1)&#123; if(i&lt;j) swap(f[i],f[j]); int k=n&gt;&gt;1; while(j&gt;=k)&#123; j-=k; k&gt;&gt;=1; &#125; if(j&lt;k) j+=k; &#125;&#125;void fft(cd* f,int n,int dft)&#123; // nä¸ºå¤šé¡¹å¼ä½æ•° change(f,n); for(int step=1;step&lt;n;step&lt;&lt;=1)&#123; // åˆå¹¶ cd wn=exp(cd(0,dft*PI/step)); for(int j=0;j&lt;n;j+=step&lt;&lt;1)&#123; cd wnk(1,0); for(int k=j;k&lt;j+step;k++)&#123; cd x=f[k],y=wnk*f[k+step]; f[k]=x+y; // F(x)=G(x)+Ï‰H(x) f[k+step]=x-y; wnk*=wn; &#125; &#125; &#125; if(dft==-1) rep(i,0,n) f[i]/=n; // IDFTéœ€è¦æ•´ä¸ªçŸ©é˜µçš„å†…å®¹ä¹˜ä¸Š1/n &#125;cd a[maxn],b[maxn]; int ans[maxn];void slove()&#123; int mx=...,L=1; while(L&lt;mx*2) L&lt;&lt;=1; mst(ans,0); fft(a,L,1); fft(b,L,1); rep(i,0,L) a[i]=a[i]*b[i]; fft(a,L,-1); rep(i,0,L) ans[i]=(int)(a[i].real()+0.5);&#125; fwt123456789101112131415161718192021222324void fwt_or(int *a,int op)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;++k) if(op==1) a[i+j+k]=(a[j+k]+a[i+j+k])%mod; else a[i+j+k]=(a[i+j+K]-a[j+K]+mod)%mod;&#125; void fwt_and(int *a,int op)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;++k) if(op==1) a[j+k]=(a[j+k]+a[i+j+k])%mod; else a[j+k]=(a[j+K]-a[i+j+K]+mod)%mod;&#125; void fwt_xor(int *a,int op)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;++k)&#123; int x=a[j+k],y=a[i+j+k]; a[j+k]=(x+y)%mod,a[i+j+k]=(x-y+mod)%mod; if(op==-1) a[j+k]=1ll*a[j+k]*inv2%mod, a[i+j+k]=1ll*a[i+j+k]*inv2%mod; &#125;&#125; æ‹‰æ ¼æœ—æ—¥æ’å€¼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465namespace polysum&#123; const int D = 1e5 + 5; ll a[D],f[D],g[D],p1[D],p2[D],b[D],h[D][2],C[D]; ll qpow(ll a,ll b)&#123; ll ans=1; for(;b;b&gt;&gt;=1)&#123; if(b&amp;1) ans=ans*a%mod; a=a*a%mod; &#125; return ans; &#125; void init(int M)&#123; f[0]=f[1]=g[0]=g[1]=1; rep(i,2,M+5) f[i]=f[i-1]*i%mod; g[M+4]=qpow(f[M+4],mod-2); dep(i,M+3,2) g[i]=g[i+1]*(i+1)%mod; &#125; // å·²çŸ¥f(0),f(1)..f(d) æ±‚ f(n) ll calcn(ll d,ll *a,ll n)&#123; // a[0].. a[d] a[n] if(n&lt;=d) return a[n]; p1[0]=p2[0]=1; rep(i,0,d+1)&#123; ll t=(n-i+mod)%mod; p1[i+1]=p1[i]*t%mod; &#125; rep(i,0,d+1)&#123; ll t=(n-d+i+mod)%mod; p2[i+1]=p2[i]*t%mod; &#125; ll ans(0); rep(i,0,d+1)&#123; ll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod; if((d-i)&amp;1) ans=(ans-t+mod)%mod; else ans=(ans+t)%mod; &#125; return ans; &#125; // å·²çŸ¥ f(0),f(1)...f(m),æ±‚\\sum_&#123;i=0 &#125;^&#123;n&#125; f[i] ll polysum(ll m,ll *a,ll n)&#123; // a[0].. a[m] ll b[D]; rep(i,0,m+1) b[i]=a[i]; b[m+1]=calcn(m,b,m+1); rep(i,1,m+2) b[i]=(b[i-1]+b[i])%mod; return calcn(m+1,b,n-1); &#125; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i ll qpolysum(ll R,ll n,ll *a,ll m) &#123; if(R==1) return polysum(n,a,m); a[m+1]=calcn(m,a,m+1); ll r=qpow(R,mod-2),p3=0,p4=0,c,ans; h[0][0]=0; h[0][1]=1; rep(i,1,m+2)&#123; h[i][0]=(h[i-1][0]+a[i-1])*r%mod; h[i][1]=h[i-1][1]*r%mod; &#125; rep(i,0,m+2)&#123; ll t=g[i]*g[m+1-i]%mod; if(i&amp;1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod; else p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod; &#125; c=qpow(p4,mod-2)*(mod-p3)%mod; rep(i,0,m+2) h[i][0]=(h[i][0]+h[i][1]*c)%mod; rep(i,0,m+2) C[i]=h[i][0]; ans=(calcn(m,C,n)*qpow(R,n)%mod-c)%mod; if(ans&lt;0) ans+=mod; return ans; &#125;&#125; åšå¼ˆ1234567891011121314151617181920212223242526272829/* å·´ä»€åšå¼ˆï¼šä¸€å †ç‰©å“nä¸¤äººè½®æµå–ç‰©ï¼Œä¸€æ¬¡æœ€å¤šmæ ¹æ®n%(m+1)æ˜¯å¦ä¸ºé›¶åˆ¤æ–­èƒœè€… *//* å¨ä½å¤«åšå¥•ï¼šä¸¤å †ç‰©å“aã€bä¸¤äººè½®æµå–ç‰©ï¼Œä¸€æ¬¡åªèƒ½åœ¨ä¸€å †ä»»æ„å–æˆ–æ˜¯ä¸¤å †å–åŒæ ·å¤š //é»˜è®¤a&lt;bæ ¹æ®(int)((double)(1.0+sqrt(4.0))/2.0)*(b-a))æ˜¯å¦ç­‰äºaåˆ¤æ–­èƒœè€…æ‰©å±•å¨ä½å¤«åšå¼ˆï¼šä¸¤å †ç‰©å“aã€bä¸¤äººè½®æµå–ç‰©ï¼Œä¸€æ¬¡åªèƒ½åœ¨ä¸€å †ä»»æ„å–æˆ–æ˜¯ä¸¤å †å–ç›¸å·®ä¸è¶…è¿‡kçš„ //é»˜è®¤a&lt;b */if(a&gt;b) swap(a,b);if(a==1) return puts(b==k+2?&quot;0&quot;:&quot;1&quot;);if(a==k+2||b==k+2) return puts(&quot;1&quot;);ll r=(b-a)%(k+1); if(r) return puts(&quot;1&quot;);double t=(1.0-k+sqrt(1ll*(k+1)*(k+1)+4.0))/2.0;ll q=(b-a)/(k+1); q=(ll)q*t;return puts(q==a?&quot;0&quot;:&quot;1&quot;);/* Fibonacciåšå¼ˆï¼šä¸€å †ç‰©å“nï¼Œä¸¤äººè½®æµå–ç‰©ï¼Œæ¯ä¸€æ¬¡èƒ½å–çš„ä¸ªæ•°æ˜¯ä¸Šä¸€æ¬¡çš„ä¸¤å€ä»¥å†…ï¼Œæœ€åå–å®Œèƒœnä¸ºFibonacciæ•°æ—¶å…ˆæ‰‹è´¥ */// kå€åŠ¨æ€å‡æ³•// ä¸€å †çŸ³å¤´ ç¬¬ä¸€æ­¥å¯ä»¥æ‹¿1~n-1ä¸ªçŸ³å¤´ ä¹‹åæ¯æ­¥æœ€å¤šæ‹¿ä¸Šä¸€æ­¥çš„kå€int a[maxn],b[maxn];int slove()&#123; int n,k; sc(n); sc(k); a[0]=b[0]=1; int i=0,j=0; while(n&gt;a[i])&#123; i++; a[i]=b[i-1]+1; while(a[j+1]*k&lt;a[i]) j++; if(a[j]*k&lt;a[i]) b[i]=b[j]+a[i]; else b[i]=a[i]; &#125; if(a[i]==n) return puts(&quot;lose&quot;); // å…ˆæ‰‹è´¥ int ans; while(n)&#123; if(n&gt;=a[i]) n-=a[i],ans=a[i]; i--; &#125; return pf(&quot;%d\\n&quot;,ans); // ç¬¬ä¸€æ­¥æ‰€æ‹¿æœ€å°‘æ•°&#125; æ–æ³¢é‚£å¥‘æ±‚å¾ªç¯èŠ‚1234567/*ç»™å®šä¸€ä¸ªæ•°n æ±‚%nçš„æ–æ³¢é‚£å¥‘å¾ªåèŠ‚é•¿åº¦lenÂ·nä¸ºè´¨æ•°ä¸”5æ˜¯æ¨¡nçš„äºŒæ¬¡å‰©ä½™ lenä¸º(n-1)çš„å› å­Â·nä¸ºè´¨æ•°ä¸”5ä¸ä¸ºæ¨¡nçš„äºŒæ¬¡å‰©ä½™ lenä¸º(2n+2)çš„å› å­Â·nä¸ºè´¨æ•°pçš„kæ¬¡ lenä¸ºlenp*p^(k-1)Â·nåˆ†è§£ä¸ºè´¨å› æ•° lenä¸ºæ¯ä¸ªè´¨å› æ•°å¾ªç¯èŠ‚é•¿åº¦çš„lcm*/ è®¡ç®—å‡ ä½•äºŒç»´å‡ ä½•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// ä¸€èˆ¬å½¢å¼// ç›´çº¿Lä¸Šä¸¤ç‚¹(x1,y1),(x2,y2);// ç›´çº¿å¤–ä¸€ç‚¹P(x0,y0);// Lè¡¨ç¤ºä¸ºAx+By+C=0;double A,B,C;A=y2-y1; B=x1-x2; C=x2*y1-x1*y2;// ç‚¹åˆ°ç›´çº¿è·ç¦»ddouble d=fabs(A*x0+B*y0+C)/sqrt(A*A+B*B);// ç‚¹åˆ°ç›´çº¿å‚è¶³H(x, y)double x,y;x=(B*B*x0-A*B*y0-A*C)/(A*A+B*B);y=(-A*B*x0+A*A*y0-B*C)/(A*A+B*B);// ç‚¹å…³äºç›´çº¿çš„å¯¹ç§°ç‚¹P&#x27;(_x, _y);double k,_x,_y;k=-2*(A*x0+B*y0+C)/(A*A+B*B); _x=x0+k*A; _y=y0+k*B;// æ±‚ä¸‰è§’å½¢å†…æ•´æ•°ç‚¹ä¸ªæ•°// ä¸‰è§’å½¢ä¸‰ä¸ªé¡¶ç‚¹åæ ‡(x1, y1), (x2, y2), (x3, y3) éƒ½ä¸ºæ•´æ•°ç‚¹int t1,t2,t3; // ä¸‰è¾¹ä¸Šæ•´æ•°ç‚¹ä¸ªæ•°t1=gcd(abs(x1-x2),abs(y1-y2));t2=gcd(abs(x3-x2),abs(y3-y2));t3=gcd(abs(x1-x3),abs(y1-y3));int num; // ä¸‰è§’å½¢å†…æ•´æ•°ç‚¹num=abs((x2-x1)*(y3-y2)-(x3-x2)*(y2-y1))/2;num-=(t1+t2+t3)/2-1; // çš®å…‹å®šç†// ä¸€ä¸ªæ ¼ç‚¹å¤šè¾¹å½¢æœ‰ S=a+b/2-1;// Sé¢ç§¯ aå†…éƒ¨æ ¼ç‚¹æ•° bè¾¹ä¸Šæ ¼ç‚¹æ•°// ç»“æ„ä½“å½¢å¼struct point&#123; double x,y; point(double _x=0,double _y=0)&#123; x=_x,y=_y; &#125; point operator+ (const point&amp; a) const&#123; return point(x+a.x,y+a.y); &#125; point operator- (const point&amp; a) const&#123; return point(x-a.x,y-a.y); &#125; point operator* (double a) const&#123; return point(x*a,y*a); &#125;&#125;; // ç‚¹struct line&#123; point s,e; line(point a,point b)&#123; s=a,e=b; &#125; line()&#123;&#125;&#125;; // çº¿int dcmp(double x)&#123; if(x&gt;eps) return 1; return x&lt;-eps?-1:0;&#125;double getdis(point a, point b)&#123; double xx=a.x-b.x,yy=a.y-b.y; return sqrt(xx*xx+yy*yy);&#125; // ä¸¤ç‚¹è·ç¦»double multi(point a,point b,point c)&#123; double xa,ya,xb,yb; xa=b.x-a.x; ya=b.y-a.y; xb=c.x-b.x; yb=c.y-b.y; return xa*xb+ya*yb;&#125; // ç‚¹ä¹˜double cross(point a,point b,point c)&#123; double xa,ya,xb,yb; xa=b.x-a.x; ya=b.y-a.y; xb=c.x-a.x; yb=c.y-a.y; return xa*yb-xb*ya;&#125; // å‰ä¹˜int judgec(line a,line b)&#123; if (max(a.s.x,a.e.x)&gt;=min(b.s.x,b.e.x) &amp;&amp; max(a.s.y,a.e.y)&gt;=min(b.s.y,b.e.y) &amp;&amp; max(b.s.x,b.e.x)&gt;=min(a.s.x,a.e.x) &amp;&amp; max(b.s.y,b.e.y)&gt;=min(a.s.y,a.e.y) &amp;&amp; cross(a.s,b.s,b.e)*cross(a.e,b.s,b.e)&lt;=0 &amp;&amp; cross(b.s,a.s,a.e)*cross(b.e,a.s,a.e)&lt;=0 ) return 1; else return 0;&#125; // åˆ¤æ–­çº¿æ®µæ˜¯å¦ç›¸äº¤point getpoi(point a,point b,point c,point d)&#123; double u=cross(a,b,c),v=cross(b,a,d); return point((c.x*v+d.x*u)/(u+v),(c.y*v+d.y*u)/(u+v));&#125; // æ±‚äº¤ç‚¹double parea(point p[],int n)&#123; if(n&lt;3) return 0; double ans=0; p[n]=p[0]; rep(i,0,n) ans+=p[i].x*p[i+1].y-p[i+1].x*p[i].y; return ans/2;&#125; // å¤šè¾¹å½¢é¢ç§¯// æ±‚ä¸¤ä¸ªå¤šè¾¹å½¢é¢ç§¯äº¤/å¹¶double CPIA(point a[],point b[],int n1,int n2)&#123; if(n2&lt;3) return 0; point p[15],t[15]; a[n1]=a[0]; b[n2]=b[0]; memcpy(p,b,sizeof(point)*(n2+1)); rep(i,0,n1)&#123; int f1=dcmp(cross(a[i],a[i+1],p[0])),tn=0; rep(j,0,n2)&#123; if(f1&gt;=0) t[tn++]=p[j]; int f2=dcmp(cross(a[i],a[i+1],p[j+1])); if((f1^f2)==-2) t[tn++]=getpoi(a[i],a[i+1],p[j],p[j+1]); f1=f2; &#125; memcpy(p,t,sizeof(point)*tn); n2=tn; p[n2]=p[0]; &#125; return parea(p,n2);&#125;double SPIA(point a[],point b[],int n1,int n2)&#123; point t1[5],t2[5]; a[n1]=t1[0]=a[0]; b[n2]=t2[0]=b[0]; double res=0; rep(i,2,n1)&#123; t1[1]=a[i-1]; t1[2]=a[i]; int f1=dcmp(cross(t1[0],t1[1],t1[2])); if(f1&lt;0) swap(t1[1],t1[2]); rep(j,2,n2)&#123; t2[1]=b[j-1]; t2[2]=b[j]; int f2=dcmp(cross(t2[0],t2[1],t2[2])); if(f2&lt;0) swap(t2[1],t2[2]); res+=CPIA(t1,t2,3,3)*f1*f2; &#125; &#125; return fabs(res); //é¢ç§¯äº¤ //return fabs(parea(a,n1)+parea(b,n2)-res); //é¢ç§¯å¹¶ &#125;double gx, gy;void find_gra()&#123; double area=0,tmp; rep(i,1,n-1)&#123; tmp=(p[i].x-p[0].x)*(p[i+1].y-p[0].y)-(p[i+1].x-p[0].x)*(p[i].y-p[0].y); area+=tmp; gx+=(p[0].x+p[i].x+p[i+1].x)*tmp; gy+=(p[0].y+p[i].y+p[i+1].y)*tmp; &#125; gx=gx/3/area, gy=gy/3/area;&#125; // æ±‚é‡å¿ƒåæ ‡ äºŒç»´å‡¸åŒ…12345678910111213141516171819// ä»¥ä¸‹å‡¸åŒ…Grahamint top;point p[maxn],s[maxn];int iszero(double x)&#123; return fabs(x)&lt;eps; &#125;int cmp(point a,point b)&#123; double tt=multi(a,b,p[0]); if(tt&gt;0||iszero(tt)&amp;&amp;getdis(a,p[0])&lt;getdis(b,p[0])) return 1; return 0;&#125;void graham() &#123; point tmp; rep(i,1,n) if(p[i].y&lt;p[0].y||(p[i].y==p[0].y&amp;&amp;p[i].x&lt;p[0].x)) swap(p[0],p[i]); sort(p+1,p+n,cmp); s[0]=p[0]; s[1]=p[1]; s[2]=p[2]; top=2; rep(i,3,n)&#123; while(top&gt;=2&amp;&amp;multi(s[top-1],s[top],p[i])&lt;=eps) top--; s[++top]=p[i]; &#125;&#125; Javaå¿«è¯»123456789101112131415161718192021222324252627282930import java.io.*;public class Main &#123; public static void main(String[] args) throws IOException &#123; // è¿™å¥æ˜¯ioæµåŒ…è£…ï¼Œè®°ä½å°±å¥½ StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); /*in.resetSyntax(); in.whitespaceChars(0, 32); in.wordChars(&#x27;0&#x27;, &#x27;9&#x27;); in.wordChars(&#x27;-&#x27;, &#x27;.&#x27;); in.wordChars(&#x27;+&#x27;, &#x27;+&#x27;); in.wordChars(&#x27;a&#x27;, &#x27;z&#x27;); in.wordChars(&#x27;A&#x27;, &#x27;Z&#x27;); in.wordChars(0xa0, 0xff); in.slashSlashComments(true); in.slashStarComments(true); in.quoteChar(&#x27;&quot;&#x27;); in.quoteChar(&#x27;\\&#x27;&#x27;);*/ // ä»¥ä¸ŠåŠ ä¸Šå¯ä»¥å°†æ•°å­—å½“å­—ç¬¦ä¸²è¯» // StreamTokenizer.TT_EOFè¿™ä¸ªæ˜¯ä¸ªå‚æ•°ï¼Œå°±æ˜¯EOF while (in.nextToken() != StreamTokenizer.TT_EOF) &#123; String n = in.sval; in.nextToken(); // æ²¡è®°é”™æ˜¯æ¢è¡Œ double m = in.nval; int a = (int) in.nval; out.println(m); out.flush(); // åˆ·æ–°ï¼Œä¸ç„¶maxä¼šç•™åœ¨ç¼“å†²åŒº &#125; &#125;&#125; é«˜ç²¾åº¦123456789101112131415161718import java.math.*;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); // æ™®é€šè¯»å…¥ while(sc.hasNext())&#123; // å¤§æ•°å¸¸è§å‡½æ•° BigInteger.valueOf(); // intè½¬å¤§æ•° BigInteger a = new BigInteger(/*val:*/&quot;&quot;); BigInteger b = new BigInteger(/*String*/); BigInteger array[]=new BigInteger[maxn]; add(); subtract(); multiply(); divide(); compareTo(); mod(); pow(); gcd(); // ç†è®ºä¸Šå¤§éƒ¨åˆ†æœ‰è¡¥å…¨çš„ System.out.println(a.stripTrailingZeros().toPlainString()); // å®æ•°çš„è¾“å‡ºå»é™¤æœ«å°¾0 Arrays.sort(a,0,n); // æ•°ç»„æ’åº &#125; &#125;&#125; å…¶ä»–å„ç§å‡½æ•°12345is_sorted(a+l,a+r); // åˆ¤æ–­æ•°ç»„aåœ¨åŒºé—´æ˜¯å¦æœ‰åº__builtin_popcount(x); // è®¡ç®—äºŒè¿›åˆ¶xæœ‰å‡ ä¸ª1__builtin_popcountll(x); // llæ¨¡å¼ æœ«å°¾åŠ ä¸ªllprev_permutation(iterator strat,iterator end);next_permutation(iterator strat,iterator end); pbds1234567891011121314151617181920212223// å¹³è¡¡æ ‘#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/tree_policy.hpp&gt;using namespace __gnu_pbds;tree&lt;/*int*/,null_type,greater&lt;/*int*/&gt;,rb_tree_tag,tree_order_statistics_node_update&gt; T;// ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æ•°æ®ç±»å‹// ç¬¬äºŒä¸ªè¦å¡«null_typeï¼Œä½ç‰ˆæœ¬ç¼–è¯‘å™¨å¡«null_mapped_type// ç¬¬ä¸‰ä¸ªå¡«æ¯”è¾ƒå‡½æ•° std::greater&lt;&gt; or std::less&lt;&gt; or cmp// ç¬¬å››ä¸ªå¡«æ ‘çš„ç±»å‹ï¼Œæœ‰rb_tree_tagçº¢é»‘æ ‘å’Œsplay_tree_tag// ç¬¬äº”ä¸ªæ˜¯ä¸ºäº†æ”¯æŒæŸ¥è¯¢ç¬¬kå¤§å’Œæ’åçš„ä¸€ä¸ªå‚æ•°T.insert(x); T.erase(x); T.lower_bound(x);int rk=(int)T.order_of_key(x)+1; // æŸ¥è¯¢ä¸€ä¸ªæ•°çš„æ’åint num=(int)*T.find_by_order(x-1)); //æŸ¥è¯¢ç¬¬kå¤§çš„æ•° è¿”å›è¿­ä»£å™¨// rope#include&lt;ext/rope&gt;using namespace __gnu_cxx;rope&lt;/*int*/&gt;r;r.push_back(x); // åœ¨æœ«å°¾æ·»åŠ xr.insert(pos,x); // åœ¨posæ’å…¥xï¼Œè‡ªç„¶æ”¯æŒæ•´ä¸ªcharæ•°ç»„çš„ä¸€æ¬¡æ’å…¥r.erase(pos,x); // ä»poså¼€å§‹åˆ é™¤xä¸ªr.copy(pos,len,x); // ä»poså¼€å§‹åˆ°pos+lenä¸ºæ­¢ç”¨xä»£æ›¿r.replace(pos,x); // ä»poså¼€å§‹æ¢æˆxr.substr(pos,x); // æå–poså¼€å§‹xä¸ª æŒ‡ä»¤é›†ä¼˜åŒ–123#pragma GCC optimize(3)#pragma GCC optimize(&quot;Ofast,no-stack-protector&quot;)#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native&quot;) å…³åŒæ­¥1ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); å¿«è¯»123456inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch)) w|=ch==&#x27;-&#x27;,ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-&#x27;0&#x27;,ch=getchar(); return w?-x:x;&#125; __int128è¾“å…¥è¾“å‡º1234567891011void scan(__int128 &amp;x)&#123; x=0; int op=1; char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;) op=(c==&#x27;-&#x27;?-1:1),c=getchar(); while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#x27;0&#x27;,c=getchar(); x*=op;&#125;void print(__int128 x)&#123; if(x&lt;0)&#123; x=-x; putchar(&#x27;-&#x27;); &#125; if(x&gt;9) print(x/10); putchar(x%10+&#x27;0&#x27;);&#125; éšæœº12mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count());int rnd(int x)&#123; return mrand()%x; &#125; ç»™é€†å…ƒæ±‚æ¦‚ç‡123456789101112void slove(ll pa,ll xa,ll pb,ll xb,ll &amp;a,ll &amp;b)&#123; ll tmp=(pa-1)/xa; if(tmp+1&lt;=pb/xb)&#123; a=tmp+1; b=1; return; &#125; pa-=tmp*xa; pb-=tmp*xb; slove(xb,pb,xa,pa,b,a); a+=tmp*b; &#125;void getsample()&#123; ll p,x,a,b; scl(p); scl(x); // pæ¨¡çš„è´¨æ•° xç»“æœ slove(p,x,p,x-1,a,b); ll c=x*a-p*b; pf(&quot;%lld/%lld\\n&quot;,c,a);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"æ¿å­","slug":"æ¿å­","permalink":"http://example.com/tags/%E6%9D%BF%E5%AD%90/"}]},{"title":"2019æµæ°´è´¦æ€»ç»“","slug":"2019æµæ°´è´¦æ€»ç»“","date":"2019-12-31T12:08:01.000Z","updated":"2021-01-26T16:39:01.021Z","comments":true,"path":"2019/12/31/2019æµæ°´è´¦æ€»ç»“/","link":"","permalink":"http://example.com/2019/12/31/2019%E6%B5%81%E6%B0%B4%E8%B4%A6%E6%80%BB%E7%BB%93/","excerpt":"æ²¡å¹²ä»€ä¹ˆçš„2019","text":"æ²¡å¹²ä»€ä¹ˆçš„2019 2019å¯¹æˆ‘æ¥è¯´ æ˜¯å¾ˆæ²¡æœ‰æ¦‚å¿µçš„ä¸€å¹´æ—¥å¸¸ç”Ÿæ´»éƒ½æ˜¯è®­ç»ƒç”»ç¨¿æ‘¸é±¼ æ¯å¤©éƒ½å¾ˆä¸€æ ·ä¸€æœˆå¼€å§‹å¯’å‡çš„ä¸“é¢˜è®­ç»ƒäºŒæœˆç”»äº†hgameçš„ç¨¿ä¸‰æœˆè¿›äº†æ­£å¼é˜Ÿå››æœˆåšäº†vidarå…”åˆè®¾äº”æœˆæŸ“äº†ä¸ªå¤´ ä¿æŒæ¯æ—¥å†™é¢˜æ‰“å¡ æŒºæ‹¼çš„ç»å¸¸è¶´åœ¨ç”µè„‘æ—å°±ç¡ç€äº†qwqå…­æœˆæœ‰äº†ä¸–ç•Œä¸Šæœ€å¥½çœ‹çš„è€å©†æµ·æ´‹ä¹‹æ˜Ÿ ä½†æ˜¯æ‰“é“œäº†å‘œå‘œä¸ƒæœˆç•™ç€æš‘å‡é›†è®­äº† å¼€å¿ƒå…«æœˆç»§ç»­é›†è®­ å¥½å–œæ¬¢é›†è®­çš„æ—¥å­ ç¡åˆ°ä¸­åˆç„¶åå»å®éªŒå®¤æ‰“æ¯”èµ›/è¡¥é¢˜ å¾ˆçº¯ç²¹ä¹æœˆå¼€å§‹å¿™æ‹›æ–° cfratingå¼€å§‹æ¶¨åæœˆå¥½åƒä¹Ÿæ²¡å¹²å˜›ï¼Ÿå¯èƒ½æ˜¯æ²¡æ¯”èµ›æ‰“å¿ƒæ€æœ‰ç‚¹å°å´© ä¸è¿‡å…»èµ·æ¥äº†å„ç§å¥½ä¹ æƒ¯åä¸€æœˆæ¢å¤è®­ç»ƒäº† cfè“äº† ç¡äº†ä¸¤æ¬¡å®éªŒå®¤ å¼€å§‹å¿™d3çš„ç¨¿ ä¸¤å¤´è·‘ç´¯æ­»åäºŒæœˆå’Œylhåœ¨ä¸€èµ·äº† cf1802äº† å½“ä¸Šäº†å‰¯é˜Ÿé™¤äº†1205æ²¡æœ‰ä»€ä¹ˆå¾ˆç‰¹æ®Šçš„æ—¶å€™äº†qwq æ¯å¤©éƒ½ä¸€æ · å¾ˆæ™®é€š æ™®é€šåˆ°ä¸€çœ¨çœ¼2019å°±å·²ç»è¿‡å»äº†å¯¹äºacm æœ‰è¿‡è¿·èŒ« æœ‰è¿‡æŒ£æ‰ æœ‰è¿‡ç—›è‹¦ ä½†æ›´å¤šçš„è¿˜æ˜¯çƒ­çˆ±å§ â€œå¦‚æœä½ è§‰å¾—æ‰“acmç—›è‹¦å¤šäºå¿«ä¹ é‚£æ‰ç®—ä¸é€‚åˆâ€ å¸Œæœ›wenzhuanç»§ç»­åŠ æ²¹ å¸Œæœ›cfç¨³åœ¨1800 è¿˜å¸Œæœ›è‡ªå·±èƒ½å½“ä¸€ä¸ªç‹¬å½“ä¸€é¢çš„é€‰æ‰‹ ä¿è¯å•åˆ·ç¨³é“œqwqqqå…³äºylh å…¶å®æ²¡åœ¨ä¸€èµ·å‰å°±æƒ³è¿‡è¦å†™ä»– ç½‘æ˜“äº‘å¹´åˆçš„ç­¾æ˜¯â€œé‡åˆ°ä½ ç”Ÿå‘½é‡Œå¾ˆçè´µçš„äººâ€è¿˜çœŸåº”äº† è¿˜æ˜¯å¥½å…„å¼Ÿçš„æ—¶å€™å°±æŠŠä»–çœ‹å¾—å¾ˆé‡äº† ä¸€èµ·åˆ·é¢˜ä¸€èµ·è·‘æ­¥ä¸€èµ·åƒé¥­ä¸€èµ·æ¯”èµ› ä»¥è‡´æˆ‘ç”šè‡³æœ‰æ®µæ—¶é—´äº§ç”Ÿäº†å¾ˆä¸¥é‡çš„ä¾èµ– å®³æ€•ä¸€ä¸ªäººåƒé¥­ä¸€ä¸ªäººè·‘æ­¥ä¸€ä¸ªäººæ‰“æ¯”èµ› ä»–æ˜¯æˆ‘ç”Ÿæ´»é‡Œä¸å¯æˆ–ç¼ºçš„ä¸€éƒ¨åˆ† æ˜¯æˆ‘çš„è‰¯å¥½ä¹ æƒ¯ æ˜¯æˆ‘æ°¸é‡ä¹çš„å¯„æ‰˜èƒ½æˆæ˜¯â€œæˆ‘è¿™ä¸ªé˜²aké¢˜ä¸ºäº†æ”¾ä»–çš„å‚»é€¼ä»£ç 1aè°ƒäº†ä¸€ä¸ªæœˆçš„æ•°æ®â€ åæœˆåº•åšæ¢¦æ¢¦åˆ°ä»–å’Œæˆ‘è¡¨ç™½ å½“åœºå“é†’ å› ä¸ºçœŸçš„å¾ˆæ€•å¤±å»è¿™æ ·çš„ä¸€ä¸ªå¥½æœ‹å‹ åšäº†ä¸€ä¸ªæœˆçš„å¿ƒç†å‡†å¤‡ è§‰å¾—å¦‚æœæ˜¯ä»–çš„è¯ ä¹Ÿä¸æ˜¯ä¸å¯ä»¥ åæ¥æ„Ÿè§‰æµ‹äº†å‡ æ¬¡æ ·ä¾‹ ä¹Ÿæ”¾ä»–è¿‡äº† æœ€åå°±ç†æ‰€å½“ç„¶åœ°1aå¥½å–œæ¬¢ä»–å•Š æˆ‘éƒ½ä¸çŸ¥é“æˆ‘èƒ½è¿™ä¹ˆå–œæ¬¢ä¸€ä¸ªäºº å˜»å˜»æœ‰åœ¨çœ‹æˆ‘åšå®¢çš„ æ–°å¹´å¿«ä¹å‘€ å˜»å˜»","categories":[{"name":"w&y","slug":"w-y","permalink":"http://example.com/categories/w-y/"}],"tags":[{"name":"éšç¬”","slug":"éšç¬”","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"å“ˆç†å·¥2019æ–°ç”Ÿèµ›è§£é¢˜æŠ¥å‘Š","slug":"å“ˆç†å·¥2019æ–°ç”Ÿèµ›è§£é¢˜æŠ¥å‘Š","date":"2019-12-21T07:30:28.000Z","updated":"2021-01-26T16:43:12.585Z","comments":true,"path":"2019/12/21/å“ˆç†å·¥2019æ–°ç”Ÿèµ›è§£é¢˜æŠ¥å‘Š/","link":"","permalink":"http://example.com/2019/12/21/%E5%93%88%E7%90%86%E5%B7%A52019%E6%96%B0%E7%94%9F%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"æ²¡å•¥å¥½å†™çš„ä½†æ¯•ç«Ÿä¹Ÿæ˜¯akäº†","text":"æ²¡å•¥å¥½å†™çš„ä½†æ¯•ç«Ÿä¹Ÿæ˜¯akäº† æ¥çœ‹å‹è¡Œå°å¤©æ‰çš„è¡¨æ¼” A: ä¼šé•¿çš„çƒ¦å¿ƒäº‹é¢˜ç›®é“¾æ¥ 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int len[15];int change(char c)&#123; if(c==&#x27;l&#x27;) return 0; if(c==&#x27;e&#x27;) return 1; if(c==&#x27;a&#x27;) return 2; if(c==&#x27;g&#x27;) return 3; if(c==&#x27;u&#x27;) return 4; if(c==&#x27;o&#x27;) return 5; if(c==&#x27;f&#x27;) return 6; return 7;&#125;int main()&#123; string s; while(cin&gt;&gt;s)&#123; int n=s.length(); rep(i,0,7) len[i]=0; rep(i,0,n) len[change(s[i])]++; len[0]/=2; len[1]/=2; int mn=1e9; rep(i,0,7) mn=min(mn,len[i]); cout&lt;&lt;mn&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; B: å¿«æ¥ç§’æ‰æˆ‘ï¼é¢˜ç›®é“¾æ¥å—¯ï¼ç¬¬ä¸€æ¬¡å†™phpï¼ˆé€ƒ 1Do you want to play ACM?(yes\\no) C: ç´ æ•°åœ†ç¯é¢˜ç›®é“¾æ¥æš´æœ 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int n,cas,ans[25],vis[25];int p[25]=&#123;0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1&#125;;void dfs(int x)&#123; if(x&gt;n&amp;&amp;p[ans[n]+1]) rep(i,1,n+1) cout&lt;&lt;ans[i]&lt;&lt;(char)(i==n?&#x27;\\n&#x27;:&#x27; &#x27;); if(x&lt;=n) rep(i,2,n+1) if(!vis[i]&amp;&amp;p[i+ans[x-1]])&#123; vis[i]=1; ans[x]=i; dfs(x+1); vis[i]=0; &#125;&#125;void solve()&#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;++cas&lt;&lt;&quot;:\\n&quot;; ans[1]=1; if(n%2==0) dfs(2); cout&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) solve();&#125; D: ç”µè„‘ç£¨æŸç¨‹åº¦é¢˜ç›®é“¾æ¥å§”å±ˆï¼Œå®ƒå¡coutç²¾åº¦ 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int solve(int n)&#123; if(n&lt;=4) return cout&lt;&lt;10&lt;&lt;&#x27;\\n&#x27;,0; int r=n%8,c=n/8; if(!r) return cout&lt;&lt;c*18&lt;&lt;&#x27;\\n&#x27;,0; if(r==1) return cout&lt;&lt;c*18+2&lt;&lt;&quot;.4&quot;&lt;&lt;&#x27;\\n&#x27;,0; if(r==2) return cout&lt;&lt;c*18+4&lt;&lt;&quot;.8&quot;&lt;&lt;&#x27;\\n&#x27;,0; if(r==3) return cout&lt;&lt;c*18+7&lt;&lt;&quot;.2&quot;&lt;&lt;&#x27;\\n&#x27;,0; if(r==4) return cout&lt;&lt;c*18+9&lt;&lt;&quot;.6&quot;&lt;&lt;&#x27;\\n&#x27;,0; return cout&lt;&lt;c*18+10+(r-4)*2&lt;&lt;&#x27;\\n&#x27;,0;&#125;int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n) solve(n);&#125; E: ACMerå¦‚ä½•æ‹¯æ•‘å°å­¦ç”Ÿé¢˜ç›®é“¾æ¥ 123456789101112#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;string s;int main()&#123; int _; cin&gt;&gt;(_); getchar(); while(_--)&#123; getline(cin,s); int n=s.length(); string t=&quot;&quot;; t+=toupper(s[0]); rep(i,1,n)&#123; if(s[i-1]==&#x27; &#x27;&amp;&amp;s[i]!=&#x27; &#x27;) t+=toupper(s[i]); &#125; cout&lt;&lt;t&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; F: å½“ä¼šé•¿å’Œä¸€ç¾¤æ‰‹è´±çš„è€—å­åœ¨ç”µæ¢¯ç›¸é‡é¢˜ç›®é“¾æ¥ç®—å› æ•°ä¸ªæ•° 123456789101112#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)using namespace std;typedef long long ll;void solve(ll n)&#123; ll cnt(0); rep(i,1,1e8)&#123; if(i*i&gt;n) break; if(n%i==0) cnt+=i*i==n?1:2; &#125; puts(cnt&amp;1?&quot;Goddess,I&#x27;m coming~~~&quot;:&quot;Farewell~&quot;);&#125;int main()&#123; ll n; while(cin&gt;&gt;n&amp;&amp;n) solve(n);&#125; G: ACMeråˆ†å¥–é‡‘é¢˜ç›®é“¾æ¥ 1234567891011121314#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int main()&#123; int _; cin&gt;&gt;_; while(_--)&#123; int num[10]; rep(i,0,6) num[i]=0; int n; cin&gt;&gt;n; rep(i,0,n)&#123; int a; cin&gt;&gt;a; num[0]+=a/100; a%=100; num[1]+=a/50; a%=50; num[2]+=a/20; a%=20; num[3]+=a/10; a%=10; num[4]+=a/5; a%=5; num[5]+=a; &#125; int sum(0); rep(i,0,6) sum+=num[i]; cout&lt;&lt;sum&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; H: æ”¾è½»æ¾é¢˜ç›®é“¾æ¥ 12345678910#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;double a[15];int main()&#123; int n; while(cin&gt;&gt;n)&#123; rep(i,0,n) cin&gt;&gt;a[i]; sort(a,a+n); rep(i,0,n) printf(&quot;%.2lf &quot;,a[i]); cout&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; I: ACMåä¼šæ™šä¼šé¢˜ç›®é“¾æ¥ç»„åˆæ•° 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;const int mod = 1e18;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1,y=0; return; &#125; else&#123; exgcd(b,a%b,y,x); y-=(a/b)*x; return; &#125;&#125;ll C(int s,int x)&#123; if(s&gt;x-s) s=x-s; ll ans=1,tmp=1,xx,y; rep(i,1,s+1) ans=ans*(x-i+1)%mod,tmp=tmp*i%mod; exgcd(tmp,mod,xx,y); ans=(ans*xx%mod+mod)%mod; return ans;&#125;int solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; if(m&gt;n) return puts(&quot;0&quot;); return cout&lt;&lt;C(m,n)&lt;&lt;&#x27;\\n&#x27;,0;&#125;int main()&#123; int _; cin&gt;&gt;_; while(_--) solve();&#125; J: ä¼šé•¿çˆ±æ—…æ¸¸é¢˜ç›®é“¾æ¥bfs 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 1e5 + 5;vector&lt;int&gt;vv[maxn];int vis[maxn],ans[maxn];void bfs(int s)&#123; queue&lt;int&gt;q; q.push(s); while(!q.empty())&#123; int fr=q.front(); q.pop(); for(int t:vv[fr]) if(!vis[t]) vis[t]=1,ans[t]=fr,q.push(t); &#125;&#125;int main()&#123; int _; cin&gt;&gt;_; while(_--)&#123; int n,s; cin&gt;&gt;n&gt;&gt;s; mst(vv,0); rep(i,1,n)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; vv[x].push_back(y); vv[y].push_back(x); &#125; ans[s]=-1; vis[s]=1; bfs(s); rep(i,1,n+1) cout&lt;&lt;ans[i]&lt;&lt;(char)(i==n?&#x27;\\n&#x27;:&#x27; &#x27;); &#125;&#125; å‹è¡Œé€‰æ‰‹æ˜¯è¿™ä¹ˆç‰›é€¼çš„","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"}]},{"title":"ä½™å¿ƒå¾€æœŸgraffitiå½’æ¡£","slug":"ä½™å¿ƒgraffitiä½œå“é›†","date":"2019-12-15T04:00:11.000Z","updated":"2021-01-26T16:44:05.395Z","comments":true,"path":"2019/12/15/ä½™å¿ƒgraffitiä½œå“é›†/","link":"","permalink":"http://example.com/2019/12/15/%E4%BD%99%E5%BF%83graffiti%E4%BD%9C%E5%93%81%E9%9B%86/","excerpt":"æŒç»­æ›´æ–°ã€‚","text":"æŒç»­æ›´æ–°ã€‚ ä¸å¯å•†ç”¨ï¼Œå…¶ä»–ä½¿ç”¨è¯·å…ˆæˆæƒ ä¸Šæµ· 17.9graffitiåˆå°è¯• é£æ ¼æ¨¡ä»¿å¾ˆåƒåœŸå—¨= = MATURITY 17.9é£æ ¼æ¨¡ä»¿é…è‰²è¿˜æ˜¯okçš„ Monster 17.11ç» å…¸ é… è‰² 19.3ç»˜åˆ¶çŸ¢é‡ç‰ˆæœ¬// å½“æ—¶ç”»å¾—ç¦»è°± ä¹‹åè¡¥å›¾ æµ™æ±Ÿ 18.7 ZXJ 18.8çˆ±ä¸Šäº†cdr HDU 18.12ç¬¬ä¸€æ¬¡æˆ·å¤–æ¶‚é¸¦ Respite 18.12.31ç¬¬ä¸€æ¬¡çœŸÂ·ä¸Šå¢™åæ ‡ï¼š31å·æ¥¼åœ°ä¸‹è½¦åº“ HDUART 19.3-19.4å’Œå­¦å§ä¸€èµ·çš„æ¶‚å¢™ï¼è‡ªå·±åªåšäº†ä¸€å°ç‚¹ç‚¹ç‚¹","categories":[{"name":"y","slug":"y","permalink":"http://example.com/categories/y/"}],"tags":[{"name":"design","slug":"design","permalink":"http://example.com/tags/design/"}]},{"title":"ä½™å¿ƒå¾€æœŸå­—è®¾å½’æ¡£","slug":"ä½™å¿ƒå­—è®¾ä½œå“é›†","date":"2019-12-15T03:59:39.000Z","updated":"2021-01-26T16:44:21.484Z","comments":true,"path":"2019/12/15/ä½™å¿ƒå­—è®¾ä½œå“é›†/","link":"","permalink":"http://example.com/2019/12/15/%E4%BD%99%E5%BF%83%E5%AD%97%E8%AE%BE%E4%BD%9C%E5%93%81%E9%9B%86/","excerpt":"æŒç»­æ›´æ–°ã€‚","text":"æŒç»­æ›´æ–°ã€‚ ä¸å¯å•†ç”¨ï¼Œå…¶ä»–ä½¿ç”¨è¯·å…ˆæˆæƒHGAME logo/é›†è®­é˜Ÿlogoåº”è¯¥éšæ„ï¼Œè‡ªè¡Œä½¿ç”¨8ï¼Œå½“ç„¶èƒ½è¯´ä¸€å£°æ›´å¥½å•¦ 2017AM å±±é¬¼ Respite æ€’æ”¾ é’å±±è§æˆ‘ ä¸–ç•Œå’Œå¹³åˆå”±èŠ‚ å‡¹å‡¸ç›¸å…³ æ›´å¤šè§ä½™å¿ƒçš„lofter æ—ä½™å¿ƒ THREE æ¸…å¹³ä¹ æ¸…é¹¤ä½“â€œå‚åŠ æ–¹æ­£å­—ä½“è®¾è®¡æ¯”èµ›æ˜¯æˆ‘çš„æ¢¦æƒ³ï¼Œåªè¦å‚åŠ å°±å¤Ÿäº†â€å¾ˆç¾¡æ…•å½“æ—¶çš„çƒ­æƒ… 2018å¹³å¿ƒé™æ°” æ‰‡å­é«˜è€ƒå‰çš„æ‘¸é±¼ è²å­æ¸…å¦‚æ°´ ç–ç‹‚ 2019HGAME logo HDUACMé›†è®­é˜Ÿlogoå¥½ä¸‘ï¼Œä¸æƒ³æ”¾å›¾ Vidar-Team 2019å¤å­£ä¼šæœ çµæ„Ÿ Vidar-Teamæ‹›æ–°æµ·æŠ¥ D^3CTFç›¸å…³ Vidar-Team 2019ç§‹å†¬ä¼šæœ","categories":[{"name":"y","slug":"y","permalink":"http://example.com/categories/y/"}],"tags":[{"name":"design","slug":"design","permalink":"http://example.com/tags/design/"}]},{"title":"Codeforces Round #604è§£é¢˜æŠ¥å‘Š","slug":"Codeforces-Round-604è§£é¢˜æŠ¥å‘Š","date":"2019-12-06T03:53:26.000Z","updated":"2021-01-26T16:41:02.354Z","comments":true,"path":"2019/12/06/Codeforces-Round-604è§£é¢˜æŠ¥å‘Š/","link":"","permalink":"http://example.com/2019/12/06/Codeforces-Round-604%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"çªç„¶æƒ³æ›´åšå‘—","text":"çªç„¶æƒ³æ›´åšå‘— rk553 rating+35ä¸€è¾¹æ‰“ä¸€è¾¹çœ‹å­¦å¼Ÿæ”¹çš„ç¨¿å­233 æœ‰ç‚¹å°ç‚¸ä¸‹è¾ˆå­å†ä¹Ÿä¸å€’å¼€äº†.jpg A: Beautiful Stringé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šå¸Œæœ›æ„é€ ä¸€ä¸ªé‚»ä½ä¸ç›¸åŒçš„åªæœ‰abcçš„å­—ç¬¦ä¸² ç»™å®šä¸€ä¸ªå¸¦æœ‰â€™?â€™çš„ä¸² â€˜?â€™å¯ä»¥ä»»æ„æ›¿æ¢ä¸ºabc é—®èƒ½ä¸èƒ½æ„é€ å‡ºç¬¦åˆè¦æ±‚çš„ä¸²ä¸€å¼€å§‹è¢«å¡äº†ä¸€ä¸‹ 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define sc(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;char s[maxn];int solve()&#123; scs(s); int len=strlen(s); if(s[0]==&#x27;?&#x27;&amp;&amp;s[1]!=&#x27;a&#x27;) s[0]=&#x27;a&#x27;; else if(s[0]==&#x27;?&#x27;) s[0]=&#x27;b&#x27;; if(s[len-1]==&#x27;?&#x27;&amp;&amp;s[len-2]!=&#x27;a&#x27;) s[len-1]=&#x27;a&#x27;; else if(s[len-1]==&#x27;?&#x27;) s[len-1]=&#x27;b&#x27;; rep(i,1,len-1) if(s[i]==&#x27;?&#x27;)&#123; if(s[i-1]==&#x27;a&#x27;)&#123; if(s[i+1]!=&#x27;b&#x27;) s[i]=&#x27;b&#x27;; else s[i]=&#x27;c&#x27;; &#125; else&#123; if(s[i+1]!=&#x27;a&#x27;) s[i]=&#x27;a&#x27;; else if(s[i-1]==&#x27;b&#x27;) s[i]=&#x27;c&#x27;; else s[i]=&#x27;b&#x27;; &#125; &#125; rep(i,1,len) if(s[i-1]==s[i]) return puts(&quot;-1&quot;); pf(&quot;%s\\n&quot;,s); return 0;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; B: Beautiful Numbersé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šç»™å®šnå’Œåˆå§‹åºåˆ— é—®åœ¨1åˆ°nä¸­çš„iæœ‰å“ªäº›æ»¡è¶³åœ¨åˆå§‹åºåˆ—ä¸­å­˜åœ¨åŒºé—´é•¿åº¦ä¸ºiä¸”åŒºé—´å†…åªæœ‰1-içš„æ•°çœŸå¥½å†™å•Š æˆ‘ä¸ºä»€ä¹ˆä¸å…ˆå†™Båˆ¤ä¸€ä¸‹å·¦å³å°±è¡Œ å†™å¾—å¤æ‚äº†ä¸€ç‚¹ 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define sc(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[maxn],ans[maxn];pii p[maxn];int solve()&#123; int n,pos; sc(n); rep(i,1,n+1)&#123; sc(a[i]); p[i].first=a[i]; p[i].second=i; &#125; sort(p+1,p+n+1); ans[1]=1; int l=1e9,r=0; rep(i,1,n+1)&#123; l=min(l,p[i].second); r=max(r,p[i].second); if(r-l&gt;=i) ans[i]=0; else if(r-l&lt;i) ans[i]=1; else ans[i]=0; &#125; rep(i,1,n+1) pf(&quot;%d&quot;,ans[i]); pf(&quot;\\n&quot;);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; C: Beautiful Regional Contesté¢˜ç›®é“¾æ¥é¢˜æ„ï¼šåˆ†é‡‘é“¶é“œç‰Œ è§„åˆ™æ˜¯è·å¾—é‡‘ç‰Œçš„äººé¢˜æ•°ä¸¥æ ¼å¤§äºå¾—é“¶ç‰Œçš„ é“¶ç‰Œçš„ä¸¥æ ¼å¤§äºé“œç‰Œçš„ é‡‘ç‰Œæ•°ä¸¥æ ¼å°äºé“¶ç‰Œæ•°å’Œé“œç‰Œæ•° ä¸‰ä¸ªç‰Œå­çš„æ€»å’Œä¸å¤šäºæ€»äººæ•°çš„ä¸€åŠ ç»™å®šäººæ•°å’Œè¿‡é¢˜æ•° å¸Œæœ›ç‰Œå­å°½é‡å¤š è¾“å‡ºæ–¹æ¡ˆè´ªå¿ƒ é‡‘ç‰Œåªå–æœ€å¤šè¿‡é¢˜æ•°çš„äººæ•° é“¶ç‰Œå–åˆ°æ¯”é‡‘ç‰Œå¤šå°±break é“œå‰©ä¸‹ åˆ¤æ˜¯å¦ç¬¦åˆè¦æ±‚ 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;int a[maxn],vis[maxn];int main()&#123; int _; sc(_); while(_--)&#123; int n,a0; sc(n); sc(a0); rep(i,0,a0+1) vis[i]=0; a[1]=a0; vis[a0]++; rep(i,2,n+1) sc(a[i]),vis[a[i]]++; int mid=n/2; if(a[mid]==a[mid+1])&#123; while(a[mid]==a[mid+1]) mid--; &#125; int aa,b=0,c=0; aa=vis[a0]; dep(i,a0-1,0) if(vis[i])&#123; b+=vis[i]; if(b&gt;aa) break; &#125; if(b&lt;=aa||aa+b&gt;=mid)&#123; pf(&quot;0 0 0\\n&quot;); continue; &#125; c=mid-aa-b; if(c&lt;=aa)&#123; pf(&quot;0 0 0\\n&quot;); continue; &#125; pf(&quot;%d %d %d\\n&quot;,aa,b,c); &#125;&#125; D: Beautiful Sequenceé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šç»™abcdå››ä¸ªæ•° ä»£è¡¨æœ‰aä¸ª0 bä¸ª1 cä¸ª2 dä¸ª3 é—®èƒ½ä¸èƒ½æ„æˆç›¸é‚»ä½å·®å€¼ç»å¯¹å€¼ä¸º1çš„åºåˆ—æœ¬æ¥ä»¥ä¸ºæ˜¯ç»†èŠ‚é¢˜ æ€ç»´è¿˜æ˜¯ä¸å¤Ÿç¼œå¯†å¾ˆå¤šè¯·å†µæ²¡è€ƒè™‘åˆ°233çœ‹äº†dlsä»£ç  å†™çš„æ˜¯æŒ‰é¢˜æ„æ¨¡æ‹Ÿ çœŸå¥½çœ‹å•Š wxhtxdytxdy 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[5],b[5];vector&lt;int&gt;vv; int main()&#123; rep(i,0,4) sc(a[i]); rep(i,0,4)&#123; rep(j,0,4) b[j]=a[j]; if(!b[i]) continue; int x=i; vv.clear(); while(1)&#123; vv.push_back(x); b[x]--; if(x&amp;&amp;b[x-1]) x--; else if(x!=3&amp;&amp;b[x+1]) x++; else break; &#125; if(!b[0]&amp;&amp;!b[1]&amp;&amp;!b[2]&amp;&amp;!b[3])&#123; pf(&quot;YES\\n&quot;); rep(i,0,vv.size()) pf(&quot;%d &quot;,vv[i]); return pf(&quot;\\n&quot;),0; &#125; &#125; return pf(&quot;NO\\n&quot;),0;&#125; E: Beautiful Mirrorsé¢˜ç›®é“¾æ¥æ–‡å­—å…ˆå’•äº† å¥½å›° éšç¼˜æ›´ 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1) ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;ll a[maxn],q1[maxn],q2[maxn];int main()&#123; int n; sc(n); rep(i,0,n) scl(a[i]); ll t=qpow(100,mod-2); q1[n]=q2[n]=0; dep(i,n-1,0)&#123; q1[i]=a[i]*t%mod*q1[i+1]%mod; q1[i]++; q1[i]%=mod; q2[i]=a[i]*t%mod*q2[i+1]%mod; q2[i]+=t*(100-a[i])%mod; q2[i]%=mod; &#125; ll ans=q1[0]*qpow((1-q2[0]+mod)%mod,mod-2)%mod; pf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"Codeforces Round #598è§£é¢˜æŠ¥å‘Š","slug":"Codeforces-Round-598è§£é¢˜æŠ¥å‘Š","date":"2019-11-06T05:35:17.000Z","updated":"2021-01-26T16:40:56.175Z","comments":true,"path":"2019/11/06/Codeforces-Round-598è§£é¢˜æŠ¥å‘Š/","link":"","permalink":"http://example.com/2019/11/06/Codeforces-Round-598%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"å…¨ç»¿çš„ç¬¬ä¸€åœºä¸å¥½æ„æ€è¯´æ˜¯é¢˜è§£ å°±è§£é¢˜æŠ¥å‘Šå§ï¼ˆå¤©å“ªç¨³èµšç»ˆäºæ›´åšäº†","text":"å…¨ç»¿çš„ç¬¬ä¸€åœºä¸å¥½æ„æ€è¯´æ˜¯é¢˜è§£ å°±è§£é¢˜æŠ¥å‘Šå§ï¼ˆå¤©å“ªç¨³èµšç»ˆäºæ›´åšäº† å…ˆåæ€ä¸€ä¸‹ Bè¿™ä¸ªå‚»é€¼æš´åŠ›åœºä¸Šæ²¡è°ƒå‡ºæ¥ çœŸçš„å¼Ÿå¼Ÿè¿™åœº+11 æˆ‘ä»€ä¹ˆæ—¶å€™ä¸Šè“å•Š555è´ªå¿ƒåœºâˆš A: Payment Without Changeé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šæœ‰aä¸ªn bä¸ª1 é—®èƒ½ä¸èƒ½å‡‘åˆ°sä»¥ä¸ºä¼šç‚¸int èµ›åæƒ³äº†æƒ³å¥½åƒä¹Ÿä¸ä¼š233 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)using namespace std;typedef long long ll;ll a,b,n,s;int solve()&#123; if(a*n+b&lt;s) return puts(&quot;NO&quot;),0; int x=min(a,s/n); if(x*n+b&gt;=s) return puts(&quot;YES&quot;),0; else return puts(&quot;NO&quot;),0;&#125;int main()&#123; int _; sc(_); while(_--)&#123; scl(a); scl(b); scl(n); scl(s); solve(); &#125;&#125; B: Minimize the Permutationé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šç»™å®šä¸€ä¸ª1~nçš„æ’åˆ— è¦æ“ä½œæœ€å¤šn-1æ¬¡ç›¸é‚»ä½äº¤æ¢ä¸”æ¯ä¸ªä½ç½®åªèƒ½äº¤æ¢ä¸€æ¬¡ ä½¿æœ€ç»ˆç»“æœåºåˆ—å­—å…¸åºæœ€å° è¾“å‡ºæ­¤åºåˆ—æš´åŠ›è½ å†™å¾—æœ‰ç‚¹ä¸‘ ä¸€ä¸ªæ´»è„±è„±çš„&gt;å·æˆ‘å¼€å§‹å‹è¡Œåå°±æ²¡å†™è¿‡è¿™ä¹ˆä¸‘çš„ä»£ç  12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[105],v[105];int main()&#123; int _; sc(_); while(_--)&#123; int n; sc(n); rep(i,1,n+1) sc(a[i]),v[i]=0; int c(0); rep(i,1,n+1)&#123; rep(j,1,n+1)&#123; if(a[j]==i)&#123; int k=j; while(k&gt;1)&#123; if(v[k]) break; if(a[k]&lt;a[k-1])&#123; swap(a[k],a[k-1]); c++; v[k]++; &#125; else break; k--; &#125; break; &#125; &#125; if(c==n) break; &#125; rep(i,1,n+1) pf(&quot;%d &quot;,a[i]); pf(&quot;\\n&quot;); &#125;&#125; C: Platforms Jumpingé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šä¸€é“æ²³é•¿n æœ‰mä¸ªæœ¨æ¿ ç¬¬iä¸ªæœ¨æ¿é•¿c[i] äººä¸€æ¬¡å¯ä»¥è·³dæ ¼ é—®è¿™ä¸ªäººèƒ½å¦è¿‡æ²³ èƒ½çš„è¯è¾“å‡ºæ–¹æ¡ˆè´ªå¿ƒ åˆ¤å®ŒYESåå…ˆè®©è¿™ä¸ªäººä¸€ç›´è·³å°½é‡è¿œ 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[1005],s;int main()&#123; int n,m,k; sc(n); sc(m); sc(k); rep(i,1,m+1) sc(a[i]),s+=a[i]; if(n-s&gt;(m+1)*(k-1)) pf(&quot;NO\\n&quot;); else&#123; int n1=n; pf(&quot;YES\\n&quot;); n-=s; n++; rep(i,1,m+2)&#123; int t=min(k,n); rep(j,0,t-1) pf(&quot;0 &quot;); rep(j,0,a[i]) pf(&quot;%d &quot;,i); n-=t-1; &#125; &#125;&#125; D: Binary String Minimizingé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šç»™å®šä¸€ä¸ªé•¿åº¦ä¸ºnçš„01ä¸² é—®äº¤æ¢æœ€å¤škæ¬¡åå­—å…¸åºæœ€å°çš„ä¸²æ˜¯ä»€ä¹ˆè´ªå¿ƒ ç›´æ¥forä¸€é ä¸è¿‡è¿˜æ˜¯å†™éº»çƒ¦äº†233kæ²¡å¼€ll waäº†ä¸€æ¬¡ qswl 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;const int maxn = 1e6 + 5;char s[maxn];vector&lt;int&gt;v;int main()&#123; int _; sc(_); while(_--)&#123; int n; ll k; sc(n); scl(k); scs(s); v.clear(); rep(i,0,n) if(s[i]==&#x27;0&#x27;) v.push_back(i); int pos(0); rep(i,0,n) if(s[i]==&#x27;0&#x27;) pos++; else break; rep(i,0,v.size())&#123; if(v[i]&lt;pos) continue; int t=min(1ll*v[i]-1ll*pos,k); if(t&lt;k) swap(s[v[i]],s[pos]); else swap(s[v[i]],s[v[i]-k]); k-=t; pos++; if(k&lt;=0) break; &#125; pf(&quot;%s\\n&quot;,s); &#125;&#125; E: Yet Another Division Into Teamsé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šnä¸ªäººæ¯ä¸ªäººèƒ½åŠ›ä¸ºa[i] ä¸€ä¸ªé˜Ÿçš„å·®è·æŒ‡æœ€å¤§å€¼å‡æœ€å°å€¼ è¦æŠŠè¿™äº›äººåˆ’åˆ†æˆkä¸ªè‡³å°‘3äººçš„é˜Ÿ å¸Œæœ›æ¯ä¸ªé˜Ÿå·®å¼‚æ€»å’Œæœ€å° æ±‚æ€»å’Œ é˜Ÿæ•° æˆå‘˜åˆ’åˆ†æ˜¯ä¸ªdp æˆ‘çœ‹é¢˜è§£å†™çš„å‘œå‘œå‘œ æ²¡ä»€ä¹ˆå¥½è¯´çš„ å®˜æ–¹é¢˜è§£æ›´å¥½æ‡‚ wtcl 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define pf printf#define INF 0x3f3f3f3f#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;const int maxn = 2e5 + 5;pair&lt;int,int&gt;a[maxn];int dp[maxn],t[maxn],r[maxn];int main()&#123; int n,cnt(0); sc(n); rep(i,0,n) sc(a[i].first),a[i].second=i; sort(a,a+n); rep(i,1,n+1) dp[i]=INF; rep(i,0,n) rep(j,3,6)&#123; if(i+j&gt;n) break; if(dp[i+j]&gt;dp[i]+a[i+j-1].first-a[i].first)&#123; dp[i+j]=dp[i]+a[i+j-1].first-a[i].first; r[i+j]=i; &#125; &#125; int now=n; while(now)&#123; dep(i,now-1,r[now]) t[a[i].second]=cnt; cnt++; now=r[now]; &#125; pf(&quot;%d %d\\n&quot;,dp[n],cnt); rep(i,0,n) pf(&quot;%d &quot;,t[i]+1); pf(&quot;\\n&quot;);&#125; F: Equalizing Two Stringsé¢˜ç›®é“¾æ¥é¢˜æ„ï¼šç»™å®šä¸²så’Œt æ¯æ¬¡å¯ä»¥åœ¨så’Œtä¸­ç¿»è½¬é•¿åº¦ç›¸åŒçš„å­ä¸² é—®æ˜¯å¦æœ‰å¯èƒ½ä½¿så’Œtç›¸åŒé—®æ–½è€å¸ˆçš„ 11-nbï¼ç¿»è½¬é•¿åº¦ä¸ºlençš„åŒºé—´å¯ä»¥ç­‰ä»·ä¸ºå¤šæ¬¡ç›¸é‚»äº¤æ¢ å°†å­—ç¬¦ä¸²æ¢æˆé€’å¢çš„ éœ€è¦é€†åºå¯¹æ¬¡ å¦‚æœé€†åºå¯¹æ•°ç›¸åŒæˆ–è€…å·®ä¸ºå¶æ•°ï¼ˆæ¢ä¸¤æ¬¡ç­‰åŒäºä¸å˜ï¼‰åˆ™å¯ä»¥ å¦‚æœæœ‰ä¸€ä¸ªä¸²çš„å­—æ¯æœ‰ä¸¤ä¸ªä»¥ä¸Š è¿™å°±å¯ä»¥å’Œè¿™ä¸ªå­—æ¯ä¸å—é™åœ°äº¤æ¢ æ‰€ä»¥ä¹Ÿå¯ä»¥å•Šæˆ‘è¯´çš„å•¥å•Š 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 2e5 + 5;int n,c[30],d[30];char s[maxn],t[maxn];int solve()&#123; int t1(0),t2(0); rep(i,0,n)&#123; c[s[i]-&#x27;a&#x27;]++,d[t[i]-&#x27;a&#x27;]++; rep(j,s[i]-&#x27;a&#x27;+1,26) t1+=c[j]; rep(j,t[i]-&#x27;a&#x27;+1,26) t2+=d[j]; &#125; rep(i,0,26) if(c[i]!=d[i]) return 0; rep(i,0,26) if(c[i]&gt;=2||d[i]&gt;=2) return 1; return (t1-t2)%2==0;&#125;int main()&#123; int _; sc(_); while(_--)&#123; sc(n); scs(s); scs(t); mst(c,0); mst(d,0); if(solve()) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"}]},{"title":"Javaå¤§æ•°åŸºæœ¬æ“ä½œ","slug":"Javaå¤§æ•°åŸºæœ¬æ“ä½œ","date":"2019-05-10T09:32:07.000Z","updated":"2021-01-26T16:41:15.222Z","comments":true,"path":"2019/05/10/Javaå¤§æ•°åŸºæœ¬æ“ä½œ/","link":"","permalink":"http://example.com/2019/05/10/Java%E5%A4%A7%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"è¯•ç€æ•´ç†æˆ‘çœ‹Javaçš„è¿‡ç¨‹å—·","text":"è¯•ç€æ•´ç†æˆ‘çœ‹Javaçš„è¿‡ç¨‹å—· ä¸€ç›´çŸ¥é“Javaå¤§æ•°nb ä¸€ç›´å£å—¨å­¦Java ä¸€ç›´æ²¡åŠ¨æœºç¼˜å·§åˆä¹‹ä¸‹ çœ‹åˆ°æˆ‘rank10058 æƒ³å¿«ä¹rankå››ä½æ•° åˆæ‡’å¾—å¼€æ–°é¢˜ å¹²è„†Javaæä¸ª1042ï¼ˆæ±‚N!ï¼‰å…ˆæœé¢˜è§£ä¸€è¡Œè¡Œæœçœ‹æ‡‚ä»€ä¹ˆæ„æ€åäº¤äº†æˆ‘çœ‹çš„é¢˜è§£æ˜¯BigDecimal ä½†è¿™é¢˜BigIntegerå°±è¡Œæˆ‘åæ¥ä¹ŸBigIntegerè¿‡äº†ä¸‹é¢å°±æ”¾BigIntegerçš„acä»£ç äº†=ã€‚= 1234567891011121314151617181920212223import java.math.BigInteger; import java.util.Scanner;// å¤§æ•°å¤´æ–‡ä»¶å’Œè¾“å…¥å¤´æ–‡ä»¶public class Main &#123; public static void main(String[] args) &#123; // æ ¼å¼å§ Scanner sc = new Scanner(System.in); // Scannerè¾“å…¥ è¿™åº”è¯¥å°±æ˜¯ä¸€å¥æ ‡å‡†æ ¼å¼å§233 while(sc.hasNext())&#123; // while(æœ‰è¾“å…¥) BigInteger n = sc.nextBigInteger(); // æ ¼å¼ BigInteger m=new BigInteger(&quot;1&quot;); // æ ¼å¼ for(int i=2;i&lt;=n.intValue();i++)&#123; // ä¸€ä¸ªæŒºcçš„for m = m.multiply(BigInteger.valueOf(i)); // å‡½æ•°æ ¼å¼ &#125; System.out.println(m.toString()); // è½¬æˆå­—ç¬¦ä¸²è¾“å‡º ä¸è¿‡ä¸è½¬ä¹Ÿè¡Œ &#125; &#125;&#125; çœŸÂ·ä¸€è¡Œä¸€æ³¨é‡Šäº†ï¼çœ‹æ‡‚äº†å°± å¿«ä¹äº¤é¢˜ ac++; rank=9949;ç„¶åå»é­”æ”¹ä»£ç  ç”¨åœ¨çº¿ç¼–è¯‘è·‘ æ•´è‡ªé—­äº† è¿˜æ˜¯ä¸‹äº†IDEAé…äº†ç¯å¢ƒ å•Šè¦æ­»ä¸è¿‡å½“æ—¶æ²¡é€‰å¥½é¢˜ æ²¡é€‰æ°´çš„ç„¶åæœç´¢å…³é”®è¯ï¼šhdoj å¤§æ•° Javagetåˆ°hdojä¸Šçš„Javaå¤§æ•°æ°´é¢˜ BigIntegerçš„æœ‰1002 // ä¸¤ä¸ªå¤§æ•°ç›¸åŠ 1047 // å¤§æ•°ç´¯åŠ 1715 // æ±‚æ–æ³¢é‚£å¥‘ ç›´æ¥å¤§æ•°ç›¸åŠ 1316 // æ±‚åŒºé—´æœ‰å‡ ä¸ªæ–æ³¢é‚£å¥‘æ•° å¤§æ•°åŠ å®Œforä¸€é1297 // é€’æ¨+å¤§æ•°åŠ æ³•ç„¶å BigIntegeråŸºæœ¬å‡½æ•°ï¼š 1234567891011121314151617181920212223242526BigInteger a, b;a = BigInteger.valueOf(b); // a=b;int c;a = BigInteger.valueOf(c); // ç±»å‹è½¬æ¢String s = &quot;111&quot;;a = BigInteger.valueOf(s); // è¿è¡Œåa==111;a = BigInteger(&quot;111&quot;); // èµ‹å€¼å¸¸é‡a = sc.nextInteger(); // èµ‹å€¼è¾“å…¥a = a.add(b); // a+=b;a = a.subtract(b); // a-=b;a = a.multiply(b); // a*=b;a = a.divide(b); // a/=b;/* å‡½æ•°é‡Œçš„å€¼ä¹Ÿæ˜¯BigInteger å¦‚æœæ˜¯å…·ä½“æ•°å€¼ æ ¼å¼ï¼ša.add(new BigInteger(&quot;1&quot;));æ˜¯å‰é¢å˜é‡ æ ¼å¼ï¼ša.add(BigInteger.valueOf(i));ç‰¹æ®Šçš„ 0 1 10 å¯ä»¥ç”¨BigInteger.ZERO\\ONE\\TEN;*/if(a.compareTo(b)&gt;0) System.out.println(a&gt;b); if(a.compareTo(b)==0) System.out.println(a==b);if(a.compareTo(b)&lt;0) System.out.println(a&lt;b);remainder(); mod(); // éƒ½æ˜¯a%bpow(); gcd(); // a^b æœ€å¤§å…¬çº¦æ•°abs(); negate(); // ç»å¯¹å€¼ ç›¸åæ•°max(); min();// å®šä¹‰æ•°ç»„æ ¼å¼BigInteger array[]=new BigInteger[maxn]; ç„¶åBigDecimal 12345678import java.math.BigDecimal; // å¤´æ–‡ä»¶BigDecimal a, b;a = sc.nextBigDecimal();a = new BigDecimal(111);a = new BigDecimal(b);// å‡½æ•°å’ŒBigIntegerå·®ä¸å¤ªå¤šå—· å°±æœ‰çš„è¯­æ³•æœ‰çš„å°å°åŒºåˆ«System.out.println(a.stripTrailingZeros().toPlainString());// è¿™ä¸ªæ˜¯ è¾“å‡ºæ—¶å»é™¤å¤šä½™æœ«å°¾0 å¥½ç”¨ï¼ï¼ hdoj BigDecimalæ°´é¢˜é¦–å…ˆBigIntegerçš„ç”¨BigDecimalåº”è¯¥ä¹Ÿèƒ½åšï¼Ÿ1753 // åŠ æ³•2054 // æ¯”è¾ƒ1063 // a^bé—®é¢˜ç„¶åè¯´ç‚¹é¢˜å¤–è¯ï¼Ÿé…å®ŒJavaç¯å¢ƒåæˆ‘å‘ç°æˆ‘çš„hexoå‘½ä»¤ä¸èƒ½ç”¨è¾½ Googleåè·Ÿç€æ•™ç¨‹æ˜¯ åœ¨é«˜çº§ç³»ç»Ÿè®¾ç½®ä¸­çš„ç¯å¢ƒå˜é‡çš„PATHåŠ äº†node_modules\\.binå’Œnodejsçš„è·¯å¾„ å°±å¯ä»¥è¾£ï¼","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"æ­å¸ˆæ ¡èµ›Ié¢˜-Little Sub and Enigma ACä»£ç ","slug":"Little-Sub-and-Enigmaé¢˜è§£","date":"2019-03-18T02:13:12.000Z","updated":"2021-01-26T16:41:23.120Z","comments":true,"path":"2019/03/18/Little-Sub-and-Enigmaé¢˜è§£/","link":"","permalink":"http://example.com/2019/03/18/Little-Sub-and-Enigma%E9%A2%98%E8%A7%A3/","excerpt":"ä¸éš¾ å¬äº†å‡ºé¢˜äººè®²æ€è·¯é©¬ä¸Šå°±ä¼š ä½†æˆ‘å°±æ˜¯è¦æé¢˜è§£ çºªå¿µæˆ‘çš„èµ›åœºè‡ªé—­å››å°æ—¶","text":"ä¸éš¾ å¬äº†å‡ºé¢˜äººè®²æ€è·¯é©¬ä¸Šå°±ä¼š ä½†æˆ‘å°±æ˜¯è¦æé¢˜è§£ çºªå¿µæˆ‘çš„èµ›åœºè‡ªé—­å››å°æ—¶ æœ€å‘çš„æ˜¯25å¯¹æ¨ç¬¬26å¯¹åŒå‘æ˜ å°„ä¸€ä¸€å¯¹åº”ç›´æ¥æ•°ç»„å­˜æ„Ÿè§‰ä¹Ÿè®¸æ˜¯è¾“åœ¨è‹±è¯­ä¸å¥½ï¼Ÿ é¢˜ç›®ï¼šLittle Sub and Enigma DescriptionLittle Sub builds a naive Enigma machine of his own. It can only be used to encrypt/decrypt lower-case letters by giving each letter a unique corresponding lower-case letter. In order to ensure the accuracy, no contradiction or controversy is allowed in both the decryption and the encryption, which means all lower-case letters can only be decrypted/encrypted into a distinct lower-case letter.Now we give you a string and its encrypted version. Please calculate all existing corresponding relationship which can be observed or deducted through the given information.InputThe first line contains a string S, indicating the original message.The second line contains a string T , indicating the encrypted version.The length of S and T will be the same and not exceed 1000000.Outputwe use a string like â€™x-&gt;yâ€™ to indicate that letter x will be encrypted to letter y.Please output all possible relationships in the given format in the alphabet order.However, if there exists any contradiction in the given information, please just output Impossible in one line.AuthorYE, Zicheng æ”¾ä¸€ä¸‹å‡ºé¢˜äººï¼Œzjunb ACä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int a[27], b[27];string s1, s2;int main() &#123; while (cin &gt;&gt; s1 &gt;&gt; s2) &#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); int flag = 0; for (int i = 0; i &lt; s1.length(); i++) &#123; int t1, t2; t1 = s1[i] - &#x27;a&#x27; + 1; t2 = s2[i] - &#x27;a&#x27; + 1; if (!a[t1]) a[t1] = t2; else if (a[t1] != t2) &#123; cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; flag = 1; break; &#125; if (!b[t2]) b[t2] = t1; else if (b[t2] != t1) &#123; cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; flag = 1; break; &#125; //å¤è¯»ï¼ŒåŒå‘å­˜ &#125; if (flag) continue; //ä¸Šé¢breakçš„æ˜¯forï¼Œè¿˜éœ€è¦ä¸€ä¸ªcontinueï¼Œæ™•äº† int ai, bi = 0; int cnt = 0; for (int i = 1; i &lt;= 26; i++) &#123; if (a[i] == 0) cnt++, ai = i; if (cnt &gt;= 2) continue; &#125; if (cnt == 1) for (int i = 1; i &lt;= 26; i++) if (b[i] == 0) bi = i; if (bi) a[ai] = bi;//25æ¨26 for (int i = 1; i &lt;= 26; i++) &#123; if (a[i] ) &#123; char tmp1, tmp2; tmp1 = i - 1 + &#x27;a&#x27;; tmp2 = a[i] - 1 + &#x27;a&#x27;; cout &lt;&lt; tmp1 &lt;&lt; &quot;-&gt;&quot; &lt;&lt; tmp2 &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; å…¶ä»–é¢˜è«å¾—äº† å¤ªèœäº†","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"ZSTUoj 4433-Suffix Zeroesï¼ˆæš´åŠ›æšä¸¾ï¼‰","slug":"Suffix-Zeroesé¢˜è§£","date":"2019-03-16T13:01:55.000Z","updated":"2021-01-26T16:41:37.760Z","comments":true,"path":"2019/03/16/Suffix-Zeroesé¢˜è§£/","link":"","permalink":"http://example.com/2019/03/16/Suffix-Zeroes%E9%A2%98%E8%A7%A3/","excerpt":"è¿™ä¸¤å¤©å’Œé˜Ÿå‹èŠäº†ä¸€ä¸‹ç†å·¥æ–°ç”Ÿèµ›ï¼Œæåˆ°æˆ‘æš´åŠ›æšä¸¾Aæ‰çš„è¿™é¢˜ï¼Œå¹²è„†æä¸ªé¢˜è§£äº†æ—¶æ•ˆæ€§ç¡®å®æ˜¯ è¿‡äº†","text":"è¿™ä¸¤å¤©å’Œé˜Ÿå‹èŠäº†ä¸€ä¸‹ç†å·¥æ–°ç”Ÿèµ›ï¼Œæåˆ°æˆ‘æš´åŠ›æšä¸¾Aæ‰çš„è¿™é¢˜ï¼Œå¹²è„†æä¸ªé¢˜è§£äº†æ—¶æ•ˆæ€§ç¡®å®æ˜¯ è¿‡äº† é¢˜ç›®ï¼šSuffix Zeroes Descriptionè¿™ä¸ªæ¸¸æˆè¶…ä¼‘é—²çš„~ã€‚ç°åœ¨ä½ éœ€è¦æ‰¾ä¸€ä¸ªè‡ªç„¶æ•°nï¼Œä½ æ‰¾çš„è‡ªç„¶æ•°éœ€è¦æ»¡è¶³n!çš„æœ«å°¾æ°å¥½æœ‰kä¸ª0ï¼ˆå½“ç„¶æˆ‘ä»¬éƒ½æ˜¯åè¿›åˆ¶ä¸‹çš„æ•°ï¼Œn! = 123â€¦nï¼‰ã€‚æ¯”å¦‚ï¼š5ï¼= 120ï¼Œå°¾éƒ¨æ°å¥½æœ‰ä¸€ä¸ª0ã€‚Input å…ˆè¾“å…¥Tï¼Œä»£è¡¨æœ‰Tç»„æ•°æ®ï¼ˆT â‰¤10000ï¼‰æ¥ä¸‹æ¥çš„Tè¡Œæ¯ä¸€è¡Œéƒ½åŒ…æ‹¬ä¸€ä¸ªæ•°å­—kï¼ˆ1â‰¤kâ‰¤108ï¼‰ã€‚å…·ä½“å«ä¹‰è¯·è§é¢˜æ„ã€‚Output å¦‚æœèƒ½æ‰¾åˆ°è¿™æ ·çš„æ•°ï¼Œè¯·è¾“å‡ºæ»¡è¶³æ¡ä»¶çš„æœ€å°çš„è‡ªç„¶æ•°nï¼Œå¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è‡ªç„¶æ•°ï¼Œè¯·è¾“å‡ºimpossibleã€‚Sample Input215Sample OutputCase 1: 5Case 2: impossible é¦–å…ˆï¼Œé¢˜ç›®æ„æ€å°±æ˜¯æ‰¾5ï¼ˆ2æ¯”5å¤šå¾ˆå¤šæ‰€ä»¥ä¸å¿…è€ƒè™‘2ï¼‰ï¼Œæœ‰å‡ ä¸ª0å°±æ˜¯æœ‰å‡ ä¸ª5 25ç®—ä¸¤ä¸ª5ï¼Œ50ç®—ä¸¤ä¸ªï¼Œ125ç®—ä¸‰ä¸ª æ‰€ä»¥å¯ä»¥å¾ˆç›´æ¥åœ°å¾—åˆ°ä¸€ä¸ªå¼å­ maxç­‰äº10å…¶å®å·®ä¸å¤šäº†ï¼Œæˆ‘ä¸‹é¢ä»£ç å†™å¾—èŠ±é‡Œèƒ¡å“¨çš„maxæ˜¯ä¸€å¼€å§‹å› ä¸ºtleçš„æ”¹åŠ¨ï¼Œç°åœ¨æƒ³æƒ³å°±10èƒ½æ”¹å˜ä»€ä¹ˆ å†æ•´ç†å¾— å³æœ‰maxè¶Šå¤§ï¼Œansè¶Šæ¥è¿‘4Ã—kï¼ˆç”¨æ˜Ÿå·ä¼šç”¨å¥‡å¥‡æ€ªæ€ªçš„é—®é¢˜æ‰€ä»¥ä¸ç”¨äº†ï¼‰ ç­‰max=10çš„æ—¶å€™ï¼Œ5^maxæ¥è¿‘1e8ï¼Œè¿™ä¸ªæ—¶å€™ansä¹Ÿä¸ä¼šæ¯”4Ã—kå¤§å¤šå°‘ï¼Œæ‰€ä»¥å¯ç›´æ¥æš´åŠ›æšä¸¾ï¼š ACä»£ç 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main() &#123; int T, b = 1, max, d = 1; long k, k1 = 0, flag = 0, ans; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%ld&quot;, &amp;k); printf(&quot;Case %d: &quot;, d++); max = floor(log(k * 5) / log(5)); for (long i = k * 4; i &lt;= k * 4 + 100; i++) &#123; for (int j = 1; j &lt;= max; j++) &#123; b = b * 5; k1 += (i / b); &#125; b = 1; if (k1 == k) &#123; printf(&quot;%ld\\n&quot;, i); flag = 1; break; &#125; k1 = 0; &#125; if (flag == 0) printf(&quot;impossible\\n&quot;); flag = k1 = 0; &#125; return 0;&#125; ç±»ä¼¼æœ‰ä¸€é¢˜ï¼Œæ˜¯åœ¨HDUçš„HelloWorldç¤¾å›¢çš„æ¯”èµ›ä¸Šï¼ˆä½†æ˜¯è¿™é¢˜è´¼ç®€å•ï¼‰ï¼š é¢˜ç›®2ï¼šè¿™æ˜¯ä¸€é“ç®€å•çš„æ•°å­¦é¢˜ Problem Descriptionâ€œä»Šæ™šä½ ä¼šæˆä¸ºæˆ‘çš„äººï¼â€ç”µè§†é‡Œä¼ å‡ºè¿™æ ·çš„å£°éŸ³ï¼Œå°æ˜å’Œå°çº¢æ‰§æ‰‹ç›¸çœ‹ï¼Œå«æƒ…è„‰è„‰ï¼Œå››ç›®ç›¸å¯¹ã€‚å°çº¢çº¢ç€è„¸ï¼šâ€œä½ çˆ±æˆ‘å—ï¼Ÿâ€å°æ˜ï¼šâ€œå½“ç„¶ï¼â€å°çº¢ï¼šâ€œé‚£ä½ èƒ½å‘Šè¯‰æˆ‘ä½ æœ‰å¤šå°‘ä¸ªå‰å¥³å‹å—ï¼Ÿâ€å°æ˜ï¼šâ€œåˆ«é—®ï¼Œé—®å°±çˆ†ç‚¸ã€‚â€å°çº¢ï¼šâ€œè€å¨˜ç»™ä½ è„¸äº†ï¼Œè¯´ï¼ï¼ï¼â€å°æ˜è„‘è¡¥ç€è¯¥è¯´æœ‰å‡ ä¸ªæ¯”è¾ƒåˆé€‚ï¼Œä»–çŸ¥é“å°çº¢æœ‰ä¸ªä¹ æƒ¯ï¼Œå°±æ˜¯ç‰¹åˆ«å–œæ¬¢ä¸æ–­é‡å¤è®¡ç®—nâˆ—nâˆ—né‡Œæœ‰å¤šå°‘ä¸ª9ï¼Œäºæ˜¯ï¼Œä»–å¼€å§‹ä¸æ–­æšä¸¾nï¼Œä»¥ä¾¿è®©å°çº¢æ²‰è¿·äºè®¡ç®—ï¼Œè€Œä¸è¿½ç©¶ã€‚å°çº¢å¯¹äºné‡Œæœ‰å¤šå°‘ä¸ª9çš„å®šä¹‰ï¼šä»1åˆ°nçš„æ¯ä¸€ä¸ªæ•°èƒ½æ•´é™¤9çš„æ¬¡æ•°ç›¸åŠ ï¼Œå¦‚ï¼š9é‡Œæœ‰ä¸€ä¸ª9ï¼ˆ9/9ï¼‰ï¼Œ18é‡Œæœ‰ä¸¤ä¸ª9ï¼ˆ9/9ï¼Œ18/9ï¼‰ï¼Œ81é‡Œæœ‰10ä¸ª9ï¼ˆ9/9ï¼Œ18/9ï¼Œ27/9ï¼Œ36/9ï¼Œ45/9ï¼Œ54/9ï¼Œ63/9ï¼Œ72/9ï¼Œ81/9/9ï¼‰Inputå¤šç»„æµ‹è¯•æ•°æ®ï¼Œæ¯ç»„å ä¸€è¡Œã€‚æ¯è¡Œä¸€ä¸ªnï¼ˆ1&lt;=n&lt;=100000ï¼‰Outputæ¯è¡Œè¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºnâˆ—nâˆ—nä¸­æœ‰å¤šå°‘ä¸ª9Sample Input134Sample Output037 ACä»£ç 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;int main() &#123; long n; long long c, a = 1,ans=0; while (~scanf(&quot;%ld&quot;, &amp;n)) &#123; c = pow(n, 3); for (int i = 1; i &lt; 18; i++) &#123; a *= 9; ans = ans + (c / a); &#125; printf(&quot;%lld\\n&quot;, ans); a = 1; ans = 0; &#125; return 0;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"zstuoj","slug":"zstuoj","permalink":"http://example.com/tags/zstuoj/"}]},{"title":"noipæ¨¡æ‹Ÿ-ç¡®å®šçš„ä½ç½®ï¼ˆmap + vectorï¼‰","slug":"ç¡®å®šçš„ä½ç½®-é¢˜è§£","date":"2019-03-16T03:19:23.000Z","updated":"2021-01-26T16:43:25.834Z","comments":true,"path":"2019/03/16/ç¡®å®šçš„ä½ç½®-é¢˜è§£/","link":"","permalink":"http://example.com/2019/03/16/%E7%A1%AE%E5%AE%9A%E7%9A%84%E4%BD%8D%E7%BD%AE-%E9%A2%98%E8%A7%A3/","excerpt":"æƒ³æ¸…æ¥šäº†å°±ä¸éš¾è¿™é¢˜è¿˜æ˜¯åœ¨cç¨‹ä¸Šæœºè¯¾çš„æ—¶å€™aæ‰çš„","text":"æƒ³æ¸…æ¥šäº†å°±ä¸éš¾è¿™é¢˜è¿˜æ˜¯åœ¨cç¨‹ä¸Šæœºè¯¾çš„æ—¶å€™aæ‰çš„ è¿˜æ˜¯aaaå’Œvvçš„å‘½åï¼Œæœ¬å®¶ç‹¬åˆ›è¿˜æ˜¯åªä¼šä¸¾ä¾‹è®ºè¯ï¼Œwztcl é¢˜ç›®ï¼šç¡®å®šçš„ä½ç½® æè¿°hzyå¾ˆå–œæ¬¢äº†è§£æ­Œæ›²çš„æ’è¡Œæ¦œï¼Œä»–æ¯æ¬¡éƒ½ä»XXç½‘ç«™è·çŸ¥ã€‚ç”±äºè¿™ä¸ªç½‘ç«™æƒ³å¯¹è¿™ä¸ªæ­Œæ›²çš„æ’è¡Œæ¦œå«è“„çš„å‘Šè¯‰å¤§å®¶ï¼Œç»„ç»‡äº†ä¸€ä¸ªâ€œçŒœæ¦œå¤§èµ›â€ã€‚è¿™ä¸ªç½‘ç«™å®£å¸ƒä¸€äº›æ­Œæ›²çš„ä¿¡æ¯ï¼Œé‚£äº›æ­Œæ›²åœ¨æ­Œæ›²æ¦œä¸Šçš„å‰å‡ åï¼Œä¾‹å¦‚ï¼šÂ·â€qianlizhiwaiâ€ æ˜¯åœ¨æ¦œä¸Šçš„å‰ä¸‰åÂ·â€qianlizhiwaiâ€,â€dachengxiaoaiâ€ æ˜¯åœ¨æ­Œæ›²æ¦œçš„å‰ä¸¤åç½‘ç«™ä¸ä¼šæŠŠæ­Œæ›²çš„åæ¬¡ååˆ†æ˜ç¡®çš„å‘Šè¯‰ä½ ï¼Œä»–å°±æ˜¯æƒ³è®©ä½ é€šè¿‡è¿™äº›ä¿¡æ¯ï¼Œæ¨å‡ºä¸€éƒ¨åˆ†æ­Œæ›²çš„åæ¬¡ï¼Œç°åœ¨å›°æƒ‘çš„hzyæ‰¾æ‚¨å¸®å¿™ï¼Œæƒ³è®©æ‚¨æ¨å‡ºæ‰€æœ‰ç¡®å®šåæ¬¡çš„æ­Œæ›²ã€‚è¾“å…¥ç¬¬ä¸€è¡ŒåŒ…æ‹¬ä¸€ä¸ªæ•´æ•°n, 1â‰¤nâ‰¤500ï¼Œè¡¨ç¤ºç½‘ç«™ç»™ä½ çš„ä¿¡æ¯çš„æ¡æ•°ã€‚ä¸‹é¢nè¡ŒåŒ…æ‹¬ä¸€æ¡ä¿¡æ¯ï¼Œå½¢å¼ä¸ºâ€A and B song1 song2 song3 â€¦ songAâ€,1â‰¤Aâ‰¤Bâ‰¤100ï¼Œè¡¨ç¤ºâ€song1â€,â€song2â€,â€¦,â€songAâ€æ˜¯åœ¨æ­Œæ›²æ¦œçš„å‰Bä½ã€‚æ¯ä¸€é¦–æ­Œéƒ½æ˜¯ä¸€ä¸ªstring,ç”±æœ€å¤š25ä¸ªå°å†™å­—æ¯ç»„æˆã€‚è¾“å‡ºè¾“å‡ºå¯ä»¥çŸ¥é“çš„æ‰€æœ‰çš„æ­Œçš„æ’åï¼Œå½¢å¼:â€Position Songâ€ä½ç½®å¿…é¡»æœ‰åºã€‚è¾“å…¥æ ·ä¾‹ 121 and 3 lonely2 and 2 trebami jasekonjaè¾“å‡ºæ ·ä¾‹ 13 lonelyè¾“å…¥æ ·ä¾‹ 232 and 2 pjesma1 pjesma23 and 4 pjesma1 pjesma3 pjesma41 and 3 pjesma4è¾“å‡ºæ ·ä¾‹ 23 pjesma44 pjesma3 ACä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#define INF 0xfffffffusing namespace std;int n, m, k;int a, b, c, d;int sum, ans, num, cnt[105];string s, sa, sb;map&lt;string, int&gt;aaa;vector&lt;string&gt;vv[105];vector&lt;string&gt;::iterator it;int main() &#123; num = 0; aaa.clear(); for (int i = 1; i &lt; 105; i++) vv[i].clear(); cin &gt;&gt; n; int tmp = INF; while (n--) &#123; cin &gt;&gt; k &gt;&gt; s &gt;&gt; m; while (k--) &#123; cin &gt;&gt; s; if (!aaa[s]) aaa[s] = m, vv[m].push_back(s); else if (aaa[s] &gt; m)&#123; for(it=vv[aaa[s]].begin();it!=vv[aaa[s]].end();) if(*it==s) it=vv[aaa[s]].erase(it); else it++; vv[m].push_back(s); aaa[s] = m; &#125; &#125; &#125; for (int i = 1; i &lt; 105; i++)&#123; num+=vv[i].size(); //æ²¡æœ‰numé‡åˆ°1 1 and 3 lonelyè¿™ç§æƒ…å†µä¼šè¾“å‡º3 lonelyï¼ˆæ­£ç¡®æ˜¯æ²¡æœ‰è¾“å‡ºï¼‰ if (vv[i].size() == 1&amp;&amp;num==i) cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; vv[i][0] &lt;&lt; endl; &#125; return 0;&#125; æ„Ÿè§‰æ²¡ä»€ä¹ˆå¤ªéš¾ç†è§£çš„ä¸å¿…è¦æ‰“ä»€ä¹ˆæ³¨é‡Š= =","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"é˜Ÿå†…è®­ç»ƒ","slug":"é˜Ÿå†…è®­ç»ƒ","permalink":"http://example.com/tags/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%83/"}]},{"title":"éœ‡æƒŠï¼åŸæ¥è¿™å°±æ˜¯ä¸‡æ¶ä¹‹æºï¼","slug":"æ˜¯é¢˜è§£å“¦","date":"2019-03-14T14:11:59.000Z","updated":"2020-03-02T07:19:13.238Z","comments":true,"path":"2019/03/14/æ˜¯é¢˜è§£å“¦/","link":"","permalink":"http://example.com/2019/03/14/%E6%98%AF%E9%A2%98%E8%A7%A3%E5%93%A6/","excerpt":"Gé¢˜æ­£ç¡®ç‡è·Œç ´5%ï¼ŒIDä¸ºHDU8çš„ç”¨æˆ·åˆ·å±æäº¤è®°å½•å››é¡µï¼Œè¿™ä¸€åˆ‡çš„èƒŒåï¼Œåˆ°åº•æ˜¯äººæ€§çš„ç­äº¡ï¼Œè¿˜æ˜¯é“å¾·çš„æ²¦ä¸§â€¦â€¦","text":"Gé¢˜æ­£ç¡®ç‡è·Œç ´5%ï¼ŒIDä¸ºHDU8çš„ç”¨æˆ·åˆ·å±æäº¤è®°å½•å››é¡µï¼Œè¿™ä¸€åˆ‡çš„èƒŒåï¼Œåˆ°åº•æ˜¯äººæ€§çš„ç­äº¡ï¼Œè¿˜æ˜¯é“å¾·çš„æ²¦ä¸§â€¦â€¦ å› ä¸ºè¿™é“é¢˜æ²¡æœ‰å‡ºç°åœ¨é™¤å»æˆ‘ä»¬æ¯”èµ›çš„å…¶ä»–ojé‡Œï¼ˆè‡³å°‘æˆ‘æ²¡æœåˆ°ï¼‰ï¼Œæ¥çœ‹çš„ä¼°è®¡éƒ½æ˜¯ç†Ÿäººï¼Œæˆ‘å°±æ”¾é£è‡ªæˆ‘è¾½ã€‚ è¿™é¢˜æˆ‘äº¤äº†å…­åå¤šæ¬¡â€¦â€¦å¤ªå€”å¼ºäº†ï¼Œæˆ‘ä¸ºè‡ªå·±é¼“é¼“æŒ Aæ‰çš„æ—¶å€™è´¼é«˜å…´ï¼Œæ‰€ä»¥å°±æƒ³æ­ä¸ªåšå®¢ï¼Œæ‰€ä»¥Gé¢˜å°±æ˜¯ä¸‡æ¶ä¹‹æºï¼ˆä¸¥è‚ƒï¼‰ WARNINGï¼šæœ‰ç”¨mapï¼Œmapåå­—å«aaaï¼Œå¯èƒ½å¼•èµ·é˜…è¯»ä¸é€‚ï¼ˆä½†æˆ‘å°±æ˜¯ä¸æ”¹è¿™å¤šæœ‰ç‰¹ç‚¹å•Šï¼‰ï¼›åªä¼šä¸¾ä¾‹è®ºè¯ï¼Œè¯­è¨€é€»è¾‘ä¸å¤ªè¡Œ é¢˜ç›®ï¼šåŒ–å­¦æ–¹ç¨‹å¼ æè¿°102ç­æ¯å¤©è¦å†™åŒ–å­¦æ–¹ç¨‹å¼ï¼Œç°åœ¨è¦æƒ³åŠæ³•æ‰¹æ”¹æ–¹ç¨‹å¼ã€‚æ–¹ç¨‹å¼ä¸­ååº”ç‰©çš„é¡ºåºå¯ä»¥ä¸ä¸€æ ·ï¼Œä¸­é—´å¯ä»¥æœ‰ç©ºæ ¼ã€‚ä¸ä¼šå‡ºç°æ²‰æ·€å’Œæ°”ä½“ç¬¦å·å’Œååº”æ¡ä»¶ã€‚é”™è¯¯æœ‰ç³»æ•°ä¸å¯¹ï¼ˆä¸‹æ ‡ä¸å¯¹ï¼Œå¦‚CO2ä¸ºCO3ä¹Ÿç®—ç³»æ•°ä¸å¯¹ã€‚ååº”ç‰©æˆ–ç”Ÿæˆç‰©ä¸­ä¸ä¼šå‡ºç°å…ƒç´ ç›¸åŒï¼Œç³»æ•°ä¸åŒçš„åŒ–å­¦å¼ï¼Œå¦‚ï¼šCOå’ŒCO2ä¸ä¼šä¸€èµ·å‡ºç°åœ¨ååº”ç‰©æˆ–ç”Ÿæˆç‰©ä¸­ï¼‰ï¼ŒåŒ–å­¦å¼é”™è¯¯ï¼Œç¼ºå°‘ååº”ç‰©ï¼Œä¸¤è¾¹å…ƒç´ ä¸å®ˆæ’ã€‚è¾“å…¥ç¬¬ä¸€æ’è¾“å…¥N,Mç¬¬äºŒæ’è¾“å…¥é•¿åº¦ä¸ºNçš„å­—ç¬¦ä¸²ä¸ºæ­£ç¡®æ–¹ç¨‹å¼ç¬¬ä¸‰æ’è¾“å…¥é•¿åº¦ä¸ºMçš„å­—ç¬¦ä¸²ä¸ºè¦æ‰¹æ”¹æ–¹ç¨‹å¼è¾“å‡ºæ­£ç¡®è¾“å‡ºRIGHTé”™è¯¯ç¬¬ä¸€æ’è¾“å‡ºWRONGï¼Œç¬¬äºŒæ’è¾“å‡ºé”™è¯¯åŸå› ï¼ˆåªç³»æ•°ä¸å¯¹ä¸º1ï¼Œå…¶ä»–é”™è¯¯å’Œæœ‰ä¸¤ä¸ªä»¥ä¸Šé”™è¯¯ä¸º2ï¼‰è¾“å…¥æ ·ä¾‹ 134 292Na O H + H2S O4 = Na 2 S O4+2H2OH2S O4 +2NaO H =Na2 S O4+2H2Oè¾“å‡ºæ ·ä¾‹ 1RIGHTè¾“å…¥æ ·ä¾‹ 234 252Na O H + H2S O4 = Na 2 SO4 +2H2OH2S O4 +NaO H=2H2O +2 K Clè¾“å‡ºæ ·ä¾‹ 2WRONG2 ACä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#define INF 0xfffffffusing namespace std;int n, m, k;int a, b, c, d;int sum, ans, num, cnt;string s, sa, sb;map&lt;string, int&gt;aaa;int main() &#123; cin &gt;&gt; n &gt;&gt; m; getchar(); cnt = 1; aaa.clear(); string s1[100], s2[100]; for (int i = 0; i &lt; 100; i++) s1[i] = &quot;&quot;, s2[i] = &quot;&quot;; while (1) &#123; s = getchar(); if (s == &quot;\\n&quot;) break; else if (s != &quot;+&quot;&amp;&amp;s != &quot;=&quot;&amp;&amp;s != &quot; &quot;) s1[cnt] += s; else if (s == &quot;+&quot;) cnt++; else if (s == &quot;=&quot;) a = cnt, cnt++;//aæ˜¯å­˜ååº”ç‰©å’Œç”Ÿæˆç‰©çš„åˆ†éš” &#125; int tt = cnt; for (int i = 1; i &lt;= cnt; i++) &#123; sa = &quot;&quot;; aaa[s1[i]] = i; for (int j = 0; j &lt; s1[i].length(); j++) if (s1[i][j] &lt;= &#x27;0&#x27;||s1[i][j] &gt;= &#x27;9&#x27;) sa += s1[i][j];//å»æ•°å­— if (!aaa[sa]) aaa[sa] = ++tt;//ç³»æ•°å»æ‰åä¹Ÿå­˜ä¸€ä¸‹ &#125; int cnt2 = 1; int flag = 1;//flagè®¾ç½®ä¸º1æ˜¯å› ä¸ºå…¨å¯¹å…¨é”™éƒ½æ¯”åŠå¯¹å¥½è€ƒè™‘ sum = 0; int p[100]; memset(p, 0, sizeof(p)); while (1) &#123; s = getchar(); if (s == &quot;\\n&quot;) break; else if (s != &quot;+&quot;&amp;&amp;s != &quot;=&quot;&amp;&amp;s != &quot; &quot;) s2[cnt2] += s; else if (s == &quot;+&quot;) cnt2++; else if (s == &quot;=&quot;) b = cnt2, cnt2++; &#125;//å¤è¯»æœº if (cnt2 != cnt) flag = 2;//ä¸€äºŒå¼æ–¹ç¨‹å¼é‡Œç‰©è´¨æ•°ç›®ä¸åŒç›´æ¥é”™ for (int i = 1; i &lt;= cnt2; i++) &#123; sb = &quot;&quot;; if (flag == 2) break; for (int j = 0; j &lt; s2[i].length(); j++) if (s2[i][j] &lt;= &#x27;0&#x27;||s2[i][j] &gt;= &#x27;9&#x27;) sb += s2[i][j]; if (aaa[s2[i]] &amp;&amp; aaa[s2[i]] &lt;= cnt &amp;&amp; !p[aaa[s2[i]]]) sum++, p[aaa[s2[i]]] = 1;//åŒ…å«ç³»æ•°ç‰©è´¨çš„ç›´æ¥æ¯”è¾ƒ å’Œä¸€å¼ä¸€æ ·è®¡æ•°+æ ‡è®° // aaa[s2[i]] &lt;= cntçš„å­˜åœ¨å¿…è¦ï¼šå¦‚ä¸€å¼æ˜¯2HCläºŒå¼æ˜¯HCl // p[aaa[s2[i]]] = 1çš„å­˜åœ¨å¿…è¦ï¼šä¸€å¼CO+CuO=Cu+CO2äºŒå¼CO+CuO=Cu+CO else if (!aaa[sb]) flag = 2;//å»æ‰ç³»æ•°äº†è¿˜æ²¡æœ‰å­˜è¿‡è‚¯å®šæ˜¯é”™çš„äº† if (aaa[s2[i]] &gt; a &amp;&amp; aaa[s2[i]] &lt;= cnt &amp;&amp; i &lt;= b) flag = 2; //åˆ¤æ–­ç”Ÿæˆç‰©å’Œååº”ç‰©æœ‰æ²¡æœ‰è·‘é”™ä½å­ &#125; if (flag == 1 &amp;&amp; sum == cnt) flag = 0; if (!flag) cout &lt;&lt; &quot;RIGHT&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;WRONG&quot; &lt;&lt; endl; if (flag) cout &lt;&lt; flag &lt;&lt; endl; return 0;&#125; å…¶å®è¿™é¢˜èµ°äº†å¥½å¤šå¼¯è·¯ï¼Œæ€ªè‡ªå·±å¤ªçé¢˜ç›®æ²¡çœ‹æ¸…ï¼ˆåæ€ï¼‰ åˆ åˆ æ”¹æ”¹ï¼Œä»äº”å…­ååŠ åŠ åŠ åˆ°ç™¾æ¥è¡Œå†åˆ åˆ åˆ åˆ°ä¸ƒåè¡Œï¼ˆç„¶åå†åŠ åŠ åŠ æ³¨é‡Šï¼‰ è¿™ä¸ªè§£ç³»æ•°ä¸º1ä¸èƒ½åˆ¤æ–­ï¼Œä¸è¿‡è®²é“ç†åŒ–å­¦æ–¹ç¨‹å¼ç³»æ•°ä¸º1ç¡®å®ä¸å†™ CO2å’ŒCO3åªæ˜¯ç³»æ•°é”™äº†èƒ½æŠŠåŒ–å­¦è€å¸ˆæ°”æ­»ï¼ˆä¹ŸæŠŠæˆ‘æ°”æ­»äº†ï¼Œæ‰€ä»¥ä¸€å¼€å§‹æ˜¯å¼€äº†vectorçš„ï¼‰ æ¯”è¾ƒå¸¸è§„è€Œä¸”åˆç¨³çš„è§£æ³•åº”è¯¥æ˜¯å››ä¸ªmap+ä¸€ä¸ªvectorï¼Œé¡¾è€å¸ˆå¥½åƒå°±æ˜¯è¿™æ ·ä¸è¿‡ä»–è¿˜åˆ†äº†å•è´¨å•Šä»€ä¹ˆçš„æˆ‘ä¹Ÿæ²¡ç»†çœ‹= =åæ­£æˆ‘è¿™ä¸ªèƒ½Aå˜»å˜»","categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"é˜Ÿå†…è®­ç»ƒ","slug":"é˜Ÿå†…è®­ç»ƒ","permalink":"http://example.com/tags/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%83/"}]},{"title":"ç›¸ é€¢ å³ æ˜¯ ç¼˜","slug":"ä¸€ä¸ªç½®é¡¶","date":"2019-03-13T09:13:12.000Z","updated":"2021-01-26T11:09:50.281Z","comments":true,"path":"2019/03/13/ä¸€ä¸ªç½®é¡¶/","link":"","permalink":"http://example.com/2019/03/13/%E4%B8%80%E4%B8%AA%E7%BD%AE%E9%A1%B6/","excerpt":"Like the meeting of the seagulls and the waves we meet and come near. The seagulls fly off, the waves roll away and we depart. â€”â€”ã€ŠStray Birdsã€‹Rabindranath Tagore","text":"Like the meeting of the seagulls and the waves we meet and come near. The seagulls fly off, the waves roll away and we depart. â€”â€”ã€ŠStray Birdsã€‹Rabindranath Tagore wz&amp;yx å¹³æ—¶ç”¨çš„idæ˜¯ç¨³èµšï¼ŒHDUå°±è¯»ï¼Œä¸“ä¸šæ˜¯å·¥è®¾ èœé¸¡acmerä¸€ä¸ªï¼Œç§ƒå¤´æ•²ä»£ç ä¸­ HDUACMé›†è®­é˜Ÿåº•å±‚é˜Ÿå‘˜ï¼Œéšæ—¶å¯èƒ½è¢«ç»è´¹è­¦å‘Š Vidar Teamç¾å·¥ï¼Œä½†æ˜¯ä¸ä¼šç”»çœ‹æ¿å¨˜åªä¼šè¡¨æƒ…åŒ…ï¼ˆé€ƒï¼‰ åœˆåæ˜¯ä½™å¿ƒï¼Œç”»ç”»å†™å­—å‰ªçº¸éƒ½ä¼šä¸€ç‚¹ï¼Œå¹³æ—¶ä¸€èˆ¬ææå­—è®¾ ç ”ç©¶ç˜¦é‡‘+åšç˜¦é‡‘ç›¸å…³å­—ä½“ï¼ˆä½†æ˜¯ä¸€ç›´å’•å’•å’•ï¼‰ åœ¨æ­å·çš„graffitiæ´»åŠ¨è¯·ï¼å«ï¼ä¸Šï¼æˆ‘ï¼ ç›®å‰ä½äº100rçš„ç¨¿å­ä¸æ¥ï¼ˆç†ç›´æ°”å£®ï¼‰ åˆå¿ƒ æˆ‘ä¸¤å‘¨å‰è¿˜è¯´ä¸æƒ³æåšå®¢ï¼Œé£å¿«çœŸé¦™ æè¿™ä¸ªåšå®¢çš„å¥‘æœºæ˜¯å†™äº†ä¸€ä¸ªé¢˜æ„Ÿè§‰è‡ªå·±tqlæƒ³å†æä¸ªé¢˜è§£ åº”è¯¥ä»¥åå°±ä¼šå¼€å§‹åšé¢˜è§£å’Œå‘ä½œå“ ä¸€æ˜¯å¯¹è‡ªå·±æˆé•¿çš„ä¸€ä¸ªçºªå¿µå§ äºŒæ˜¯ç£ä¿ƒè‡ªå·±å¥½å¥½å†™é¢˜å¥½å¥½ç”»ç”» ä¸‰æ˜¯å¸Œæœ›æ›´å¤šäººçœ‹åˆ°è¿™ä¹ˆä¼˜ç§€çš„æˆ‘ è®¸å‡ ä¸ªæ„¿ æœ€å¸Œæœ›8è¦è¢«ç»è´¹è­¦å‘Š ç„¶åå¸Œæœ›åœ¨2020èƒ½æŠŠå®‹é‡‘ä½“ï¼ˆåå­—æš‚å®šï¼‰åšå‡ºæ¥ æ¸…é¹¤ä¸æ€¥åšè¾½ï¼ç­‰æˆ‘æœ‰æ—¶é—´äº†æ…¢æ…¢å†å»ç ”ç©¶å§233 æ²¡è¾½ï¼å¤ªè´ªå¿ƒ8å¥½","categories":[{"name":"w&y","slug":"w-y","permalink":"http://example.com/categories/w-y/"}],"tags":[{"name":"éšç¬”","slug":"éšç¬”","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"w","slug":"w","permalink":"http://example.com/categories/w/"},{"name":"w&y","slug":"w-y","permalink":"http://example.com/categories/w-y/"},{"name":"y","slug":"y","permalink":"http://example.com/categories/y/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"é¢è¯•","slug":"é¢è¯•","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"éšç¬”","slug":"éšç¬”","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"ç´ æ","slug":"ç´ æ","permalink":"http://example.com/tags/%E7%B4%A0%E6%9D%90/"},{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"},{"name":"pintia","slug":"pintia","permalink":"http://example.com/tags/pintia/"},{"name":"hdoj","slug":"hdoj","permalink":"http://example.com/tags/hdoj/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"},{"name":"æ¿å­","slug":"æ¿å­","permalink":"http://example.com/tags/%E6%9D%BF%E5%AD%90/"},{"name":"design","slug":"design","permalink":"http://example.com/tags/design/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"zstuoj","slug":"zstuoj","permalink":"http://example.com/tags/zstuoj/"},{"name":"é˜Ÿå†…è®­ç»ƒ","slug":"é˜Ÿå†…è®­ç»ƒ","permalink":"http://example.com/tags/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%83/"}]}