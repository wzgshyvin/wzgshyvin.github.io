{"meta":{"title":"V1n","subtitle":"","description":"I have suffered and despaired and known death and I am glad that I am in this great world.","author":"V1n","url":"http://wzgshyvin.github.io","root":"/"},"pages":[{"title":"Friends","date":"2019-03-18T03:34:17.000Z","updated":"2021-01-26T11:24:10.683Z","comments":true,"path":"Friends/index.html","permalink":"http://wzgshyvin.github.io/Friends/index.html","excerpt":"","text":"结缘于ACMArya_Erin 玥玥Axiomofchoice hjt 永远滴神BearChild 天天CallmeChallenger 爬爬Chenboluo ct 前队友Chenfu1234 飞飞Codgician 张学长Colin 金牌学弟Culaccino cby 前队友Dddfaker 丁狗DeaphetS 叉哥Dreaming2019 小彭Edwiv 郑老师EricXia 夏宝Garvey 陆老师ILLLZKQF 施巨Jiedai 汤汤Kaizyn 凯凯K0u1e 燕宝MaJorieL 小任 我滴宝REXWind 小施Tommy1123 辣宝UniverseofHK 吉老师V4yne 彭老师Willingox 刘老师Zarathu 尹宝 来自Vidar-Team357 WebAnnevi WebBrownFly 飞哥Cosmos 阿C PwnCyris cy学长 Web 前端 美工Danis Jiang 蒋公子 BinE99p1ant 199 WebFeather 语宝Fl0a1e 峥宝Kevin Web 前端Matrix BinObjectNotFound MiscOyiadin oyyRin1ang 盛宝 WebRosetta 鱼宝Y 歪宝 Re 其他朋友AYang 小老弟Caesar BaoXiaoyuyu 楼哥"},{"title":"About","date":"2019-03-15T16:44:19.000Z","updated":"2019-03-20T16:14:48.000Z","comments":true,"path":"about/index.html","permalink":"http://wzgshyvin.github.io/about/index.html","excerpt":"","text":"Man goes into the noisy crowd to drown his own clamour of silence. ——《Stray Birds》"},{"title":"tags","date":"2019-03-16T02:27:12.000Z","updated":"2019-03-16T13:00:52.000Z","comments":true,"path":"tags/index.html","permalink":"http://wzgshyvin.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-16T02:26:48.000Z","updated":"2019-03-16T02:34:46.000Z","comments":true,"path":"categories/index.html","permalink":"http://wzgshyvin.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"各种排序学习笔记","slug":"各种排序学习","date":"2021-01-27T07:11:59.000Z","updated":"2021-01-26T16:45:44.428Z","comments":true,"path":"2021/01/27/各种排序学习/","link":"","permalink":"http://wzgshyvin.github.io/2021/01/27/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/","excerpt":"因为学了冒泡后就会用 sort 了，完全没有学过各种排序，第一次面试因为不会手写快排 GG ，痛定思痛，决定认真写篇学习博客 QAQ","text":"因为学了冒泡后就会用 sort 了，完全没有学过各种排序，第一次面试因为不会手写快排 GG ，痛定思痛，决定认真写篇学习博客 QAQ 冒泡排序时间复杂度 $O(n^2)$ ，空间复杂度 $O(1)$ ，不断 swap 把大的排到后面，咕噜咕噜冒泡泡 123456789101112void BubbleSort(int *a,int len)&#123; for(int i=1;i&lt;len;++i)&#123; int ff(0); for(int j=0;j&lt;len-i;++j)&#123; if(a[j]&gt;a[j+1])&#123; swap(a[j],a[j+1]); ff++; &#125; &#125; if(!ff) break; // 小剪枝 &#125;&#125; 插入排序时间复杂度 $O(n^2)$ ，空间复杂度 $O(1)$ ，每次将新元素插入已排序的数组中。 12345void InsertSort(int *a,int len)&#123; for(int i=1;i&lt;len;++i) for(int j=i;j&gt;0;--j) if(a[j]&lt;a[j-1]) swap(a[j],a[j-1]);&#125; 选择排序时间复杂度 $O(n^2)$ ，空间复杂度 $O(1)$ ，每次将最值放在当前可操作的首位。 12345678void SelectSort(int *a,int len)&#123; for(int i=0;i&lt;len;++i)&#123; int mn=i; for(int j=i+1;j&lt;len;++j) if(a[j]&lt;a[mn]) mn=j; swap(a[i],a[mn]); &#125;&#125; 归并排序时间复杂度 $O(nlogn)$ ，空间复杂度 $O(n)$ ，递归，每次将要排序的子数组分成两个部分排序。 1234567891011121314151617void MergeSort(int *a,int l,int r)&#123; if(l&gt;=r) return; int mid=l+r&gt;&gt;1; MergeSort(a,l,mid); MergeSort(a,mid+1,r); int i=l,j=mid+1,tlen=l,tmp[maxn]; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(a[i]&lt;=a[j]) tmp[tlen++]=a[i++]; else tmp[tlen++]=a[j++]; &#125; while(i&lt;=mid) tmp[tlen++]=a[i++]; while(j&lt;=r) tmp[tlen++]=a[j++]; for(int i=l;i&lt;=r;++i) a[i]=tmp[i];&#125;void solve()&#123; MergeSort(a,0,len-1); &#125; 快速排序时间复杂度 $O(nlogn)$ ，空间复杂度 $O(logn)$ ，每次找一个比较合适的 pivot ，根据这个值对数组进行调整。 123456789101112131415161718192021int findmiddle(int a,int b,int c)&#123; int tmp=a^b^c; int mx=max(&#123;a,b,c&#125;); int mn=min(&#123;a,b,c&#125;); return tmp^mx^mn;&#125;void QuickSortAdjust(int *a,int l,int r)&#123; if(l&gt;=r) return; int pivot=findmiddle(a[l],a[r],a[l+r&gt;&gt;1]); int i=l,j=r; while(i&lt;=j)&#123; while(i&lt;=j&amp;&amp;a[i]&lt;pivot) i++; while(i&lt;=j&amp;&amp;a[j]&gt;pivot) j--; if(i&lt;=j) swap(a[i++],a[j--]); &#125; QuickSortAdjust(a,l,j); QuickSortAdjust(a,i,r);&#125;void QuickSort(int *a,int len)&#123; QuickSortAdjust(a,0,len-1);&#125; 堆排序时间复杂度 $O(nlogn)$ ，空间复杂度 $O(1)$ ，每次对无序的子数组进行堆调整，将最值置于堆顶，然后把最值移到数组末尾，再对剩下的子数组进行操作。 1234567891011121314151617181920212223242526272829303132void HeapAdjust(int *a,int len)&#123; for(int i=len-1;i&gt;0;--i)&#123; if((i&amp;1)&amp;&amp;(a[i]&gt;a[i/2])) swap(a[i],a[i/2]); else if(!(i&amp;1)&amp;&amp;(a[i]&gt;a[i/2-1])) swap(a[i],a[i/2-1]); &#125;&#125;void HeapSort(int *a,int len)&#123; while(len)&#123; HeapAdjust(a,len--); swap(a[0],a[len]); &#125;&#125;// 加速版void _HeapAdjust(int *a,int x,int len)&#123; int fa=x,son=(fa&lt;&lt;1)|1; while(son&lt;len)&#123; if(son+1&lt;len&amp;&amp;a[son]&lt;a[son+1]) son++; // 哪个小孩 if(a[fa]&gt;=a[son]) break; swap(a[fa],a[son]); fa=son; son=(fa&lt;&lt;1)|1; &#125;&#125;void _HeapSort(int *a,int len)&#123; for(int i=(len&gt;&gt;1)-1;i&gt;=0;--i) _HeapAdjust(a,i,len); for(int i=len-1;i&gt;=0;--i)&#123; swap(a[0],a[i]); _HeapAdjust(a,0,i); &#125;&#125; 桶排序时间复杂度 $O(n+k)$ ，空间复杂度 $O(n+k)$ ，将元素放进桶里，按桶的大小取出。 12345678910void BucketSort(int *a,int len)&#123; int vis[maxn]=&#123;0&#125;; // 值域 for(int i=0;i&lt;len;++i)&#123; vis[a[i]]++; &#125; int cnt(0); for(int i=0;i&lt;maxn;++i)&#123; while(vis[i]) vis[i]--,a[cnt++]=i; &#125;&#125; 基数排序时间复杂度 $O(n*k)$ ，空间复杂度 $O(n+k)$ 。两种：一种（LSD）从低位到高位放进桶里（每次 10 个）。一种（MSD）从高位到低位放进桶里，一位处理完后，直接在当前桶里分下一位的类。复杂度略高而且代码过长，感觉能嘴就行 233","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://wzgshyvin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"http://wzgshyvin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"2020 Multi-University Training Contest 10","slug":"杭电 (10)","date":"2020-08-20T14:22:22.000Z","updated":"2021-02-22T18:55:45.163Z","comments":true,"path":"2020/08/20/杭电 (10)/","link":"","permalink":"http://wzgshyvin.github.io/2020/08/20/%E6%9D%AD%E7%94%B5%20(10)/","excerpt":"8.20 并不是一个好收尾的杭电10","text":"8.20 并不是一个好收尾的杭电10 1004-Permutation Counting题意 给定 $n-1$ 长度的 $01$ 关系数组，$0$ 和 $1$ 代表原数组中当前位和前一位的大小关系。问有多少种符合条件的原数组方案。 代码 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;const int mod = 1e9 + 7;int dp[2][5005];int solve()&#123; mst(dp,0); dp[0][1]=1; int n,ff(0); sc(n); rep(i,1,n)&#123; int x,res(0); sc(x); ff^=1; if(x)&#123; dp[ff][1]=0; rep(j,1,i+1)&#123; res+=dp[ff^1][j]; if(res&gt;=mod) res-=mod; dp[ff][j+1]=res; &#125; &#125; else&#123; dp[ff][i+1]=0; dep(j,i,1)&#123; res+=dp[ff^1][j]; if(res&gt;=mod) res-=mod; dp[ff][j]=res; &#125; &#125; &#125; int ans(0); rep(i,1,n+1)&#123; ans+=dp[ff][i]; if(ans&gt;=mod) ans-=mod; &#125; return pf(&quot;%d\\n&quot;,ans); &#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1010-Tic-Tac-Toe-Nim题意 给定 $3*3$ 的石子堆，$a$ 、$b$ 两人轮流拿石子，每人的第一轮必须整堆拿走，其余任意。问先手有几种取法能保证必胜。 思路 枚举 $a$ 第一步取的点，再枚举 $b$ 第一步能取的剩下 $4$ 个点。如果有 $b$ 能赢的状态就不计数。 最优局势到最后一定是除了三个横纵坐标各不相同的点为 $0$ 外其他全是 $1$ 。这时候再两步就一定走到结局。所以枚举 $a$ 、$b$ 初始点后，异或第三个能取到 $0$ 的点的值和其他点的值 $-1$ 。为 $0$ 的话 $b$ 胜利。 代码 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;int p[5][5],q[5][5];int cal(int a,int b,int c,int d)&#123; int cnt(0); rep(i,1,4) rep(j,1,4)&#123; if(i==a&amp;&amp;j==b||i==c&amp;&amp;j==d) continue; if(i!=a&amp;&amp;i!=c&amp;&amp;j!=b&amp;&amp;j!=d)&#123; cnt^=q[i][j]; continue; &#125; cnt^=q[i][j]-1; &#125; return cnt;&#125;int solve()&#123; rep(i,1,4) rep(j,1,4) sc(p[i][j]),q[i][j]=p[i][j]; int ans(0); rep(i,1,4) rep(j,1,4)&#123; q[i][j]=0; int ff(0); rep(k,1,4) rep(l,1,4)&#123; if(k==i||l==j) continue; q[k][l]=0; int t=cal(i,j,k,l); ff+=(t&gt;0); q[k][l]=p[k][l]; &#125; if(ff==4) ans++; q[i][j]=p[i][j]; &#125; return pf(&quot;%d\\n&quot;,ans);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1011-Task Scheduler题意 有 $n$ 个任务，每个任务需要 $t_i$ 个人完成。公司一共有 $m$ 个员工，其中有 $k$ 个掉线。随机安排在当前没任务的员工分配任务，随机到掉线的员工就重新分配直到分配完成。问如何安排任务顺序可以使分配次数的期望最少，如果有多个方案输出其中字典序最小的。 思路 特判 + $sort$ ，就这是第三简单？？？ 代码 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;typedef pair&lt;int,int&gt; pii;pii p[105];int cmp(pii a,pii b)&#123; return (a.first==b.first&amp;&amp;a.second&lt;b.second)||a.first&gt;b.first;&#125;int solve()&#123; int n,m,k; sc(n); sc(m); sc(k); rep(i,1,n+1) sc(p[i].first),p[i].second=i; sort(p+1,p+n+1,cmp); if(!k)&#123; rep(i,1,n+1) pf(&quot;%d%c&quot;,i,&quot; \\n&quot;[i==n]); return 0; &#125; rep(i,1,n+1) pf(&quot;%d%c&quot;,p[i].second,&quot; \\n&quot;[i==n]); return 0;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"HDOJ","slug":"HDOJ","permalink":"http://wzgshyvin.github.io/tags/HDOJ/"}]},{"title":"2020 Multi-University Training Contest 9","slug":"杭电 (9)","date":"2020-08-18T14:22:22.000Z","updated":"2021-02-22T18:55:24.383Z","comments":true,"path":"2020/08/18/杭电 (9)/","link":"","permalink":"http://wzgshyvin.github.io/2020/08/18/%E6%9D%AD%E7%94%B5%20(9)/","excerpt":"8.18 自闭但是成绩还可以的杭电9","text":"8.18 自闭但是成绩还可以的杭电9 1001-Tree题意 给定一棵根节点为 $1$ 、顶点数为 $n$ 的树，在树上只能从父节点到达子节点。问加上一条边后最大可达的点对数。 思路 很气，为啥不是贪心啊（因为小转菜啊） 最优解一定是某个叶节点连回根。在叶节点到根的这条链上每个点都有 $n-sz$ 的贡献，其中 $sz$ 指的是这个节点的子树大小。 直接暴力 $dfs$ 回去找最大值。 代码 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;typedef long long ll;const int maxn = 5e5 + 5;ll ans,qaq,sz[maxn];vector&lt;int&gt;vv[maxn];void dfs(int x)&#123; for(int y:vv[x]) dfs(y),sz[x]+=sz[y]; ans+=sz[x]; &#125;void dfss(int n,int x,ll t)&#123; t+=n-sz[x]; qaq=max(qaq,t); for(int y:vv[x]) dfss(n,y,t);&#125;int solve()&#123; ans=0; qaq=0; vv[1].clear(); sz[1]=1; int n,x; sc(n); rep(i,2,n+1)&#123; vv[i].clear(); sz[i]=1; sc(x); vv[x].push_back(i); &#125; dfs(1); dfss(n,1,0); ans+=qaq; return pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1003-Slime and Stones题意 两堆物品 $a$ 、$b$ 两人轮流取物，一次只能在一堆取任意数量物品（大于 $0$ ）或是两堆取相差不超过 $k$ 的物品。问先手胜负情况。 思路 对着威佐夫博弈嗯猜（猜着猜着样例过了这你不冲？） 代码 123456789101112131415#include&lt;bits/stdc++.h&gt;#define scl(x) scanf(&quot;%lld&quot;, &amp;x)using namespace std;typedef long long ll;int solve()&#123; ll a,b,k; scl(a); scl(b); scl(k); if(a&gt;b) swap(a,b); ll r=(b-a)%(k+1); if(r) return puts(&quot;1&quot;); long double t=(1.0-k+sqrt(1ll*(k+1)*(k+1)+4.0))/2.0; ll q=(b-a)/(k+1); q=(ll)q*t; return puts(q==a?&quot;0&quot;:&quot;1&quot;);&#125;int main()&#123; ll _; scl(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"HDOJ","slug":"HDOJ","permalink":"http://wzgshyvin.github.io/tags/HDOJ/"}]},{"title":"2020 Multi-University Training Contest 8","slug":"杭电 (8)","date":"2020-08-13T14:22:22.000Z","updated":"2021-02-22T18:50:02.814Z","comments":true,"path":"2020/08/13/杭电 (8)/","link":"","permalink":"http://wzgshyvin.github.io/2020/08/13/%E6%9D%AD%E7%94%B5%20(8)/","excerpt":"8.13 愉快且排名新高的杭电8","text":"8.13 愉快且排名新高的杭电8 1002-Breaking Down News题意 给定长度为 $n$ 的数组 $a$ ，对于任意 $i$ 都有 $-1\\leq a_i\\leq 1$ 。想要将 $a$ 划分做若干块使得每块总和的 $sgn$ 和最大，每块的长度需要满足 $l\\leq len\\leq r$ 。 思路 由于 $dp_i$ 只能从 $dp_{i-r}-dp_{i-l}$ 转移过来，所以记录前缀和每次求区间最值。参考别人代码用 $multiset$ 和 $lowerbound$ ，怪好看的233 代码 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;int a[maxn],q[maxn];multiset&lt;pii&gt;s;int sgn(int x)&#123; return x&lt;0?-1:(x&gt;0); &#125;int solve()&#123; int n,l,r; sc(n); sc(l); sc(r); s.clear(); rep(i,1,n+1) sc(a[i]),a[i]+=a[i-1]; rep(i,1,l) q[i]=-n; rep(i,l,n+1)&#123; s.insert(&#123;q[i-l],-a[i-l]&#125;); pii t=*--s.end(); q[i]=t.first+sgn(a[i]+t.second); multiset&lt;pii&gt;::iterator it; it=s.lower_bound(&#123;t.first,-n&#125;); if(it!=s.begin())&#123; t=*--it; q[i]=max(q[i],t.first+sgn(a[i]+t.second)); &#125; if(r&lt;=i) s.erase(s.find(&#123;q[i-r],-a[i-r]&#125;)); &#125; return pf(&quot;%d\\n&quot;,q[n]);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1003-Clockwise or Counterclockwise题意 给定在以原点为圆心的圆上三个点。问这三个点是顺时针还是逆时针。 思路 套了个求多边形面积的板子，判面积正负就过了。 代码 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;typedef long long ll;struct point&#123; ll x,y; &#125;p[5];__int128 parea(point p[],int n)&#123; if(n&lt;3) return 0; __int128 ans=0; p[n]=p[0]; rep(i,0,n) ans+=p[i].x*p[i+1].y-p[i+1].x*p[i].y; return ans/2;&#125;int solve()&#123; rep(i,0,3) scl(p[i].x),scl(p[i].y); __int128 s=parea(p,3); return puts(s&lt;0?&quot;Clockwise&quot;:&quot;Counterclockwise&quot;);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1006-Fluctuation Limit题意 给定 $n$ 段限制，问能否找到可以满足每段限制的方案，方案之间差值最大为 $k$ 。 思路 因为不会 $dp$ 直接考虑贪心（确实不是 $dp$ ）。求出每段满足题意的 $l$ 、$r$ ，最后倒推回去。 代码 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;typedef long long ll;const int maxn = 1e5 + 5;ll a[maxn],b[maxn],c[maxn],l[maxn],r[maxn];int solve()&#123; int n,ff(0); ll k; sc(n); scl(k); l[0]=-1e18,r[0]=1e18; rep(i,1,n+1)&#123; scl(a[i]),scl(b[i]); l[i]=max(a[i],l[i-1]-k); r[i]=min(b[i],r[i-1]+k); if(l[i]&gt;r[i]) ff++; &#125; if(ff) return pf(&quot;NO\\n&quot;); pf(&quot;YES\\n&quot;); c[n]=l[n]; ll lt=l[n],rt=l[n]; dep(i,n-1,1)&#123; lt=max(lt-k,l[i]); rt=min(rt+k,r[i]); c[i]=lt+rt&gt;&gt;1; &#125; rep(i,1,n+1) pf(&quot;%lld%c&quot;,c[i],&quot; \\n&quot;[i==n]); return 0;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1008-Hexacppn题意 给定半径为 $n$ 的六边形网格图，可以任意选择起点，问不重复地走满全部网格且转弯最多的路径方案。 思路 团体智慧的聚集，小转画图，小庄造数据，小潘找规律写代码 分奇数和偶数进行分析 偶数时，直接从左上角开始从外到内的绕圈，最后会正好绕完 奇数时，可以视为前一个半径 $(r - 2)$ 的图外面再多绕一圈，绕法与偶数相同 写的时候就先把半径为 $3$ 和 $4$ 的结果写好，完事拿着前一个绕就行了，节省时间可以打个不同位置的表来绕 嗯，花花大法好 奇数情况： 1009-Isomorphic Strings题意 给定串 $s$ ，问能否均等地划分成 $k$ 份，使得每份互为循环同构。 思路 备注：理论复杂度不低，但是很难卡满，$O(能过)$ ，甚至没到 $1s$ 枚举每个因数，对每个因数 $check$ 。 求出第一块的哈希值，之后每块和第一块的对比。如果和第一块不同就枚举循环同构，递推求循环同构的哈希值，具体是 $(hash-a[pos_{now}]*bas[len-1])*seed+a[pos_{now}]$ 。找到就 $break$ ，所有循环同构都不满足就 $return$ 。 upd：wcy学号就是个除了吉利一无是处的花瓶（ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;const int maxn = 5e6 + 5;const int mod = 998244353;char s[maxn]; int n;int seed[2]=&#123;*,18271131&#125;;// 嘿嘿第一个模数不给看了 谢谢wcy学号int hs[2][maxn],bas[2][maxn];void init()&#123; bas[0][0]=bas[1][0]=1; rep(j,0,2) rep(i,1,n+1)&#123; bas[j][i]=1ll*bas[j][i-1]*seed[j]%mod; hs[j][i]=1ll*hs[j][i-1]*seed[j]%mod+s[i]-&#x27;a&#x27;+1; if(hs[j][i]&gt;=mod) hs[j][i]-=mod; &#125; &#125;int getsum(int j,int l,int r)&#123; int res=hs[j][r]-1ll*hs[j][l-1]*bas[j][r-l+1]%mod; if(res&lt;0) res+=mod; return res;&#125;int check(int x)&#123; int len=n/x,q[2]; q[0]=getsum(0,1,len); q[1]=getsum(1,1,len); rep(i,2,x+1)&#123; int l=(i-1)*len+1,r=i*len,ff(0); int p[2]; rep(j,0,2) p[j]=getsum(j,l,r); if(p[0]==q[0]&amp;&amp;p[1]==q[1]) continue; rep(k,1,len)&#123; rep(j,0,2)&#123; int ind=(i-1)*len+k; int sub=1ll*(s[ind]-&#x27;a&#x27;+1)*bas[j][len-1]%mod; p[j]=1ll*(1ll*p[j]-sub+mod)%mod*seed[j]%mod+s[ind]-&#x27;a&#x27;+1; if(p[j]&gt;=mod) p[j]-=mod; &#125; if(p[0]==q[0]&amp;&amp;p[1]==q[1])&#123; ff++; break; &#125; &#125; if(!ff) return 0; &#125; return 1;&#125;int solve()&#123; sc(n); scs(s+1); init(); for(int i=1;i*i&lt;=n;++i) if(n%i==0)&#123; if(i!=1) if(check(i)) return puts(&quot;Yes&quot;); if(i*i!=n) if(check(n/i)) return puts(&quot;Yes&quot;); &#125; return puts(&quot;No&quot;);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1011-Kidnapper’s Matching Problem题意 给定长度分别为 $n$ 、$m$ 的 $a$ 、$b$ 数组，再给定数量为 $k$ 的集合 $S$ 。对于 $S$ ，定义 $2_{\\oplus}^S$ 为 $S$ 所有子集的异或和集合。问有多少 $a$ 的长度为 $m$ 、起点为 $l$ 的连续子数组满足任意 $1\\leq i\\leq m$ 有 $a_{l+i-1}\\oplus b_i \\in 2_{\\oplus}^S$ 。 思路 出题人：名字就暗示是 $kmp$ 了 求出线性基后将 $a$ 、$b$ 筛掉，剩下不能用线性基表示的部分仅当 $a$ 、$b$ 相等时可以消去，所以用剩下部分跑一遍 $kmp$ 求匹配数即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;const int maxn = 2e5 + 5;const int mod = 1e9 + 7; int a[maxn],b[maxn],s[maxn];int qpow(int a,int b)&#123; int ans=1; while(b&gt;0)&#123; if(b&amp;1) ans=1ll*ans*a%mod; b&gt;&gt;=1; a=1ll*a*a%mod; &#125; return ans;&#125;int nex[maxn];void getnext(int* s,int len)&#123; int i=0,j=-1/* ,len=strlen(s) */; nex[0]=-1; while(i&lt;len)&#123; if(j==-1||s[i]==s[j])&#123; i++; j++; nex[i]=j; &#125; else j=nex[j]; &#125;&#125;int kmp(int *s1,int *s2,int len1,int len2)&#123; int i=0,j=0,ans(0); getnext(s2,len2); // int len1=strlen(s1),len2=strlen(s2); while(i&lt;len1&amp;&amp;j&lt;len2)&#123; if(j==-1||s1[i]==s2[j])&#123; i++; j++; &#125; else j=nex[j]; if(j==len2)&#123; ans+=qpow(2,i-len2); if(ans&gt;=mod) ans-=mod; j=nex[j]; &#125; &#125; return ans;&#125;int d[32];void insert(int x)&#123; dep(i,30,0) if((x&gt;&gt;i)&amp;1)&#123; if(!d[i])&#123; d[i]=x; return; &#125; else x^=d[i]; &#125;&#125;void slove(int *s,int len)&#123; rep(i,0,len) dep(j,30,0) if(d[j]&amp;&amp;((s[i]&gt;&gt;j)&amp;1)) s[i]^=d[j];&#125;int solve()&#123; int n,m,k,x; mst(d,0); sc(n),sc(m),sc(k); rep(i,1,n+1) sc(a[i]); rep(i,1,m+1) sc(b[i]); rep(i,1,k+1) sc(x),insert(x); slove(a+1,n); slove(b+1,m); return pf(&quot;%d\\n&quot;,kmp(a+1,b+1,n,m));&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"HDOJ","slug":"HDOJ","permalink":"http://wzgshyvin.github.io/tags/HDOJ/"}]},{"title":"2020 Multi-University Training Contest 7","slug":"杭电 (7)","date":"2020-08-11T14:22:22.000Z","updated":"2021-02-22T18:57:31.851Z","comments":true,"path":"2020/08/11/杭电 (7)/","link":"","permalink":"http://wzgshyvin.github.io/2020/08/11/%E6%9D%AD%E7%94%B5%20(7)/","excerpt":"8.11 差点没签上到的杭电7","text":"8.11 差点没签上到的杭电7 1009-Increasing and Decreasing题意 给定 $n$ 、$x$ 、$y$ ，需要构造一个 $1-n$ 的排列使得排列里 $LIS$ 的长度为 $x$ ，$LDS$ 的长度为 $y$ 。如果有多个满足要求的排列，选择其中字典序最小的。 思路 构造的思路是：由于有字典序的要求，考虑尽量把 $LIS$ 放在最前面。选择连续递增的小于 $x$ 的一部分（可能为 $0$ ），将长度设为 $f$ ，后面有长度为 $x-f$ 的分别递减的小块。设小块数量为 $t$ ，则可以列出 $t+n-t*y=x$ ，则 $t=\\frac{n-x}{y-1}$ 。小块内不一定取满则 $t$ 需要取上整。 可以发现当 $x+y&gt;n+1$ 时没有答案。同时根据分小块的结论可以发现在 $x*y&lt;n$ 时也不存在解。 由于后面有对 $y-1$ 进行的除法操作，所以当 $x=n$ ，$y=1$ 时选择特判。代码里直接将所有 $x+y=n+1$ 的情况特判。 代码 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;const int maxn = 1e6 + 5;int ans[maxn];int solve()&#123; int n,x,y; sc(n); sc(x); sc(y); if(x+y&gt;n+1||1ll*x*y&lt;n) return pf(&quot;NO\\n&quot;); if(x+y==n+1)&#123; pf(&quot;YES\\n&quot;); rep(i,1,x) pf(&quot;%d &quot;,i); dep(i,n,x) pf(&quot;%d%c&quot;,i,&quot; \\n&quot;[i==x]); return 0; &#125; pf(&quot;YES\\n&quot;); int t=(n-x+y-2)/(y-1),f=max(0,x-t); rep(i,1,f+1) ans[i]=i; int pos=n-y+1,cnt(0),tot(0); dep(i,n,f+1)&#123; ans[pos]=i; pos++; cnt++; tot++; if(cnt==y) cnt=0,pos-=2*y; pos=max(pos,f+1); &#125; rep(i,1,n+1) pf(&quot;%d%c&quot;,ans[i],&quot; \\n&quot;[i==n]); return 0;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1010-Jogging题意 一个点 $(x,y)$ 合法当且仅当满足 $gcd(x,y)&gt;1$ 。设一个合法点周围八个点内的合法点数为 $z$ ，到达一个合法点后有 $\\frac{1}{z+1}$ 的概率留在原地，$\\frac{z}{z+1}$ 的概率到周围的合法点。给定点 $(x,y)$ ，问在时间趋于正无穷时回到此点的概率。 思路 首先可以想到，这样的点不会特别多，可以考虑直接暴搜。特别的，当周围的点对有横竖坐标相同的情况，这时点是无穷多的，加个标记判掉。结论是给定点对周围合法点数/所有能到的合法点周围的合法点总和。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; pii;int ff;queue&lt;pii&gt;q;map&lt;pii,int&gt;mp;void dfs(ll x,ll y)&#123; if(ff) return; if(mp.count(pii(x,y))) return; if(x==y)&#123; ff++; return; &#125; if(__gcd(x,y)==1) return; q.push(pii(x,y)); mp[pii(x,y)]=1; dfs(x+1,y); dfs(x,y+1); dfs(x-1,y); dfs(x,y-1); dfs(x+1,y+1); dfs(x+1,y-1); dfs(x-1,y+1); dfs(x-1,y-1);&#125;int cal(ll x,ll y)&#123; int ans(0); if(mp.count(pii(x-1,y))) ans++; if(mp.count(pii(x,y-1))) ans++; if(mp.count(pii(x+1,y))) ans++; if(mp.count(pii(x,y+1))) ans++; if(mp.count(pii(x-1,y-1))) ans++; if(mp.count(pii(x-1,y+1))) ans++; if(mp.count(pii(x+1,y-1))) ans++; if(mp.count(pii(x+1,y+1))) ans++; return ans;&#125;int solve()&#123; ll x,y; scl(x); scl(y); mp.clear(); ff=0; while(!q.empty()) q.pop(); dfs(x,y); if(ff) return pf(&quot;0/1\\n&quot;); ll sz=q.size(),ans=sz,cnt=1+cal(x,y); while(!q.empty())&#123; ll x=q.front().first,y=q.front().second; q.pop(); if(mp.count(pii(x-1,y))) ans++; if(mp.count(pii(x,y-1))) ans++; if(mp.count(pii(x+1,y))) ans++; if(mp.count(pii(x,y+1))) ans++; if(mp.count(pii(x-1,y-1))) ans++; if(mp.count(pii(x-1,y+1))) ans++; if(mp.count(pii(x+1,y-1))) ans++; if(mp.count(pii(x+1,y+1))) ans++; &#125; ll g=__gcd(ans,cnt); ans/=g; cnt/=g; return pf(&quot;%lld/%lld\\n&quot;,cnt,ans);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"HDOJ","slug":"HDOJ","permalink":"http://wzgshyvin.github.io/tags/HDOJ/"}]},{"title":"2020牛客暑期多校训练营（第十场）","slug":"牛客 (10)","date":"2020-08-10T14:22:22.000Z","updated":"2021-02-22T18:17:30.768Z","comments":true,"path":"2020/08/10/牛客 (10)/","link":"","permalink":"http://wzgshyvin.github.io/2020/08/10/%E7%89%9B%E5%AE%A2%20(10)/","excerpt":"8.10 只想着G赛后也过了G的牛客10","text":"8.10 只想着G赛后也过了G的牛客10 A-Permutation题意 给定一个质数 $p$ ，求出 $p-1$ 个数组成的序列，要求序列满足 $x_{i+1}=2x_i$ 或 $x_{i+1}=3x_i$ 思路 如果序列有解，则 $x_1=1,x_2=2$ 然后依序构造，判断 $x_{i-1}*2%p$ 和 $x_{i-1}*3%p$ 是否有满足条件的解。 G-Math Test题意 给定数 $a$ 、$n$ ，问有多少点对 $(x,y)$ 满足 $gcd(x,y)=1$，$y∣(x^2+a)$，$x∣(y^2+a)$，$1≤x≤y≤n$ 。 思路 参考 ==zjut_6== 队伍代码。 由于 $T$ 为 $1e6$ ，考虑全部预处理，在每次询问时二分查找答案。 打表可以看出对于满足条件的 $(x,y)$ ，$(y,(y^2+a)/x)$ 也是一组解。所以思路就是每次求出小的解往后迭代。 有 $(x^2+a)/y\\geq x$ ，即 $x*(y-x)\\leq a$ 。故枚举差值 $d$ 和 $x$ ，得到 $(x,y)$ ，对于每对这样的 $(x,y)$ 求出符合条件的 $a$。 坑点 评测机波动可能会造成样例能过提交后内存超限。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; pii;const int maxn = 1e5 + 1;vector&lt;ll&gt;vv[maxn+5];vector&lt;pii&gt;rt[maxn+5];void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1; y=0; return; &#125; exgcd(b,a%b,y,x); y-=(a/b)*x; return;&#125;ll inv(ll a,ll p)&#123; ll x,y; exgcd(a,p,x,y); return (x%p+p)%p;&#125;void init()&#123; rep(a,1,maxn) rt[a].push_back(pii(1,1)); // 对于任意a都有1,1满足条件 rep(d,1,maxn) for(int x=1;1ll*x*d&lt;maxn;++x)&#123; // 枚举y和x的差值d和x if(__gcd(d,x)&gt;1) continue; // 差值和x不互质则x和y也不互质 int y=x+d; ll m=1ll*x*y; ll k1=inv(y,x),k2=inv(x,y); ll t1=-1ll*y*y%x,t2=-1ll*x*x%y; while(t1&lt;0) t1+=x; while(t2&lt;0) t2+=y; ll a=k1*y%m*t1%m; a+=k2*x%m*t2%m; a%=m; // crt while(a&lt;1ll*x*d) a+=m; while(a&lt;maxn)&#123; rt[a].emplace_back(pii(x,y)); a+=m; // 加xy不影响取模的结果 前后a是等价的 &#125; &#125; rep(a,1,maxn)&#123; rep(i,0,(int)rt[a].size())&#123; ll x=rt[a][i].first,y=rt[a][i].second; __int128 t=(__int128)y*y+a; t/=x; if(t&gt;1e18) continue; x=y; y=t; rt[a].push_back(pii(x,y)); // 更新 这个打表一下就找到规律了 &#125; sort(rt[a].begin(),rt[a].end()); int sz=unique(rt[a].begin(),rt[a].end())-rt[a].begin(); rep(i,0,sz) vv[a].push_back(rt[a][i].second); sort(vv[a].begin(),vv[a].end()); rt[a].resize(0); rt[a].shrink_to_fit(); &#125; &#125;int solve()&#123; int a; ll n; sc(a); scl(n); return pf(&quot;%d\\n&quot;,(int)(upper_bound(vv[a].begin(),vv[a].end(),n)-vv[a].begin()));&#125;int main()&#123; init(); int _; sc(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"2020牛客暑期多校训练营（第九场）","slug":"牛客 (9)","date":"2020-08-08T14:22:22.000Z","updated":"2021-02-22T19:16:38.261Z","comments":true,"path":"2020/08/08/牛客 (9)/","link":"","permalink":"http://wzgshyvin.github.io/2020/08/08/%E7%89%9B%E5%AE%A2%20(9)/","excerpt":"8.08 体验极差的牛客9","text":"8.08 体验极差的牛客9 A-Groundhog and 2-Power Representation题意 给一个式子，每个括号前省略了一个 ^ 符号，问式子运算后的结果。 思路 卡语言是真的恶心，Python 一行就行，真的没意思，体验极差 倒着模拟记录状态，Java 写的 代码 123456789101112131415161718192021222324252627282930313233343536373839404142import java.math.*;import java.util.*;import java.io.*;public class Main &#123; public static BigInteger qpow(BigInteger a,BigInteger b)&#123; BigInteger ans=BigInteger.ONE; while(b.compareTo(BigInteger.ZERO)&gt;0)&#123; if(b.mod(new BigInteger(&quot;2&quot;)).compareTo(BigInteger.ONE)==0) ans=ans.multiply(a); b=b.divide(new BigInteger(&quot;2&quot;)); a=a.multiply(a); &#125; return ans; &#125; public static void main(String[] args)&#123; Scanner sc=new Scanner(System.in); String s=sc.next(); BigInteger[] a=new BigInteger[20005]; BigInteger res=BigInteger.ZERO; BigInteger two=new BigInteger(&quot;2&quot;); BigInteger ten=new BigInteger(&quot;10&quot;); // solve int len=s.length(),cnt=0; for(int i=0;i&lt;len;i++) a[i]=BigInteger.ZERO; for(int i=len-1;i&gt;=0;i--)&#123; if(s.charAt(i)==&#x27;)&#x27;)&#123; cnt++; &#125; else if(s.charAt(i)&gt;=&#x27;0&#x27;&amp;&amp;s.charAt(i)&lt;=&#x27;9&#x27;)&#123; res=BigInteger.valueOf(s.charAt(i)-&#x27;0&#x27;); &#125; else if(s.charAt(i)==&#x27;+&#x27;)&#123; a[cnt]=a[cnt].add(res); res=BigInteger.ZERO; &#125; else if(s.charAt(i)==&#x27;(&#x27;)&#123; a[cnt]=a[cnt].add(res); res=BigInteger.ZERO; BigInteger t=qpow(two,a[cnt]); cnt--; a[cnt]=a[cnt].add(t); a[cnt+1]=BigInteger.ZERO; i--; &#125; &#125; System.out.println(a[0]); &#125;&#125; E-Groundhog Chasing Death题意 给定 $a$ 、$b$ 、$c$ 、$d$ 、$x$ 、$y$ ，求 $\\prod \\limits^{b} _ {i=a}\\prod \\limits^{d} _ {j=c}gcd(x^i,y^j)$ 。 思路 只需要考虑公共质因数。记录 $x$ 和 $y$ 的公共质因数在 $x$ 、$y$ 分别出现的次数，对于每个公共质因数，枚举 $x$ 的每个幂次，每次求 $y$ 在 $[c,d]$ 幂次中的和 $x$ 此幂次的大小关系，取最小个数计算。 坑点 这种写法有个数炸 long long ，赛后想到可以取模降幂的哦 upd：取模还没 __int128 快，就这 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(ll i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(ll i=(e); i&gt;=(s); --i)using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; pii;const ll maxn = 1e5 + 5;const ll mod = 998244353;map&lt;ll,ll&gt;mp1,mp2;ll qpow(ll a,__int128 b)&#123; ll ans=1; while(b&gt;0)&#123; if(b&amp;1) ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;ll solve()&#123; ll a,b,c,d,x,y; sc(a); sc(b); sc(c); sc(d); sc(x); sc(y); if(!b||!d) return pf(&quot;1\\n&quot;); if(!a) a++; if(!c) c++; if(b-a&gt;d-c) swap(a,c),swap(b,d),swap(x,y); vector&lt;pii&gt;vv1,vv2; ll xx=x,yy=y; for(ll i=2;1ll*i*i&lt;=xx;++i)&#123; while(xx%i==0) mp1[i]++,xx/=i; &#125; if(xx&gt;1) mp1[xx]++; for(ll i=2;1ll*i*i&lt;=yy;++i)&#123; while(yy%i==0) mp2[i]++,yy/=i; &#125; if(yy&gt;1) mp2[yy]++; for(auto t:mp1)&#123; ll tt=t.first; if(!mp2.count(tt)) continue; vv1.push_back(pii(t.first,t.second)); &#125; for(auto t:mp2)&#123; ll tt=t.first; if(!mp1.count(tt)) continue; vv2.push_back(pii(t.first,t.second)); &#125; // any vv1 fr == vv2 fr ll ans=1; rep(i,0,vv1.size())&#123; ll t=vv1[i].first; __int128 cnt=0; rep(j,a,b+1)&#123; ll u=vv1[i].second*j,v=vv2[i].second; // &lt;= ll num=min(u/v,d)-c+1; if(num&lt;0) num=0; // getsum if(num) cnt+=1ll*num*(num-1)/2*v+1ll*num*v*c; // &gt; num=(d-c+1)-num; if(num&lt;0) num=0; cnt+=1ll*u*num; &#125; ans=1ll*ans*qpow(t,cnt)%mod; &#125; return pf(&quot;%lld\\n&quot;,ans);&#125;signed main()&#123; /* ll _; sc(_); while(_--) */ solve();&#125; I-The Crime-solving Plan of Groundhog题意 给定 $n$ 个数，问重新排列成两个没有前导零的正整数的乘积最大值是多少。 思路 $sort$ 一下最小的一位乘上后面剩下的。有 $0$ 的时候要把 $0$ 往后移。虽然是乘法但其中一个乘数最多为 $9$ ，直接用大数加法的板子就可以。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;char s[maxn],q[maxn];int th[maxn],ss;void add(char *a,char *b)&#123; mst(th,0); int ans=0; int len1=strlen(a+1),len2=strlen(b+1); int k=ss=1; while(len1||len2||ans)&#123; if(len1&gt;0) ans+=a[len1--]-&#x27;0&#x27;; if(len2&gt;0) ans+=b[len2--]-&#x27;0&#x27;; th[ss++]=ans%10; ans/=10; &#125; while(!th[ss]) ss--;&#125;int solve()&#123; int n; sc(n); getchar(); mst(s,0); rep(i,1,n+1)&#123; char c=getchar(); s[i]=c; getchar(); &#125; sort(s+1,s+n+1); int ff(0); rep(i,1,n+1)&#123; if(s[i]==&#x27;0&#x27;) ff++; else&#123; if(ff) swap(s[1],s[i]),swap(s[2],s[i+1]); break; &#125; &#125; mst(q,0); rep(i,1,s[1]-&#x27;0&#x27;+1)&#123; add(q,s+1); int cnt(0); for(;ss&gt;=1;ss--) q[++cnt]=th[ss]+&#x27;0&#x27;; &#125; return pf(&quot;%s\\n&quot;,q+1);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"2020 Multi-University Training Contest 6","slug":"杭电 (6)","date":"2020-08-06T14:22:22.000Z","updated":"2021-02-22T19:15:50.073Z","comments":true,"path":"2020/08/06/杭电 (6)/","link":"","permalink":"http://wzgshyvin.github.io/2020/08/06/%E6%9D%AD%E7%94%B5%20(6)/","excerpt":"8.06 没签上到的杭电6","text":"8.06 没签上到的杭电6 1001-Road To The 3rd Building题意 给定 $n$ 个数，每个数有价值 $val[i]$ 。随机选择 $i\\leq j$ 的 $(i,j)$ 点对，问下标 $i$ 到 $j$ 的子数组价值和的平均数的期望。 思路 当随机选择 $1$ 个或者 $n$ 个时，每个数只出现一次；随机选择 $2$ 个或者 $n-1$ 个时，除了首位的数出现一次，其他数出现两次……递推计算即可。总方案数是 $n*(n+1)/2$ 。 代码 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;const int maxn = 2e5 + 5;const int mod = 1e9 + 7; int val[maxn],sum;int qpow(int a,int b)&#123; int ans=1; while(b&gt;0)&#123; if(b&amp;1) ans=1ll*ans*a%mod; b&gt;&gt;=1; a=1ll*a*a%mod; &#125; return ans;&#125;int solve()&#123; int n,ans(0),sum(0); sc(n); rep(i,1,n+1)&#123; sc(val[i]); sum+=1ll*val[i]; if(sum&gt;=mod) sum-=mod; &#125; int l=1,r=n,t=sum,q=sum; while(l&lt;=r)&#123; ans+=1ll*t*qpow(l,mod-2)%mod; if(ans&gt;=mod) ans-=mod; if(l==r) break; ans+=1ll*t*qpow(r,mod-2)%mod; if(ans&gt;=mod) ans-=mod; q=q-val[l]-val[r]; while(q&lt;0) q+=mod; t=t+q,l++,r--; if(t&gt;=mod) t-=mod; &#125; int u=1ll*n*(n+1)/2%mod; ans=1ll*ans*qpow(u,mod-2)%mod; return pf(&quot;%d\\n&quot;,ans);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1002-Little Rabbit’s Equation题意 给定公式，格式为数字 运算符 数字 等于号 数字，问能否在 $2-16$ 的进制中找到满足此公式的进制。 思路 因为最多只有 $16$ 进制，故暴力枚举即可。找到式子中最大的数，从 $mx+1$ 进制枚举到 $16$ 进制。处理出三个数字在每个进制下的表示，满足条件的就输出。注意会爆 $int$ 。 1009-Divisibility题意 给定数 $b$ 、$x$ ，问在 $b$ 进制下的任意 $y$ ，能否满足各位和是 $x$ 的倍数和 $y$ 是 $x$ 的倍数是充要条件。 思路 存在 $k*x+1=b$ ，$k\\in Z^+$ 时满足条件。 代码 123456789101112131415#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)using namespace std;typedef long long ll;int solve()&#123; ll n,k; scl(n); scl(k); if(k&gt;=n) return pf(&quot;F\\n&quot;); if((n-1)%k==0) return pf(&quot;T\\n&quot;); return pf(&quot;F\\n&quot;);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1010-Expectation题意 给定 $n$ 个点 $m$ 条边，每条边有权值。定义一棵生成树的权值和为所有边权的按位与，问随机选定生成树的期望权值和是多少。 思路 将权值按位拆分，枚举二进制位计算。每次跑一遍矩阵树。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 队友板子#include &lt;bits/stdc++.h&gt;#define re read()#define ll long long#define mkp(a, b) make_pair(a, b)#define mst(a, c) memset(a, c, sizeof(a))#define rep(a, b, c) for(int a = b; a &lt;= c; a++)#define per(a, b, c) for(int a = b; a &gt;= c; a--)using namespace std;const int MOD = 998244353;int read()&#123; int num = 0; bool f = 0; char ch = getchar(); while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;f = (ch == &#x27;-&#x27;); ch = getchar();&#125; while(ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + ch - &#x27;0&#x27;; ch = getchar();&#125; return f? -num : num;&#125;struct SF&#123; int u, v, w;&#125;e[10005];ll qpow(ll a, ll b)&#123; ll ans = 1; while(b &gt; 0) &#123; if(b &amp; 1) ans = ans * a % MOD; b &gt;&gt;= 1; a = a * a % MOD; &#125; return ans;&#125;int n, m, cnt;char str[15][15];ll a[115][115];void init(ll x, int ff)&#123; mst(a, 0); rep(i, 1, m) &#123; int u = e[i].u, v = e[i].v, w = e[i].w; if(ff || x &amp; w) &#123; a[u][v]--, a[u][u]++; a[v][u]--, a[v][v]++; &#125; &#125;&#125;ll det(int x)&#123; rep(i, 1, x) rep(j, 1, x) a[i][j] = (a[i][j] + MOD) % MOD; ll res = 1, f = 1; rep(i, 1, x) &#123; rep(j, i + 1, x) &#123; ll A = a[i][i], B = a[j][i]; while(B) &#123; ll tmp = A / B; A %= B; swap(A, B); rep(k, i, x) a[i][k] = (a[i][k] - tmp * a[j][k] % MOD + MOD) % MOD; rep(k, i, x) swap(a[i][k], a[j][k]); f = -f; &#125; &#125; if(!a[i][i]) return 0; res = (res * a[i][i]) % MOD; &#125; if(f == -1) return (MOD - res) % MOD; return res;&#125;int solve()&#123; n = re, m = re; rep(i, 1, m)&#123; e[i].u = re, e[i].v = re, e[i].w = re; &#125; ll x = 1, ans = 0; rep(i, 0, 31)&#123; init(x, 0); ans += 1ll * det(n - 1) * x % MOD; if(ans &gt;= MOD) ans -= MOD; x = x * 2; &#125; init(0, 1); ll tt = det(n - 1); tt = qpow(tt, MOD - 2); ans = 1ll * ans * tt % MOD; printf(&quot;%d\\n&quot;, ans); return 0;&#125;int main()&#123; per(_,re,1) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"HDOJ","slug":"HDOJ","permalink":"http://wzgshyvin.github.io/tags/HDOJ/"}]},{"title":"2020 Multi-University Training Contest 5","slug":"杭电 (5)","date":"2020-08-04T14:22:22.000Z","updated":"2021-02-22T19:15:11.375Z","comments":true,"path":"2020/08/04/杭电 (5)/","link":"","permalink":"http://wzgshyvin.github.io/2020/08/04/%E6%9D%AD%E7%94%B5%20(5)/","excerpt":"8.04 接着自闭的杭电5","text":"8.04 接着自闭的杭电5 1001-Tetrahedron题意 $a$ 、$b$ 、$c$ 为 $[1,n]$ 的随机数，将其分别作为直角三棱锥的三条直角边。设直角顶点为 $P$ ，过 $P$ 的高为 $h$ ，求 $\\frac{1}{h^2}$ 的期望值。 思路 对于直角三棱柱有结论 $\\frac{1}{h^2}=\\frac{1}{a^2}+\\frac{1}{b^2}+\\frac{1}{c^2}$ ，且 $a$ 、$b$ 、$c$ 是等价的，故可以转化为：求 $[1,n]$ 内随机数 $x$ 的 $E(\\frac{3}{x^2})$ 。因为有 $2e6$ 组数据，所以需要预处理。 代码 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;const int maxn = 6e6 + 5;const int mod = 998244353; int qpow(int a,int b)&#123; int ans=1; while(b&gt;0)&#123; if(b&amp;1) ans=1ll*ans*a%mod; b&gt;&gt;=1; a=1ll*a*a%mod; &#125; return ans;&#125;int p[maxn],res[maxn],m[maxn],z[maxn],ans[maxn];int solve()&#123; int n; sc(n); return pf(&quot;%d\\n&quot;,ans[n]);&#125;int main()&#123; res[0]=1; rep(i,1,maxn)&#123; p[i]=1ll*i*i%mod; res[i]=1ll*res[i-1]*p[i]%mod; m[i]=1ll*i*res[i]%mod; m[i]=qpow(m[i],mod-2); z[i]=1ll*z[i-1]*i%mod*i%mod+res[i-1]; if(z[i]&gt;=mod) z[i]-=mod; ans[i]=3ll*z[i]*m[i]%mod; &#125; int _; sc(_); while(_--) solve();&#125; 1003-Boring Game题意 有 $n$ 张纸，左向右折 $k$ 次。之后从上到下给每层的正背面标号，保证是 $1-2 * n * 2 ^ k$ 的排列。问将纸复原后编号是什么样的。 思路 和小转有仇的 模拟 (虽然是赛时想假了) 。折一次标号就转一次。 代码 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;const int maxn = 5e5 + 5;int a[maxn]; vector&lt;int&gt;vv[1050];void solve()&#123; int n,k; sc(n); sc(k); int t=1&lt;&lt;k,sum=2*n*t; mst(vv,0); rep(i,1,sum+1) sc(a[i]),vv[t].push_back(a[i]); reverse(vv[t].begin(),vv[t].end()); rep(i,0,k) for(int j=t-(1&lt;&lt;i)+1,u=j-1;j&lt;=t;++j,--u)&#123; int s=vv[j].size()/2; rep(l,0,s)&#123; vv[u].push_back(vv[j].back()); vv[j].pop_back(); &#125; &#125; dep(i,2*n-1,0) rep(j,1,t+1) pf(&quot;%d%c&quot;,vv[j][i],&quot; \\n&quot;[!i&amp;&amp;j==t]);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1008-Set2题意 有一个包含 $1-n$ 的 $set$ ，给定 $k$ ，做若干轮删除操作直到 $set$ 里元素个数不多于 $k$ 个。 每次删除操作是先删除一个最小的数，再随机删除 $k$ 个数。 问每个元素留下来的期望是多少。 代码 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;const int mod = 998244353; int dp[5005];int qpow(int a,int b)&#123; int ans=1; while(b&gt;0)&#123; if(b&amp;1) ans=1ll*ans*a%mod; b&gt;&gt;=1; a=1ll*a*a%mod; &#125; return ans;&#125;int solve()&#123; int n,k,r; sc(n); sc(k); r=n%(1+k); rep(i,0,r) dp[i]=1; rep(i,r,n)&#123; dp[i]=0; if((n-i)%(k+1)==1) continue; int inv=qpow(i+1,mod-2); dep(j,i,0)&#123; dp[j]=1ll*dp[j]*(i-j)%mod*inv%mod; if(j) (dp[j]+=1ll*dp[j-1]*j%mod*inv%mod)%=mod; &#125; &#125; dep(i,n-1,0) pf(&quot;%d%c&quot;,dp[i],&quot; \\n&quot;[!i]);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1012-Set1题意 集合有 $1-n$ 的数，其中 $n$ 为奇数。每次操作删除一个最小的数再随机删除一个剩下的数。问每个数剩下的概率。 思路 首先必有 $n/2$ 轮，所以前 $n/2$ 个数留下来的概率必为 $0$ 。设剩下数个数为 $m$ ，则每个数留下来的方案数为 $C^{i-1}_{m-1+i-1}$ ，总方案数为 $2^{m-1+i-1}$ 。 代码 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;const int maxn = 5e6 + 5;const int mod = 998244353; int qpow(int a,int b)&#123; int ans=1; while(b&gt;0)&#123; if(b&amp;1) ans=1ll*ans*a%mod; b&gt;&gt;=1; a=1ll*a*a%mod; &#125; return ans;&#125;int jc[maxn],inv[maxn],inv2[maxn];int C(int s,int x)&#123; return 1ll*jc[x]*inv[s]%mod*inv[x-s]%mod;&#125;void solve()&#123; int n; sc(n); rep(i,1,n/2+1) pf(&quot;0 &quot;); n=(n+1)/2; rep(i,1,n+1) pf(&quot;%d%c&quot;,1ll*C(i-1,n+i-2)*inv2[n+i-2]%mod,&quot; \\n&quot;[i==n]);&#125;int main()&#123; jc[0]=inv[0]=inv2[0]=1; int in2=qpow(2,mod-2); rep(i,1,maxn) jc[i]=1ll*jc[i-1]*i%mod,inv2[i]=1ll*inv2[i-1]*in2%mod; inv[maxn-1]=qpow(jc[maxn-1],mod-2); dep(i,maxn-2,1) inv[i]=1ll*inv[i+1]*(i+1)%mod; int _; sc(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"HDOJ","slug":"HDOJ","permalink":"http://wzgshyvin.github.io/tags/HDOJ/"}]},{"title":"2020牛客暑期多校训练营（第八场）","slug":"牛客 (8)","date":"2020-08-03T14:22:22.000Z","updated":"2021-02-22T19:14:09.207Z","comments":true,"path":"2020/08/03/牛客 (8)/","link":"","permalink":"http://wzgshyvin.github.io/2020/08/03/%E7%89%9B%E5%AE%A2%20(8)/","excerpt":"8.03 又写模拟写哭了的牛客8","text":"8.03 又写模拟写哭了的牛客8 G-Game SET题意 给定一些卡片。一张卡片有 $4$ 个属性，每个属性有 $4$ 种样式，用 $1$ 、$2$ 、$3$ 、$ * $ 表示。$ * $ 可以替换为 $1$ 、$2$ 、$3$ 的任意一个。定义一个卡片集为 $3$ 张每个属性样式全一样或者全不一样的卡片，找出给定卡片的任意卡片集。 思路 暴力可以过，那就非常简单呗 再也不想写模拟了，真的恶心 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;char s[100];int vis[5][300];int solve(int cas)&#123; pf(&quot;Case #%d: &quot;,cas); mst(vis,0); int n,ff(0); sc(n); rep(i,1,n+1)&#123; scs(s+1); int len=strlen(s+1); int cnt(0); string t=&quot;&quot;; rep(j,1,len+1)&#123; if(s[j]==&#x27;[&#x27;) continue; if(s[j]==&#x27;]&#x27;)&#123; if(cnt==0)&#123; if(t==&quot;*&quot;) vis[cnt][i]=-1; else if(t==&quot;one&quot;) vis[cnt][i]=1; else if(t==&quot;two&quot;) vis[cnt][i]=2; else if(t==&quot;three&quot;) vis[cnt][i]=3; &#125; else if(cnt==1)&#123; if(t==&quot;*&quot;) vis[cnt][i]=-1; else if(t==&quot;diamond&quot;) vis[cnt][i]=1; else if(t==&quot;squiggle&quot;) vis[cnt][i]=2; else if(t==&quot;oval&quot;) vis[cnt][i]=3; &#125; else if(cnt==2)&#123; if(t==&quot;*&quot;) vis[cnt][i]=-1; else if(t==&quot;solid&quot;) vis[cnt][i]=1; else if(t==&quot;striped&quot;) vis[cnt][i]=2; else if(t==&quot;open&quot;) vis[cnt][i]=3; &#125; else if(cnt==3)&#123; if(t==&quot;*&quot;) vis[cnt][i]=-1; else if(t==&quot;red&quot;) vis[cnt][i]=1; else if(t==&quot;green&quot;) vis[cnt][i]=2; else if(t==&quot;purple&quot;) vis[cnt][i]=3; &#125; t=&quot;&quot;; cnt++; continue; &#125; t+=s[j]; &#125; &#125; rep(i,1,n+1) rep(j,i+1,n+1) rep(k,j+1,n+1)&#123; int fl[4]; mst(fl,0); rep(u,0,4)&#123; if(vis[u][i]==-1||vis[u][j]==-1||vis[u][k]==-1)&#123; fl[u]=1; continue; &#125; else if(vis[u][i]==vis[u][j]&amp;&amp;vis[u][j]==vis[u][k])&#123; fl[u]=1; continue; &#125; else if(vis[u][i]!=vis[u][j]&amp;&amp;vis[u][j]!=vis[u][k]&amp;&amp;vis[u][i]!=vis[u][k])&#123; fl[u]=1; continue; &#125; &#125; if(fl[0]+fl[1]+fl[2]+fl[3]==4) return pf(&quot;%d %d %d\\n&quot;,i,j,k); &#125; return pf(&quot;-1\\n&quot;);&#125;int main()&#123; int _,cas(0); sc(_); while(_--) solve(++cas);&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"2020牛客暑期多校训练营（第七场）","slug":"牛客 (7)","date":"2020-08-01T14:22:22.000Z","updated":"2021-02-22T17:47:36.840Z","comments":true,"path":"2020/08/01/牛客 (7)/","link":"","permalink":"http://wzgshyvin.github.io/2020/08/01/%E7%89%9B%E5%AE%A2%20(7)/","excerpt":"8.01 写模拟写哭了的牛客7","text":"8.01 写模拟写哭了的牛客7 D-Fake News题意 $\\sum^{n}_{i=1}i^2$ 一定不是完全平方数吗？ 思路 只有 $n=1$ 或 $n=24$ 的时候结果是完全平方数，打表出来的。具体证明有个知乎回答？如何证明 1²+2²+…+n² 为平方数的解只有 n＝1 或 n＝24？ 代码 123456789101112#include&lt;bits/stdc++.h&gt;#define scl(x) scanf(&quot;%lld&quot;, &amp;x)using namespace std;typedef long long ll;int solve()&#123; ll n; scl(n); if(n==1||n==24) return puts(&quot;Fake news!&quot;); return puts(&quot;Nobody knows it better than me!&quot;);&#125;int main()&#123; ll _; scl(_); while(_--) solve();&#125; H-Dividing题意 定义函数 $f(n, k)$，其中 $1\\leq n\\leq N$ 、$1\\leq k\\leq K$。 初始有：$f(1, k)=1$ 。有递推关系： $f(n, k)=1$ 则 $f(n+k, k)=1$ $f(n, k)=1$ 则 $f(n*k, k)=1$ 给定 $N$ 、$K$ ，问最多有多少对 $f(n, k)=1$ 思路 很明显的数论分块。 首先 $k&gt;n$ 时肯定只有 $f(1, k)$ 一种情况，加上后 $k$ 可以直接取到 $n$。 之后分块讨论。对于每个为 $i$ 的小块，先加上纯加法的方案 1+n/i-(n%i==0) 种。$i&gt;1$ 时，还需要考虑乘法一次后累加的情况 $n/i$ 种。大块同理，大块中的每个值 $q$ 都有 2*i+1-(i*q==n) 的贡献。计算每个大块的个数，相乘一下。i*q==n 的情况只有一个，最后减去就行。 代码 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define pf printf#define scl(x) scanf(&quot;%lld&quot;, &amp;x)using namespace std;typedef long long ll;const int mod = 1e9 + 7;int solve()&#123; ll n,k,ans(0); scl(n); scl(k); if(k&gt;n) ans+=k-n,k=n; while(ans&gt;=mod) ans-=mod; for(int i=1;1ll*i*i&lt;=n;++i)&#123; if(i&gt;k) break; ll t=n/i; ans+=1+t; while(ans&gt;=mod) ans-=mod; if(n%i==0) ans--; while(ans&lt;0) ans+=mod; if(i&gt;1)&#123; ans+=t; while(ans&gt;=mod) ans-=mod; &#125; // small t=min(t,k); if(t==i) continue; ll tmp=n/(i+1); if(t&lt;=tmp) continue; // 边界 ans+=1ll*(2ll*i+1)*(t-tmp)%mod; while(ans&gt;=mod) ans-=mod; if(t*i==n) ans--; while(ans&lt;0) ans+=mod; &#125; return pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; J-Pointer Analysis题意 有 $26$ 个全局指针，用 $A-Z$ 表示；有 $26$ 个对象，用 $a-z$ 表示；每个对象还有 $26$ 个成员变量，它们可以指向其他对象的指针，也用 $a-z$ 表示。 有四种指令： $A=x$ ，$A$ 指向对象 $x$ $A=B$ ，$A$ 可指向 $B$ 指向的对象 $A.f=B$ ，$A$ 指向的对象的成员变量 $f$ 可指向 $B$ 指向的对象 $A=B.f$ ，$A$ 指向 $B$ 指向的对象的成员变量 $f$ 指向的对象 给出 $n$ 条指令，这些指令重复多次且随机顺序地执行。问每个全局指针能指向的对象。 思路 题意很不清晰但是思路很清晰的带模拟。注意要迭代多次，看别人的直接再套了个 $n$ 次的 $for$ 就行了，那我赛时代码怎么不行啊 代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;int mp1[30][30];int mp2[30][30][30];string s1[205],s2[205],t;void solve()&#123; int n; cin&gt;&gt;n; rep(i,0,n) cin&gt;&gt;s1[i]&gt;&gt;t&gt;&gt;s2[i]; rep(_,0,n) rep(i,0,n)&#123; int l1=s1[i].size(),l2=s2[i].size(); if(l1==1&amp;&amp;l2==1)&#123; // A-&gt;o if(islower(s2[i][0])) mp1[s1[i][0]-&#x27;A&#x27;][s2[i][0]-&#x27;a&#x27;]=1; // A-&gt;B else rep(j,0,26) mp1[s1[i][0]-&#x27;A&#x27;][j]|=mp1[s2[i][0]-&#x27;A&#x27;][j]; &#125; else if(l1==3)&#123; // (A.o.f)-&gt;B rep(j,0,26) if(mp1[s1[i][0]-&#x27;A&#x27;][j]) rep(k,0,26) mp2[j][s1[i][2]-&#x27;a&#x27;][k]|=mp1[s2[i][0]-&#x27;A&#x27;][k]; &#125; else&#123; // A-&gt;(B.o.f-&gt;C) rep(j,0,26) if(mp1[s2[i][0]-&#x27;A&#x27;][j]) rep(k,0,26) mp1[s1[i][0]-&#x27;A&#x27;][k]|=mp2[j][s2[i][2]-&#x27;a&#x27;][k]; &#125; &#125; rep(i,0,26)&#123; cout&lt;&lt;(char)(&#x27;A&#x27;+i)&lt;&lt;&quot;: &quot;; rep(j,0,26) if(mp1[i][j]) cout&lt;&lt;(char)(&#x27;a&#x27;+j); cout&lt;&lt;&#x27;\\n&#x27;; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"2020 Multi-University Training Contest 4","slug":"杭电 (4)","date":"2020-07-30T14:22:22.000Z","updated":"2021-02-22T19:12:58.444Z","comments":true,"path":"2020/07/30/杭电 (4)/","link":"","permalink":"http://wzgshyvin.github.io/2020/07/30/%E6%9D%AD%E7%94%B5%20(4)/","excerpt":"7.30 怒骂出题人的杭电4","text":"7.30 怒骂出题人的杭电4 1002-Blow up the Enemy题意 逆子张三和父亲打架，有 $n$ 把武器，每把武器对敌人产生 $a$ 点伤害，需要 $b$ 时间冷却。父亲从 $n$ 把武器中等概率选择一把，问张三获胜的最大概率是多少（平局则张三有一半的概率赢） 思路 贪心的思路，让张三选择获胜概率最大的一把武器，然后求一下该武器能赢过多少把武器，最后除一下就行了 坑点 场上因为第一轮不需要冷却时间被卡了 $1e5$ 年QUQ 1004-Deliver the Cake题意 给定 $n$ 个点 $m$ 条边的无向图，起点为 $s$ ，终点为 $t$ 。每个点有 $L$ 、$R$ 、$M$ 三种状态，人物初始状态可以为 $L$ 或者 $M$ ，经过 $L/R$ 时人物状态也需要为 $L/R$ ，经过 $M$ 时随意。切换状态需要时间 $x$ 。问从 $s$ 到 $t$ 所花费的最短时间。 思路 这题很显然是个最短路，为处理换手时间的问题，可以采用拆点的方式，将一个点拆分为左手点和右手点（在该点的状态为左手/右手），把同一个点的左手点和右手点建立代价为 $x$ 的双向边，然后对于读入的情况进行讨论 $(u, v)$ 为 $MM$ 情况时，将两点的左手连左手，右手连右手即可 $(u, v)$ 为 $MR$ 或 $ML$ 情况时，$v$ 为 $L$ 时，将 $u_左$ 和 $v_左$ 相连；$v$ 为 $R$ 时，将 $u_右$ 和 $v_右$ 相连（双向） $(u,v)$ 为 $RM$ 或 $LM$ 情况时，$u$ 为 $L$ 时，将 $u_左$ 和 $v_左$ 相连；$u$ 为 $R$ 时，将 $u_右$ 和 $v_右$ 相连（双向） $(u,v)$ 为 $RL$ 或 $LR$ 情况时，$u$ 为 $L$ 时，将 $u_右$ 和 $v_右$ 相连，$v_左$ 和 $u_左$ 相连（单向）；$u$ 为 $R$ 时，将 $u_左$ 和 $v_左$ 相连，$v_右$ 和 $u_右$相连（单向）； 然后对起点分类讨论，如果起点为 $L$ 或 $R$ 则直接跑一遍最短路就行，否则需要令起点为 $L$ 和起点为 $R$ 的情况分别做最短路，取时间更小的答案。 1005-Equal Sentences题意 给定 $n$ 个单词，问这些单词错排能有几种情况。错排指在单词集相同的情况下，每个单词第 $i$ 次出现位置与原串相差不超过 $1$ 。 思路 转换题意为：两两相邻且不相同的值才能交换。每个单词编号后记忆化搜索即可。 代码 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;typedef long long ll;const int mod = 1e9 + 7;char s[15];int a[maxn]; ll f[maxn];map&lt;string,int&gt;aaa;ll qaq(int n)&#123; if(f[n]) return f[n]; if(n==1) return f[1]=1; if(n==2) return f[2]=(a[1]==a[2]?1:2); if(a[n]==a[n-1]) return f[n]=qaq(n-1); return f[n]=(qaq(n-1)+qaq(n-2))%mod;&#125;int solve()&#123; int n,cnt(0); sc(n); aaa.clear(); rep(i,1,n+1)&#123; scs(s); if(!aaa.count(s)) aaa[s]=++cnt; a[i]=aaa[s]; f[i]=0; &#125; return pf(&quot;%lld\\n&quot;,qaq(n));&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1012-Last Problem题意 给定 $n$ 种颜色，问按题意给的涂色方式涂色后包含 $n$ 的方案。涂色方式是：涂 $x$ 时，四周颜色需要是 $(x−1, x−2, x−3, x−4)$ ，其中负数的情况不考虑。 思路 每次把所需涂色的点的周围所需颜色染上，由此想到递归求解。但是纯递归会步骤过多，所以用 $map$ 存一下当前点是否已被涂上所需颜色。注意：为使操作序列尽量短，应将 $n-1$ 和 $n-4$ 相对，$n-2$ 和 $n-3$ 相对，可参考题解中的图。 代码 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e4 + 5;const int mod = 1e9 + 7;map&lt;pii,int&gt;mp;void dfs(int x,int y,int t)&#123; if(t&lt;=0) return; if(mp[pii(x-1,y)]!=t-1) dfs(x-1,y,t-1); if(mp[pii(x,y-1)]!=t-2) dfs(x,y-1,t-2); if(mp[pii(x,y+1)]!=t-3) dfs(x,y+1,t-3); if(mp[pii(x+1,y)]!=t-4) dfs(x+1,y,t-4); mp[pii(x,y)]=t; pf(&quot;%d %d %d\\n&quot;,x,y,t);&#125;int main()&#123; /* int _; sc(_); while(_--) */ dfs(0,0,100);&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"HDOJ","slug":"HDOJ","permalink":"http://wzgshyvin.github.io/tags/HDOJ/"}]},{"title":"2020 Multi-University Training Contest 3","slug":"杭电 (3)","date":"2020-07-28T14:22:22.000Z","updated":"2021-02-22T19:11:45.547Z","comments":true,"path":"2020/07/28/杭电 (3)/","link":"","permalink":"http://wzgshyvin.github.io/2020/07/28/%E6%9D%AD%E7%94%B5%20(3)/","excerpt":"7.28 勇于乱冲的杭电3","text":"7.28 勇于乱冲的杭电3 1004-Tokitsukaze and Multiple题意 给定一个长度为 $n$ 的序列 $a$ ，可以两两间任意合并（合并为两数之和同时数组长度减一）。问最多能合并出多少个 $k$ 的倍数（可以不操作）。 思路 求模 $k$ 的前缀和，每次找前一个相同前缀和的位置。 代码 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 1e6 + 5;int sum[maxn],pos[maxn];int solve()&#123; int n,a,q,cnt(0); sc(n); sc(q); rep(i,0,q) pos[i]=0; int l=0; rep(i,1,n+1)&#123; sc(a),sum[i]=sum[i-1]+a,sum[i]%=q; if(!pos[sum[i]]&amp;&amp;sum[i])&#123; pos[sum[i]]=i; continue; &#125; if(!pos[sum[i]]&amp;&amp;!sum[i]&amp;&amp;!l)&#123; l=i; cnt++; pos[sum[i]]=i; continue; &#125; if(pos[sum[i]]&lt;l)&#123; pos[sum[i]]=i; continue; &#125; l=i; cnt++; pos[sum[i]]=i; &#125; return pf(&quot;%d\\n&quot;,cnt);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1005-Little W and Contest题意 给定能力为 $1$ 或 $2$ 的 $n$ 个人，从中选择 $3$ 个人组队，需要能力之和大于 $5$ 。一个队需要彼此不熟（也不能有共同的熟人）。输出初始方案数。之后有 $n-1$ 个询问，每次有两个人互相熟识，输出此时组队的所有方案数。 思路 初始状态就是 $cnt[1] * C ^ {2} _ {cnt[2]}+C ^ {3} _ {cnt[2]}$ 。每次询问减去这两个人（$u$ 、$v$）所在的组所有的组队情况： $u$ 组能力 $2$ 和 $v$ 组能力 $2$ 的人的组队 $u$ 组能力 $1$ 和 $v$ 组能力 $2$ 的人的组队 $u$ 组能力 $2$ 和 $v$ 组能力 $1$ 的人的组队 想要每次求出也很简单，只需要每个组记录能力为 $1$ 和 $2$ 的人数，每次并查集后将人数合并。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;int a[maxn];int qpow(int a,int b,int mod)&#123; int ans=1; while(b)&#123; if(b&amp;1) ans=1ll*ans*a%mod; b&gt;&gt;=1; a=1ll*a*a%mod; &#125; return ans;&#125;int jc[maxn],inv[maxn];int C(int s,int x)&#123; if(s&gt;x) return 0; return 1ll*jc[x]*inv[s]%mod*inv[x-s]%mod;&#125;int vis[maxn],peo[2][maxn];int find(int x)&#123; return vis[x]==x?x:vis[x]=find(vis[x]);&#125;int solve()&#123; int n,cnt[2]; sc(n); mst(cnt,0); mst(peo,0); rep(i,1,n+1) sc(a[i]),a[i]&amp;=1,cnt[a[i]]++,peo[a[i]][i]++,vis[i]=i; int sum=1ll*cnt[1]*C(2,cnt[0])%mod+1ll*C(3,cnt[0]); if(sum&gt;=mod) sum-=mod; pf(&quot;%d\\n&quot;,sum); rep(i,1,n)&#123; int u,v; sc(u); sc(v); int c=find(u),d=find(v); int tt=1ll*peo[0][c]*peo[0][d]%mod*(n-peo[0][c]-peo[1][c]-peo[0][d]-peo[1][d])%mod; // u v 2 2 tt+=1ll*peo[1][c]*peo[0][d]%mod*(cnt[0]-peo[0][c]-peo[0][d])%mod; if(tt&gt;=mod) tt-=mod; tt+=1ll*peo[1][d]*peo[0][c]%mod*(cnt[0]-peo[0][c]-peo[0][d])%mod; if(tt&gt;=mod) tt-=mod; // u v 1 2 / 2 1 sum-=tt; if(sum&lt;0) sum+=mod; pf(&quot;%d\\n&quot;,sum); vis[c]=d; rep(j,0,2) peo[j][d]+=peo[j][c]; // change &#125; return 0;&#125;int main()&#123; jc[0]=inv[0]=1; rep(i,1,maxn) jc[i]=1ll*jc[i-1]*i%mod; inv[maxn-1]=qpow(jc[maxn-1],mod-2,mod); dep(i,maxn-2,1) inv[i]=1ll*inv[i+1]*(i+1)%mod; int _; sc(_); while(_--) solve();&#125; 1006-X Number题意 对于 $1\\leq i\\leq 9$，定义 $i$ 类型数为数位上 $i$ 出现次数严格多于其他数字。问 $l$ 到 $r$ 中有多少个 $d$ 类型数。 思路 数位 $dp$ 嗯搞。将数位上各数字数量情况传进去，用 $mx$ 记录最高位不为 $d$ 的数位数量。搜到最末时只需计算 $d$ 此时的数量是否大于 $mx$ 。 备注 如果单组开 $dp[20][20]$ 没啥问题，但多组就要清空反而更慢了。直接开 $dp[20][10][20]$ 可以直接用前面的。$sort$ 是为了去重（ $map$ 里可以少存点东西），具体哪一位多少个是没有影响的，只需要记录相对数量。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;int a[20],cnt[10],d; // 位数 一般题目最大1e18ll l,r; map&lt;array&lt;int,10&gt;,ll&gt; dp[20][10][20]; // 位数 数位 个数ll dfs(int pos,int state,array&lt;int,10&gt; pre,int mx,int limit)&#123; // pos位数 pre之前状态 与dp数组对应 // state各种情况包括前导零 具体看题目 limit前一位限制 rep(i,0,10) pre[i]=cnt[i]; sort(pre.begin(),pre.end()); // sort去重 if(pos==-1) return cnt[d]&gt;mx; // 计数，具体看题目 if(!limit&amp;&amp;dp[pos][d][cnt[d]].count(pre)) return dp[pos][d][cnt[d]][pre]; int last=limit?a[pos]:9; ll ans=0; rep(i,0,last+1)&#123; if(!state||i) cnt[i]++; ans+=dfs(pos-1,state&amp;&amp;!i,pre,i==d?mx:max(mx,cnt[i]),limit&amp;&amp;i==a[pos]); if(!state||i) cnt[i]--; // cnt是全局的 到下一位就要减掉 &#125; if(!limit) dp[pos][d][cnt[d]][pre]=ans; return ans;&#125;ll slove(ll x)&#123; int pos=0; while(x)&#123; a[pos++]=x%10; x/=10; &#125; array&lt;int,10&gt; tmp&#123;0&#125;; return dfs(pos-1,1,tmp,0,1);&#125;int solve()&#123; scl(l),scl(r),sc(d); mst(cnt,0); ll ans=slove(r)-slove(l-1); return pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"HDOJ","slug":"HDOJ","permalink":"http://wzgshyvin.github.io/tags/HDOJ/"}]},{"title":"2020牛客暑期多校训练营（第六场）","slug":"牛客 (6)","date":"2020-07-27T14:22:22.000Z","updated":"2021-02-22T18:16:35.719Z","comments":true,"path":"2020/07/27/牛客 (6)/","link":"","permalink":"http://wzgshyvin.github.io/2020/07/27/%E7%89%9B%E5%AE%A2%20(6)/","excerpt":"7.27 充分发挥嘴题技能的牛客6","text":"7.27 充分发挥嘴题技能的牛客6 B-Binary Vector思路 面向样例合理猜测，猜递推公式是 $F(n)=F(n-1)*(2^n-1)/2^n$ 需要降到 $O(n)$ 代码 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;const int maxn = 2e7 + 5;const int mod = 1e9 + 7;int z[maxn],m[maxn],p[maxn],w[maxn],a[maxn];int solve()&#123; int n; sc(n); return pf(&quot;%d\\n&quot;,a[n]);&#125;int main()&#123; p[1]=2; rep(i,2,maxn) p[i]=2ll*p[i-1]%mod; w[1]=500000004; rep(i,2,maxn) w[i]=1ll*w[1]*w[i-1]%mod; z[1]=1; rep(i,2,maxn) z[i]=1ll*z[i-1]*(p[i]-1+mod)%mod; m[1]=500000004; rep(i,2,maxn) m[i]=1ll*m[i-1]*w[i]%mod; rep(i,1,maxn) a[i]=1ll*z[i]*m[i]%mod; rep(i,2,maxn) a[i]^=a[i-1]; int _; sc(_); while(_--) solve();&#125; C-Combination of Physics and Maths题意 给定一个 $n*m$ 大小的矩阵，任意选择行列组成子矩阵，使子矩阵和和最后一列之和的商最大 思路 最优解一定是分母尽量大，而分子尽量小。所以当选择某行作为最底行时，它以上的所有数字都应被选上，所以对每列做一下前缀和，然后再 $n^2$ 暴力求一下最大值就好 G-Grid Coloring题意 给定一个 $n*n$ 的矩阵，有 $k$ 种颜色，需要给每条边上色。需要满足： 所有颜色出现次数相同 没有单色环 没有单色边 给出一种合法情况 思路 首先特判，$n=1$ 、$k=1$ 还有颜色不能均匀分配的显然不行。对于剩下的合法涂色数，将各边从 $1-2n(n+1)$ 进行编号（左到右上到下），然后按编号从 $1-k$ 循环涂色即可 备注 代码五分钟，特判一小时 H-Harmony Pairs题意 给定 $N$ ，$N\\leq 1e100$ 。问 $1-N$ 中有多少个 $(A, B)$ 对满足 $A$ 的数位和大于 $B$ 的数位和且 $A\\leq B$ 。 思路 数位 $dp$ 。$dp[pos][d][la][lb]$ 中，$pos$ 表示第 $pos$ 位，$d$ 表示 $B-A$ ，$la$ 表示当前是否有 $A=B$ ，$lb$ 表示当前是否有 $B=N$ 。$d$ 开到 $2000$ 且从 $1000$ 开始搜防止出现负数非法访问。直接枚举转移。 代码 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;typedef long long ll;const int mod = 1e9 + 7;int a[105]; // 位数 一般题目最大1e18ll dp[105][2005][2][2];char s[105];ll dfs(int pos,int d,int la,int lb)&#123; if(pos==-1) return d&gt;1000; if(dp[pos][d][la][lb]!=-1) return dp[pos][d][la][lb]; ll ans=0; rep(i,0,la?a[pos]+1:10) rep(j,0,lb?i+1:10) ans+=dfs(pos-1,d+j-i,la&amp;&amp;i==a[pos],lb&amp;&amp;j==i),ans%=mod; return dp[pos][d][la][lb]=ans;&#125;ll slove()&#123; mst(dp,-1); // 多组数据只用最开始mst一次 因为保证边界就可以了 int pos=0,len=strlen(s); dep(i,len-1,0) a[pos++]=s[i]-&#x27;0&#x27;; return dfs(pos-1,1000,1,1);&#125;int solve()&#123; scs(s); return pf(&quot;%lld\\n&quot;,slove());&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"2020牛客暑期多校训练营（第五场）","slug":"牛客 (5)","date":"2020-07-25T14:22:22.000Z","updated":"2021-02-22T19:10:37.920Z","comments":true,"path":"2020/07/25/牛客 (5)/","link":"","permalink":"http://wzgshyvin.github.io/2020/07/25/%E7%89%9B%E5%AE%A2%20(5)/","excerpt":"7.25 好像没啥特别的牛客5","text":"7.25 好像没啥特别的牛客5 C-Easy题意 给定 $n$、$m$、$k$，问所有长度为 $k$ 且满足 $\\sum A_i=n$、$\\sum B_i=m$ 的 $A$、$B$ 数组的 $\\prod \\min(A_i,B_i)$ 之和。 思路 构造一个长度为 $k$ 的数组 $T$ 满足 $T_i&lt;=min(A_i, B_i)$ ，$T$ 的所有方案数就是要求的答案。为什么能这么构造呢？其实就是 $T$ 满足 $T_i&lt;=min(A_i, B_i)$ ，则 $T$ 的所有方案数就是每一位种类数相乘，可以发现就是题目要求的东西 枚举 $T$ 的和 $i$（ $k$ 到 $min(n,m)$ ），对于 $T$ 的每种情况计算可能的情况数，累加 每种情况考虑用隔板法计算。对于 $T$ ：隔出所有分配情况（ $T$ 每位至少为 $1$ ），即 $C ^ {k-1} _ {i-1}$。对于 $A$ ：先使 $A$ 和 $T$ 数组相同，剩下 $n-i$ 个自由分配（可以为 $0$ ），即 $C ^ {k-1} _ {n-i+k-1}$ 。$B$ 与 $A$ 同理。三个全部乘起来就是每个 $T$ 总和为 $i$ 的所有情况 感谢 $rls$ 的讲解 代码 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;const int maxn = 1e6 + 5;const int mod = 998244353;ll qpow(ll a,ll b,ll mod)&#123; ll ans=1; while(b)&#123; if(b&amp;1) ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;ll n,m,k,ans,jc[maxn],inv[maxn];ll C(int s,int x)&#123; return 1ll*jc[x]*inv[s]%mod*inv[x-s]%mod;&#125;int solve()&#123; scl(n); scl(m); scl(k); rep(i,k,min(n,m)+1)&#123; ans+=C(k-1,i-1)*C(k-1,n-i+k-1)%mod*C(k-1,m-i+k-1)%mod; if(ans&gt;=mod) ans-=mod; &#125; return pf(&quot;%lld\\n&quot;,ans),ans=0;&#125;int main()&#123; jc[0]=inv[0]=1; rep(i,1,maxn) jc[i]=1ll*jc[i-1]*i%mod; inv[maxn-1]=qpow(jc[maxn-1],mod-2,mod); dep(i,maxn-2,1) inv[i]=1ll*inv[i+1]*(i+1)%mod; int _; sc(_); while(_--) solve();&#125; D-Drop Voicing题意 给定一个 $1$ ~ $n$ 的排列，有两种操作： 操作 $1$ : 可以将倒数第二个数放到开头 操作 $2$ : 可以将开头的第一个数放到最后 一种操作重复若干次称为一段。 现在要将排列变成 $1$ ~ $n$ ，求需要的最少段数 思路 因为操作 $2$ 实际上是不会改变相对顺序的，所以只需要找 $LIS$（最长上升子序列）的长度，最后答案就是 $n-maxlen$ 代码 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 2e5 + 5;int a[maxn],dp[maxn];int qaq(int l,int r)&#123; int cnt(0); rep(i,l,r)&#123; if(a[i]&gt;dp[cnt])&#123; dp[++cnt]=a[i]; continue; &#125; int p=lower_bound(dp+1,dp+cnt+1,a[i])-dp; dp[p]=a[i]; &#125; return cnt;&#125;int solve()&#123; int n,ans(0); sc(n); rep(i,1,n+1) sc(a[i]),a[i+n]=a[i]; rep(i,1,n+1) ans=max(ans,qaq(i,i+n)); return pf(&quot;%d\\n&quot;,n-ans);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; E-Bogo Sort题意： 给定置换，求有多少排列可以通过这个置换变成顺序 思路： 求所有环长的 $lcm$ ，无脑Java 备注： 贼快朋友们，76ms 代码： 123456789101112131415161718192021222324252627282930import java.math.*;import java.util.*;import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException &#123; // 这句是io流包装，记住就好 StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); int n=(int) in.nval; int[] a=new int[100005]; int[] vis=new int[100005]; for(int i=1;i&lt;=n;i++)&#123; in.nextToken(); a[i]=(int) in.nval; &#125; BigInteger ans=BigInteger.ONE; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]==0)&#123; int cnt=0,t=i; while(vis[t]==0) &#123; cnt++; vis[t]=1; t=a[t]; &#125; ans=ans.multiply(BigInteger.valueOf(cnt)).divide(ans.gcd(BigInteger.valueOf(cnt))); &#125; &#125; out.println(ans); out.flush(); &#125;&#125; I-Hard Math Problem题意 一个 $G$ 需要相邻一个 $H$ 和 $E$ ，问在无限大的网格中最多能放进多少个 $G$ 代码 10.666667","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"2020 Multi-University Training Contest 2","slug":"杭电 (2)","date":"2020-07-23T14:22:22.000Z","updated":"2021-02-22T19:08:46.041Z","comments":true,"path":"2020/07/23/杭电 (2)/","link":"","permalink":"http://wzgshyvin.github.io/2020/07/23/%E6%9D%AD%E7%94%B5%20(2)/","excerpt":"7.23 状态极差的杭电2","text":"7.23 状态极差的杭电2 1001-Total Eclipse题意 给定一个 $n$ 个点的图，每个点有一权值 $b$ ，每次选择 $k$ 个相互连通的点，使其中每个点权值减一，问最少需要多少操作可以使所有的点权值都为 $0$（每次选择的 $k$ 必须最大） 思路 先将节点按权值从大到小排序，然后依次遍历点 $id_i$ ，将之前遍历过且与 $id_i$ 不在同一联通块内的点 $v$ 与 $id_i$ 合并，并将父亲设为 $id_i$ ，每个点对答案的贡献为 $b_i-b_{father_i}$ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 1e9 + 7;int a[maxn],b[maxn],f[maxn],fa[maxn];int tot,vis[maxn],head[maxn];int nex[maxn&lt;&lt;1],to[maxn&lt;&lt;1];void add(int u,int v)&#123; nex[++tot]=head[u]; head[u]=tot; to[tot]=v;&#125;int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;int cmp(int x,int y)&#123; return b[x]&gt;b[y];&#125;int solve()&#123; int n,m; sc(n); sc(m); ll ans(0); rep(i,1,n+1) a[i]=f[i]=i,sc(b[i]),vis[i]=fa[i]=0; sort(a+1,a+n+1,cmp); while(m--)&#123; int u,v; sc(u); sc(v); add(u,v); add(v,u); &#125; rep(i,1,n+1)&#123; int ind=a[i]; vis[ind]++; for(int j=head[ind];~j;j=nex[j])&#123; if(!vis[to[j]]) continue; int t=find(to[j]); if(t==ind) continue; f[t]=fa[t]=ind; &#125; &#125; rep(i,1,n+1) ans+=b[i]-b[fa[i]]; rep(i,0,tot+1) head[i]=-1; tot=0; return pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; mst(head,-1); int _; sc(_); while(_--) solve();&#125; 1006-The Oculus题意 每个数都有唯一的斐波那契表示，即 $A=\\sum_{i=1}^nb[i] * F_i$ ，$b[i]$ 为 $0$ 或 $1$ 且相邻为不同为 $1$ 。给定 $A$ 、$B$ 、$C$ 的斐波那契表示，$C=A * B$ ，但是 $C$ 的斐波那契表示中有一个 $1$ 被替换为了 $0$ ，求此位数 思路 考虑直接嗯搞。根据哈希思想，利用一个大质数/双模数就降低被卡的可能，改成大质数就过了（没过我就写双模去了） 坑点 $C$ 是 $2e6$ 的，别开小了 补充 自然溢出就能过的，只是我们最开始的单模不能过罢了 1010-Lead of Wisdom题意 有 $n$ 个装备 $k$ 个类型，每个装备有 $a$ 、$b$ 、$c$ 、$d$ 四种属性，要求每种类型选一个且使得 $Sum=(100+\\sum a) * (100+\\sum b) * (100+\\sum c) * (100+\\sum d)$ 思路 嗯搜 我自己也不知道为啥正着搜就t啊 代码 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;struct node&#123; int a,b,c,d; &#125;;vector&lt;node&gt;vv[55];int n,k; ll ans;void dfs(int t,int A,int B,int C,int D)&#123; if(!t) return ans=max(ans,1ll*A*B*C*D),(void)0; int sz=vv[t].size(); if(!sz) return dfs(t-1,A,B,C,D); rep(i,0,sz) dfs(t-1,A+vv[t][i].a,B+vv[t][i].b,C+vv[t][i].c,D+vv[t][i].d);&#125;int solve()&#123; sc(n); sc(k); ans=0; rep(i,1,n+1)&#123; int t,a,b,c,d; sc(t); sc(a); sc(b); sc(c); sc(d); vv[t].push_back(&#123;a,b,c,d&#125;); &#125; dfs(k,100,100,100,100); rep(i,1,k+1) vv[i].clear(); return pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 1012-String Distance题意 给定 $1e5$ 的串 $S$ 和 $20$ 的 $T$ ，$1e5$ 的询问，每次给定 $l$ 和 $r$ ，求 $S_l$ 到 $S_r$ 和 $T$ 的 $lcs$ 长度 思路 $lcs$ 标配 $dp$ ？预处理出对于每个 $i$ 位第 $j$ 个字符最先出现的位置（记为 $pos[j][i]$），利用 $pos$ 进行转移 代码 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;const int maxn = 1e5 + 5;char s[maxn],t[25]; int n,m;int pos[26][maxn],dp[25][25];int lcs(int l,int r)&#123; mst(dp,0x3f); dp[0][0]=l-1; rep(i,0,m) rep(j,0,i+1)&#123; dp[i+1][j]=min(dp[i+1][j],dp[i][j]); if(dp[i][j]&gt;=r) continue; dp[i+1][j+1]=min(dp[i+1][j+1],pos[t[i+1]-&#x27;a&#x27;][dp[i][j]+1]); &#125; dep(i,m,1) rep(j,i,m+1) if(dp[j][i]&lt;=r) return i; return 0;&#125;void solve()&#123; scs(s+1); n=strlen(s+1); scs(t+1); m=strlen(t+1); dep(i,n,1)&#123; if(i==n) rep(j,0,26) pos[j][n+1]=n+1; rep(j,0,26) pos[j][i]=pos[j][i+1]; pos[s[i]-&#x27;a&#x27;][i]=i; &#125; int q; sc(q); while(q--)&#123; int l,r; sc(l); sc(r); int sub=2*lcs(l,r); pf(&quot;%d\\n&quot;,r-l+1+m-sub); &#125;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"HDOJ","slug":"HDOJ","permalink":"http://wzgshyvin.github.io/tags/HDOJ/"}]},{"title":"2020 Multi-University Training Contest 1","slug":"杭电 (1)","date":"2020-07-20T14:22:22.000Z","updated":"2021-02-22T19:05:45.783Z","comments":true,"path":"2020/07/20/杭电 (1)/","link":"","permalink":"http://wzgshyvin.github.io/2020/07/20/%E6%9D%AD%E7%94%B5%20(1)/","excerpt":"7.20 卡字符串的杭电1","text":"7.20 卡字符串的杭电1 1004-Distinct Sub-palindromes题意 计算具有最少回文子串且长度为 $n$ 的字符串数量 思路 当 $n=1$ 时，答案为 $26$ 当 $n=2$ 时，答案为 $26^2$ 当 $n&gt;3$ 时，最少的回文子串数为 $3$ ，即 $abcabcabc$ 的循环，所以此时答案为 $26 * 25 * 24$ 当 $n=3$ 时，虽然最少的回文子串数也为3，但此时不论子串内部怎么排，其最少回文子串数均为3，故此时的答案为 $26^3$ 1011-Minimum Index题意 给定一个串 $s$ ，求 $s$ 所有前缀的后缀序最小的下标的 $1112$ 进制值 思路 题解是用 $Lyndon$ 。作为一个乱搞选手，考虑乱搞（？）。 最初步的想法是：如果当前位比上一个的结果大，一直减到前面连续小的第一个，比如 $baaab$ 减到 $2$（下标 $1$ 开始）；如果当前位比之前的小，当前位一定是最优的；如果当前位和之前的一样，优先取当前位，参考 $aaa$ 。 需要记录位置，考虑双端队列的形式。如果当前位置较之前优，之前的就不需考虑；如果是连续的一段相同且最小的值，直接记录位置；遇到第一个不相同且较大的值时，一定是连续段的最前一个最优，往前更新。 $upd$ ：看了 $Lyndon$ 心态崩了，感觉其实差不多呜呜呜呜呜呜呜 代码 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 1e6 + 5;const int mod = 1e9 + 7;char s[maxn];int pos[maxn];int solve()&#123; scs(s+1); int len=strlen(s+1); int cur=0,ans=0,pow=1,pre=1; rep(i,1,len+1)&#123; pos[++cur]=i; while(cur&gt;pre&amp;&amp;s[i]&gt;s[i-(pos[cur]-pos[cur-1])]) cur--; while(cur&gt;pre&amp;&amp;s[i]&lt;s[i-(pos[pre+1]-pos[pre])]) pre++; // 其实核心就这两句qwq // 首先是每次都要处理的 到每一位都需要更新之前的状态 // 有点难讲qwq 通过举例子来吧 比如aabaaab // 处理到第一个b时 减到前面连续小的第一个 当前答案为1 // 处理到第二个b时 通过每次跳pos[cur]-pos[cur-1]来判断是否还在连续的状态 ans+=1ll*pow*pos[cur]%mod; if(ans&gt;=mod) ans-=mod; pow=1112ll*pow%mod; &#125; return pf(&quot;%d\\n&quot;,ans);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"HDOJ","slug":"HDOJ","permalink":"http://wzgshyvin.github.io/tags/HDOJ/"}]},{"title":"2020牛客暑期多校训练营（第四场）","slug":"牛客 (4)","date":"2020-07-20T14:22:22.000Z","updated":"2021-02-22T19:07:55.037Z","comments":true,"path":"2020/07/20/牛客 (4)/","link":"","permalink":"http://wzgshyvin.github.io/2020/07/20/%E7%89%9B%E5%AE%A2%20(4)/","excerpt":"7.20 节目效果拉满的牛客4","text":"7.20 节目效果拉满的牛客4 B-Basic Gcd Problem题意 定义函数 $f$ 在 $x&gt;1$ 有 $f_c(x)=\\max_{i=1…x-1}c*f_c(gcd(i,x))$，在 $x=1$ 时 $f_c(x)=1$，给定 $c$ 和 $x$，求 $f$ 思路 即求 $c$ 的 $x$ 因子个数次方 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;const int maxn = 1e6 + 5;const int mod = 1e9 + 7;int p[maxn],vis[maxn],pn;void init()&#123; rep(i,2,maxn)&#123; if(!vis[i]) p[pn++]=i; for(int j=0;j&lt;pn&amp;&amp;i*p[j]&lt;maxn;j++) vis[i*p[j]]=1; &#125; mst(vis,0);&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b&gt;0)&#123; if(b&amp;1) ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;ll cnt[maxn];void dfs(int x)&#123; if(x==1)&#123; cnt[x]=0,vis[x]=1; return;&#125; rep(i,0,pn)&#123; if(p[i]*p[i]&gt;x) break; if(x%p[i]==0)&#123; if(!vis[x/p[i]]) dfs(x/p[i]); cnt[x]=cnt[x/p[i]]+1,vis[x]=1; return; &#125; &#125; cnt[x]=1,vis[x]=1;&#125;int solve()&#123; int n,c; sc(n); sc(c); if(n==1) return pf(&quot;1\\n&quot;); return pf(&quot;%lld\\n&quot;,qpow(c,cnt[n]));&#125;int main()&#123; init(); dep(i,1e6,1) if(!vis[i]) dfs(i); int _; sc(_); while(_--) solve();&#125; C-Count New String题意 给定一个字符串，求此字符串的前缀最大值的前缀最大值的本质不同子串个数。 思路 参考 出来看神仙.jpg 代码。太牛了！！！永远滴神！！！ 《叛逆小转偏偏要乱搞过板子题》 倒着处理。每次和后一位对比，如果比后一位小或者和后一位一样，那后面已经不会有变化了，所以只用加上包含当前位的所有方案数；如果比后一位大，那就需要更新，更新到和此位一样或者更大的位置。$t$ 记录的是这个位数差。每次更新答案就是 $1+d$ 到 $t+d$ 的等差为 $1$ 的数列求和，其中 $d=len-i-t+1$。 同时每次记录当前状态。其实和 $sa$ 的最后相邻 $lcp$ 去重一个道理。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define pf printf#define scs(x) scanf(&quot;%s&quot;, x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;char s[maxn];vector&lt;vector&lt;int&gt;&gt;vv;int solve()&#123; scs(s+1); int len=strlen(s+1); vector&lt;int&gt;tmp(10); s[len+1]=&#x27;z&#x27;+1; ll ans(0); dep(i,len,1)&#123; int val=s[i]-&#x27;a&#x27;,t(0); rep(j,0,val) t+=tmp[j]; t++; if(s[i]&lt;=s[i+1])&#123; ans+=len-i+1; tmp[val]++; vv.push_back(tmp); &#125; else if(s[i]&gt;s[i+1])&#123; rep(j,0,val) tmp[j]=0; rep(j,0,t)&#123; tmp[val]++; vv.push_back(tmp); &#125; ans+=1ll*t*(t+(len-i-t+1)*2+1)/2; &#125; // 如果前一位是大的 说明后面要更新 // 更新到不用更新的地方的串数量 // 如果是小的 只用加上包含此位的所有串数量 &#125; // 去重 相邻的lcp sort(vv.begin(),vv.end()); rep(i,1,vv.size()) rep(j,0,10)&#123; ans-=min(vv[i-1][j],vv[i][j]); if(vv[i-1][j]!=vv[i][j]) break; &#125; return pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; D-Dividing Strings题意 给定一个数字串，问怎么划分能使划分中的数字最大最小差值最小。划分的串不能包含前导零。 思路 模拟。每个串先拆为等长的数字串，枚举因数取 $min$ 。再考虑进位情况：如果进位是三位即以上，找 $10$ 开头的子串，到结尾/下一个 $9$ /下一个 $10$ 为止，取为一个单位长度。如果进位是两位，一个 $1$ 后面跟上一个数，剩下的全取个位数。注意当 $1$ 为末尾的时候要判掉。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)using namespace std;const int maxn = 1e5 + 5;int n; char s[maxn];int qaq()&#123; int len(0); rep(i,1,n-1) if(s[i]==&#x27;1&#x27;&amp;&amp;s[i+1]==&#x27;0&#x27;)&#123; rep(j,i+2,n+2) if(j==n+1||s[j]==&#x27;9&#x27;||(s[j]==&#x27;1&#x27;&amp;&amp;s[j+1]==&#x27;0&#x27;))&#123; len=j-i; break; &#125; break; &#125; if(len&lt;=2||len==n) return 9; int mn(0),mx(0),t(0),ff(0); rep(i,1,n+1) if(ff)&#123; if(ff&gt;0) t=t*10+s[i]-&#x27;0&#x27;,ff++; else t=t*10-s[i]+&#x27;0&#x27;,ff--; if(t&gt;=9) return 9; if(abs(ff)==len)&#123; if(ff&lt;0) mn=max(mn,t); else mx=max(mx,t); t=0; ff=0; &#125; &#125; else&#123; if(s[i]==&#x27;1&#x27;) ff=1,t=0; else if(s[i]==&#x27;9&#x27;) ff=-2,t=1; else return 9; &#125; if(ff) return 9; return mn+mx;&#125;int qwq()&#123; int mn=1e9,mx(0),t(0); rep(i,1,n+1)&#123; if(t) mx=max(mx,t*10+s[i]-&#x27;0&#x27;),t=0; else if(s[i]==&#x27;1&#x27;&amp;&amp;i!=n) t=1; else mn=min(mn,(int)s[i]-&#x27;0&#x27;); &#125; if(mn==1e9||!mx) return 9; return mx-mn;&#125;int slove(int x)&#123; int mn(0),mx(0),t(0),c=1; rep(i,x+1,n+1)&#123; if(i%x==1&amp;&amp;s[i]==&#x27;0&#x27;) return 9; t=t*10+s[i]-s[i-c*x]; if(abs(t)&gt;=9) return 9; if(i%x==0)&#123; if(t&lt;0) mn=max(mn,-t); else mx=max(mx,t); c++; t=0; &#125; &#125; return mn+mx;&#125;int solve()&#123; sc(n); scs(s+1); char a=&#x27;9&#x27;+1,b=&#x27;0&#x27;-1; rep(i,1,n+1) a=min(a,s[i]),b=max(b,s[i]); int mn=b-a; if(s[1]==&#x27;0&#x27;) return pf(&quot;%d\\n&quot;,mn); for(int i=2;i*i&lt;=n;++i) if(n%i==0)&#123; mn=min(mn,slove(i)); if(i*i!=n) mn=min(mn,slove(n/i)); &#125; mn=min(mn,qaq()); mn=min(mn,qwq()); return pf(&quot;%d\\n&quot;,mn);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; H-Harder Gcd Problem题意 将 $1-n$ 不重复地放入两个无交集的集合 $A$ 、$B$且满足所有 $gcd(A[i],B[i])&gt;1$ ，问最大对数 思路 $1$ 到 $n$ 分解质因数。将所有有同一个质因数的放进同一个 $vector$ ，倒着两两匹配。使用过的数打上标记，没使用过的数存进临时使用的 $vector$ 。如果有奇数个，考虑剩一个偶数出来。因为 $2$ 是最小的质数，$2$ 的倍数个数是最多的。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;vector&lt;int&gt;vv[maxn];void init(int x)&#123; int x1=x; vv[x].push_back(x); rep(i,2,x+1)&#123; if(i*i&gt;x) break; if(x%i==0)&#123; vv[i].push_back(x1); while(x%i==0) x/=i; &#125; &#125; if(x&gt;1&amp;&amp;x!=x1) vv[x].push_back(x1);&#125;int vis[maxn];vector&lt;pii&gt;ans;void solve()&#123; int n; sc(n); rep(i,1,n+1) init(i); ans.clear(); dep(i,n,2)&#123; if(vv[i].size()&lt;=1) continue; int cnt(0),tt(0); vector&lt;int&gt;tmp; rep(j,0,vv[i].size())&#123; int x=vv[i][j]; if(!vis[x])&#123; tmp.push_back(x); if(x%2==0) tt=x; &#125; &#125; int sz=tmp.size(); if(sz%2&amp;&amp;tt)&#123; vector&lt;int&gt;::iterator it; for(it=tmp.begin();it!=tmp.end();++it)&#123; if(*it==tt) tmp.erase(it),--it; &#125; sz--; &#125; if(sz&lt;=1) continue; rep(j,0,sz)&#123; int x=tmp[j],y=tmp[j+1]; vis[x]=vis[y]=1,j++; ans.push_back(pii(x,y)); &#125; &#125; pf(&quot;%d\\n&quot;,ans.size()); for(pii x:ans) pf(&quot;%d %d\\n&quot;,x.first,x.second); rep(i,1,n+1) vis[i]=0,vv[i].clear();&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"2020牛客暑期多校训练营（第三场）","slug":"牛客 (3)","date":"2020-07-18T14:22:22.000Z","updated":"2021-02-22T19:05:13.824Z","comments":true,"path":"2020/07/18/牛客 (3)/","link":"","permalink":"http://wzgshyvin.github.io/2020/07/18/%E7%89%9B%E5%AE%A2%20(3)/","excerpt":"7.18 打一半电脑死机的牛客3","text":"7.18 打一半电脑死机的牛客3 A-Clam and Fish题意 共n天，每天共有四种状态 无鱼无蛤蜊 无鱼有蛤蜊 有鱼无蛤蜊 有鱼有蛤蜊 每天可进行的操作： 做鱼饵（当天有蛤蜊） 钓鱼（当天有鱼时不消耗鱼饵，无鱼时可用一个鱼饵换一条鱼） 啥也不做 求出最多可以抓多少鱼 思路 有鱼的时候抓鱼一定最优，没有鱼的时候先考虑有鱼饵的情况，如果当前鱼饵数小于之后没有鱼的天数，则收集鱼饵，否则就用鱼饵换鱼。这样既没鱼也没鱼饵的时候就可以直接用鱼饵换鱼。 B-Classical String Problem题意 给定一个字符串 $s$，规定两种操作： $A$ 操作：输出 $s$ 的第 $x$ 个字符； $M$ 操作：将 $s$ 的最右边 $x$ 个字符串移到最左边或者将 $s$ 的最左边 $x$ 个字符串移到最右边 思路 设一个变量 $cur$ ，初始值为 $0$ ，题目本质就是 M 操作时改变 $cur$ 的值，左移右就是让 $cur$ 加上 $x$ 后对字符串长度 $len$ 取模，右移左就是让 $cur$ 减去 $x$ 后对字符串长度 $len$ 取模，$A$ 操作时以 $cur$ 为起点取第 $x$ 个字符，为了保证 $cur$ 的值不越过 $[0,len-1]$ 这个范围，先将 $x$ 对 $len$ 取模，再在计算 $cur$ 时多加一个 $len$ 代码 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)using namespace std;const int maxn = 2e6 + 5;char s[maxn];void solve()&#123; scs(s); int len=strlen(s),cur(0); int q; sc(q); getchar(); while(q--)&#123; char c; int t; c=getchar(); sc(t); getchar(); if(c==&#x27;A&#x27;) pf(&quot;%c\\n&quot;,s[(t+cur+len-1)%len]); else&#123; cur+=t; if(t&lt;0) cur+=len; cur%=len; &#125; &#125; &#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; D-Points Construction Problem题意 无限大的平面上全部为白点，选择刚好 $n$ 个涂黑，需要有恰好 $m$ 对相邻点颜色不同。求出其中一种方案。 思路 呜呜气死了场上没开这题血亏。就是个简单构造题。 已知有 $n$ 个黑点的情况下，最多有 $4*n$ 对相邻点颜色不同，即分散开来的每个点的四周；而最少的情况是补成方块（或者最接近方块）的形状。同时能发现不可能有奇数点对。非法情况就只有 $m$ 为奇数、$m$ 过小、$m$ 过大，而区间内的任意偶数都能通过固定形状变化而得。 最大情况判掉，反正好写。 只有一列的情况也选择特判，好写一点。因为 $n\\leq 50$ ，所以先排出一列间隔 $100$ 的点。之后根据 $m$ 的值合并点。最少的情况为 $n$ 个点排成连续的直线，此时有 $2*n+2$ 个点对。 因为 $n\\leq 50$ ，所以最多只有 $7$ 种排列情况。逐一判断。 对于每个排列情况：设每列最多有 $x$ 个。最少情况是所有点排成矩形（或者最接近矩形）；最多情况是先排一个 $x*x$ 的方块，剩下的点排成一列，大概是个小旗的形状。 $m$ 在当前排列合法时就可以从最多的情况一个一个点合并。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e4 + 5;const int mod = 1e9 + 7;pii ans[maxn];int slove(int x,int n,int m)&#123; int t1=2*(x+n/x)+2*(n%x&gt;0),t2=4*x+2*(n-x*x); if(t1&gt;m) return 0; int r=n-x*x,d=t2-m,u=1,cnt(0); rep(i,1,x+1) rep(j,1,x+1) ans[cnt++]=pii(i,j); rep(i,1,r+1) ans[cnt++]=pii(x+i,1); // 根据差值调整 int v=cnt-1; while(v&gt;=cnt-d/2)&#123; rep(j,2,x+1)&#123; if(i&lt;cnt-d/2) break; ans[i]=pii(x+u,j),v--; &#125; u++; &#125; rep(i,0,cnt) pf(&quot;%d %d\\n&quot;,ans[i].first,ans[i].second); return 1;&#125;int solve()&#123; int n,m; sc(n); sc(m); int q=1; while(q*q&lt;=n) q++; q--; int u=4*q,e=n-q*q; u+=e?n&lt;=q*(q+1)?2:4:0; if(m&lt;u||m&amp;1||m&gt;4*n) return pf(&quot;No\\n&quot;); if(m==4*n)&#123; pf(&quot;Yes\\n&quot;); rep(i,1,n+1) pf(&quot;%d %d\\n&quot;,i,i); return 0; &#125; int t=4*n,d=t-m; if(m&gt;=2*n+2)&#123; rep(i,0,n) ans[i]=pii(100*i,100*i); pf(&quot;Yes\\n&quot;); int qaq=1; dep(i,n-1,n-d/2) ans[i]=pii(qaq,0),qaq++; rep(i,0,n) pf(&quot;%d %d\\n&quot;,ans[i].first,ans[i].second); return 0; &#125; pf(&quot;Yes\\n&quot;); rep(i,2,8) if(slove(i,n,m)) return 0; // 只用讨论1-7列的情况&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; F-Fraction Construction Problem题意 给定 $a$ 、$b$，求满足$\\frac{c}{d}-\\frac{e}{f}=\\frac{a}{b}$的 $c$ 、$d$ 、$e$ 、$f$ ，其中 $d$ 和 $f$ 需小于 $b$ 思路 首先考虑 $a$ 和 $b$ 不互质的情况（题目没有保证互质）。可以想到直接让 $c/d$ 为整数，$e$ 和 $f$ 相减一下就得到了。 通分后有 $\\frac{c * f-e * d}{d * f}=\\frac{a}{b}$（此时 $a$ 、$b$ 互质）。则必须有 $d*f\\equiv 0$ $(mod$ $b)$ ，此题需要 $d$ 、$f$ 尽量小即直接考虑 $d * f=b$。 可以初步判掉一部分无解的情况：$b$ 为 $1$ 时和 $b$ 为质数显然无解。 当 $d$ 、$f$ 互质时有 $c * f-e * d=1$ 即 $a * c * f-a * e * d=a$ 。故求 $c$ 、$e$ 可以通过 $exgcd$（最后再乘上 $a$ ）。 还要注意的就是当 $b$ 只有一个质因数时，不存在互质且积为 $b$ 的 $d$ 、$f$，此时无解。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;const int maxn = 2e6 + 5;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1; y=0; return a; &#125; else&#123; ll ans=exgcd(b,a%b,y,x); y-=(a/b)*x; return ans; &#125;&#125;int p[maxn],vis[maxn],pn;void init()&#123; rep(i,2,maxn)&#123; if(!vis[i]) p[pn++]=i; for(int j=0;j&lt;pn&amp;&amp;i*p[j]&lt;maxn;j++) vis[i*p[j]]=1; &#125; mst(vis,0); rep(i,0,pn) vis[p[i]]++; &#125;int solve()&#123; ll a,b; scl(a); scl(b); ll g=__gcd(a,b),c,d,e,f; if(g&gt;1)&#123; c=a/b+1; // 不能取上整 参考样例2 2 d=1; a/=g; b/=g; e=c*b-a; f=b; return pf(&quot;%lld %lld %lld %lld\\n&quot;,c,d,e,f); &#125; if(b==1||vis[b]) return pf(&quot;-1 -1 -1 -1\\n&quot;); // 先约分再判质数是a%b==0的情况是有解的 // 为1时没有比1小的正数 为质数时无法分解 vector&lt;int&gt;vv; ll tb=b; for(int i=0;1ll*p[i]*p[i]&lt;=tb;++i)&#123; if(tb%p[i]==0)&#123; ll res=1; while(tb%p[i]==0) tb/=p[i],res*=p[i]; // 这么计算res可以在后一步枚举的时候保证b/res和res是互质的 vv.push_back(res); &#125; &#125; if(tb&gt;1) vv.push_back(tb); // 剩下的大质数也记得要存 if(vv.size()==1) return pf(&quot;-1 -1 -1 -1\\n&quot;); // 只有一个质因数的情况也无解 可以感性理解一下=。= for(int x:vv)&#123; ll d=x,f=b/x,q=exgcd(f,-d,c,e); // d和f相乘为b且互质 ll tt=(ll)(max((1.*c-1)/d,(1.*e-1)/f))+1; if(c&lt;=0||e&lt;=0) c+=tt*d,e+=tt*f; // 小于0时加到大于0 if(c*f&lt;e*d) swap(c,e),swap(d,f); // 保证结果是正数 c*=a; e*=a; // 别忘了 return pf(&quot;%lld %lld %lld %lld\\n&quot;,c,d,e,f); &#125;&#125;int main()&#123; init(); int _; sc(_); while(_--) solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"2020牛客暑期多校训练营（第二场）","slug":"牛客 (2)","date":"2020-07-13T14:22:22.000Z","updated":"2021-02-22T17:14:58.674Z","comments":true,"path":"2020/07/13/牛客 (2)/","link":"","permalink":"http://wzgshyvin.github.io/2020/07/13/%E7%89%9B%E5%AE%A2%20(2)/","excerpt":"7.13 补了好多好多题的牛客2","text":"7.13 补了好多好多题的牛客2 A-All with Pairs题意 定义函数 $f(s,t)$ 为 $s$ 前缀和 $t$ 后缀的最长相同长度。给定 $n$ 个串，求两两 $f$ 和。 思路 对每个前缀后缀进行哈希，计算每个前缀对应的后缀有几个，但是直接算有重复，要靠 $next$ 去重（题解讲得挺清楚的其实）。 坑点 卡单模数哈希，气死了，贴了双哈希代码，堂堂正正过题好吧 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;const int mod = 998244353;const ll inf = 1e9;int seed[2]=&#123;18052103,27174403&#125;,bas[2][maxn];ll hs[maxn];char s[maxn];int len[maxn],ind[maxn],nex[maxn],sub[maxn];map&lt;ll,int&gt;aaa;int solve()&#123; int n,ans(0); sc(n); ind[1]=bas[0][0]=bas[1][0]=1; rep(j,0,2) rep(i,1,maxn) bas[j][i]=1ll*bas[j][i-1]*seed[j]%mod; rep(i,1,n+1)&#123; scs(s+ind[i]); len[i]=strlen(s+ind[i]); ind[i+1]=ind[i]+len[i]; ll th[2]=&#123;0,0&#125;; dep(j,len[i]-1,0)&#123; rep(k,0,2)&#123; th[k]=1ll*th[k]*seed[k]%mod+(s[j+ind[i]]-&#x27;a&#x27;+1); if(th[k]&gt;=mod) th[k]-=mod; &#125; aaa[th[0]*inf+th[1]]++; &#125; mst(th,0); rep(j,0,len[i])&#123; rep(k,0,2)&#123; th[k]+=1ll*bas[k][j]*(s[j+ind[i]]-&#x27;a&#x27;+1)%mod; if(th[k]&gt;=mod) th[k]-=mod; &#125; hs[ind[i]+j]=th[0]*inf+th[1]; &#125; &#125; rep(i,1,n+1)&#123; int k=0,tl=len[i]; nex[ind[i]]=0; rep(j,ind[i]+1,ind[i+1])&#123; while(k&amp;&amp;s[j]!=s[k+ind[i]]) k=nex[k+ind[i]-1]; if(s[j]==s[k+ind[i]]) k++; nex[j]=k; &#125; dep(j,ind[i+1]-1,ind[i])&#123; ans+=1ll*(aaa[hs[j]]-sub[j])*tl%mod*tl%mod; if(ans&gt;=mod) ans-=mod; tl--; sub[nex[j]+ind[i]-1]+=aaa[hs[j]]; // 直接减也会减重复 &#125; &#125; return pf(&quot;%d\\n&quot;,ans);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; B-Boundary题意 给定 $n$ 个点，问最多有几个点能在过原点的同一个圆上。 思路 先枚举一个点 $P$ ，再枚举所有点 $A$ ，根据角度和 $A$ 相对 $OP$ 位置统计个数，取最大值。 坑点 $mx$ 初始值要 $1$ ，保证至少有一个点。我代码在一个点/全部点共线的情况执行不到 $mx$ 的赋值 $(double)tmp1 / tmp2$ 不要写成 $1.0 * tmp1 / 1.0 * tmp2$（小庄血泪之痛呜呜呜） 代码 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define pf printf#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;struct point&#123; ll x,y,d;&#125;p[2005];void solve()&#123; ll n,mx=1; scl(n); rep(i,0,n)&#123; ll x,y; scl(x),scl(y); p[i].x=x,p[i].y=y; p[i].d=x*x+y*y; &#125; rep(i,0,n)&#123; map&lt;double,ll&gt;aaa; rep(j,0,n)&#123; if(i==j) continue; ll cr=p[i].x*p[j].y-p[j].x*p[i].y; if(!cr) continue; cr=cr&lt;0?-1:1; ll tx=p[i].x-p[j].x; ll ty=p[i].y-p[j].y; ll dt=tx*tx+ty*ty; // |AP| ll del=p[j].d+dt-p[i].d,re=4ll*dt*p[j].d; // 余弦定理 ll op=del&lt;0?-1:del?1:0,ff=1; ff=op*cr==1?-1:op*cr?1:0; del*=ff*del; double tt=(double)del/re; ll res=++aaa[tt]; mx=max(mx,res+1); &#125; &#125; pf(&quot;%lld\\n&quot;,mx);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; C-Cover the Tree题意 给定一棵树，用最少的链覆盖树的每一条边（不同链可重叠，可只覆盖一个点）。 思路 最少的链数一定是叶节点两两相连，所以最少链数为（ 叶节点数 $+1$ ）$/2$ 。然后难就难在怎么将叶节点两两配对，看了题解意识到可以用 $DFS$ 序，将叶节点按 $DFS$ 序排列后分为前后两半按顺序配对就可以啦√ 代码 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;int in[maxn],q[maxn],vis[maxn];vector&lt;int&gt;vv;int solve()&#123; srand(time(0)); int n; sc(n); rep(i,1,n)&#123; int u,v; sc(u); sc(v); in[u]++; in[v]++; &#125; if(n==1) return pf(&quot;1 1\\n&quot;); rep(i,1,n+1) if(in[i]==1) vv.push_back(i); int sz=vv.size(),cnt(0); rep(i,0,sz)&#123; int t=rand()%sz; while(vis[t]) t=rand()%sz; q[cnt++]=vv[t]; vis[t]++; &#125; pf(&quot;%d\\n&quot;,(sz+1)/2); rep(i,0,sz)&#123; pf(&quot;%d %d\\n&quot;,q[i],q[i+1]); if(sz%2&amp;&amp;!i) continue; i++; &#125; return pf(&quot;\\n&quot;);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; D-Duration题意 求秒数差 思路 乘一下加一下减一下 代码 1234567891011121314#include&lt;bits/stdc++.h&gt;#define pf printfusing namespace std;int solve()&#123; int a,b,c,t1,t2; scanf(&quot;%d:%d:%d&quot;,&amp;a,&amp;b,&amp;c); t1=a*3600+b*60+c; scanf(&quot;%d:%d:%d&quot;,&amp;a,&amp;b,&amp;c); t2=a*3600+b*60+c; return pf(&quot;%d\\n&quot;,abs(t1-t2));&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; E-Exclusive OR题意 给定长度 $n$ 的数组 $a$ ，求选择 $1-n$ 个数时最大异或和。 思路 数据范围在 $2^{18}$ ，所以 $i\\geq 20$ 时有 $ans[i]=a[i-2]$。前 $20$ 个用异或卷积求（但 $fwt$ 我可能也讲不来）。 代码 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 2e5 + 5;const int N = 1 &lt;&lt; 18;int a[N],b[N],ans[maxn];void fwt_xor(int *a,int op)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;++k)&#123; int x=a[j+k],y=a[i+j+k]; a[j+k]=x+y,a[i+j+k]=x-y; if(op==-1) a[j+k]/=2,a[i+j+k]/=2; &#125;&#125; void solve()&#123; int n; sc(n); rep(i,1,n+1)&#123; int t; sc(t); a[t]=1; &#125; fwt_xor(a,1); b[0]=1; rep(i,1,20)&#123; fwt_xor(b,1); rep(j,0,N) b[j]*=a[j]; fwt_xor(b,-1); rep(j,0,N) if(b[j]) ans[i]=j,b[j]=1; &#125; rep(i,20,n+1) ans[i]=ans[i-2]; rep(i,1,n+1) pf(&quot;%d &quot;,ans[i]);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; F-Fake Maxpooling题意 给定一矩阵 $A$ ，其中第 $(i, j)$ 位上对应的数字是 $lcm(i, j)$ ，求对于整个矩阵中的每个k×k大小的子矩阵中最大值之和。 思路 首先对矩阵进行预处理，直接暴力求的复杂度是 $O(nmlogn)$，看题解之后用线性方法优化到了 $O(nm)$ 。然后滑动窗口对 $A$ 的每一行求出区间 $(j-k,j)$ 的最大值（利用单调队列进行求解），并储存在 $g[i,j]$ 中（因为这题内存卡的比较紧，所以重复利用了一下之前的 $g$ 数组），然后对纵向用同样的方式求出 $(g[i-k][j],g[i][j])$ 的最大值，所得的结果就是子矩阵的最大值，然后求个和答案就出来啦。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;int a[5005][5005],q[5005*5005];int solve()&#123; int n,m,k; sc(n); sc(m); sc(k); ll ans(0); rep(i,1,n+1) rep(j,1,m+1) a[i][j]=i/__gcd(i,j)*j; if(k==1) rep(i,1,n+1) rep(j,1,m+1) ans+=a[i][j]; if(k==1) return pf(&quot;%lld\\n&quot;,ans); q[0]=1e9; rep(i,1,n+1)&#123; int l=1,r=0; rep(j,1,m+1)&#123; while(a[i][j]&gt;q[r]) --r; q[++r]=a[i][j]; while(r-l+1&gt;k) l++; a[i][j]=q[l]; &#125; &#125; rep(j,k,m+1)&#123; int l=1,r=0; rep(i,1,n+1)&#123; while(a[i][j]&gt;q[r]) --r; q[++r]=a[i][j]; while(r-l+1&gt;k) l++; a[i][j]=q[l]; if(i&gt;=k) ans+=1ll*a[i][j]; &#125; &#125; return pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; G-Greater and Greater题意 给定长度为 $n$ 的数组 $a$ 和长度为 $m$ 的数组 $b$ ，问 $a$ 有几个长度为 $m$ 的连续子段满足任意 $a_{l+i}&gt;b_i$ 。 思路 考虑用 $bitset$ 且反向求解。将 $a$ 、$b$ 排序后，枚举 $b[i]$ ，$cur$ 维护 $a$ 中小于 $b[i]$ 的下标，右移对应位数$-1$ 得到在 $a$ 中的状态，或起来得到 $ans$ 。最后计算在 $1$ ~ $(n-m+1)$ 中 $ans$ 为 $0$ 的个数。 代码 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;pii a[maxn],b[maxn];bitset&lt;maxn&gt;ans,cur;#define f first#define s secondint solve()&#123; int n,m; sc(n); sc(m); rep(i,1,n+1) sc(a[i].f),a[i].s=i; rep(i,1,m+1) sc(b[i].f),b[i].s=i; sort(a+1,a+n+1); sort(b+1,b+m+1); int k=1; rep(i,1,m+1)&#123; while(k&lt;=n&amp;&amp;a[k].f&lt;b[i].f) cur.set(a[k].s),k++; ans|=cur&gt;&gt;(b[i].s-1); &#125; int cnt(0); rep(i,1,n-m+2) if(!ans[i]) cnt++; return pf(&quot;%d\\n&quot;,cnt);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; J-Just Shuffle题意 给一个数组 $a$ 求置换 $k$ 次能得到 $a$ 的数组，$k$ 是大质数。 思路 找出 $a$ 的所有环，对每个环求逆元。 代码 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 2e5 + 5;int a[maxn],ans[maxn],vis[maxn];void solve()&#123; int n,k; sc(n); sc(k); rep(i,1,n+1) sc(a[i]); rep(i,1,n+1) if(!vis[i])&#123; vector&lt;int&gt;vv; int q=a[i],cnt(0); // 找环 while(!vis[q]) vv.push_back(q),vis[q]++,q=a[q]; int sz=vv.size(),inv; rep(j,0,sz) if(1ll*k*j%sz==1) inv=j; rep(i,0,sz) ans[vv[i]]=vv[(i+inv)%sz]; &#125; rep(i,1,n+1) pf(&quot;%d &quot;,ans[i]);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"2020牛客暑期多校训练营（第一场）","slug":"牛客 (1)","date":"2020-07-12T14:22:22.000Z","updated":"2021-02-22T19:02:56.071Z","comments":true,"path":"2020/07/12/牛客 (1)/","link":"","permalink":"http://wzgshyvin.github.io/2020/07/12/%E7%89%9B%E5%AE%A2%20(1)/","excerpt":"7.12 开始就自闭的牛客1","text":"7.12 开始就自闭的牛客1 A-B-Suffix Array题意 定义数组 $B(s_1s_2…s_k)$ 。对于 $B_i$ 当存在 $j$ 满足 $j&lt;i$ 且 $s_j=s_i$ 时有 $i-max(j)$ ，否则为0。给定串 $S$ ，求 $S$ 每个后缀的 $B$ 函数的字典序 思路 有排序考虑sa。构造一个 $C$ 函数，具体定义和 $B$ 差不多不过从末尾开始。通过 $C$ 函数的后缀排序得到答案。 坑点 多组数据，记得清空 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; pii;const int maxn = 1e5 + 5;const int mod = 998244353;int s[maxn],len,qwq;int sa[maxn],rk[maxn];int height[maxn];int t1[maxn],t2[maxn],c[maxn];int best[20][maxn];char ss[maxn];void getsa(int *s,int n,int m)&#123; int *x=t1,*y=t2; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[i]=s[i]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[i]]]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p=0; rep(i,n-k,n) y[p++]=i; rep(i,0,n) if(sa[i]&gt;=k) y[p++]=sa[i]-k; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[y[i]]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[y[i]]]]=y[i]; swap(x,y); p=1; x[sa[0]]=0; rep(i,1,n) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++; if(p&gt;=n) break; m=p; &#125; rep(i,1,n) rk[sa[i]]=i;&#125;struct node&#123; int f,s,id; &#125;p[maxn]; int cmp(node a,node b)&#123; return a.f==b.f?a.s&lt;b.s:a.f&lt;b.f;&#125;int solve()&#123; scs(ss+1); int a=-1,b=-1; mst(rk,0); mst(s,0); mst(sa,0); rep(i,1,len+1)&#123; if(ss[i]==&#x27;a&#x27;) s[i]=a&gt;=0?i-a+1:1,a=i; else s[i]=b&gt;=0?i-b+1:1,b=i; &#125; getsa(s+1,len+1,len+1); a=-1,b=-1; dep(i,len,1)&#123; if(ss[i]==&#x27;a&#x27;) p[i]=b&gt;=0?(node)&#123;b-i,rk[b],i&#125;:(node)&#123;len-i+1,-1,i&#125;,a=i; else p[i]=a&gt;=0?(node)&#123;a-i,rk[a],i&#125;:(node)&#123;len-i+1,-1,i&#125;,b=i; &#125; sort(p+1,p+len+1,cmp); rep(i,1,len+1) pf(&quot;%d &quot;,p[i].id); return pf(&quot;\\n&quot;);&#125;int main()&#123; while(~sc(len)) solve();&#125; J-Easy Integration题意 积分 思路 找规律 式子 $C_{2*n+1}^n *(n+1)$ ; 考点 公式推导 模逆元 组合数 坑点 预处理数组要开两倍（对不起对不起对不起） 代码 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define pf printf#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;const int maxn = 2e6 + 5;const int mod = 998244353;ll qpow(ll a,ll b,ll mod)&#123; ll ans=1; while(b)&#123; if(b&amp;1) ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;ll n,jc[maxn],inv[maxn];ll C(int s,int x)&#123; return 1ll*jc[x]*inv[s]%mod*inv[x-s]%mod;&#125;int main()&#123; jc[0]=inv[0]=1; rep(i,1,maxn) jc[i]=1ll*jc[i-1]*i%mod; inv[maxn-1]=qpow(jc[maxn-1],mod-2,mod); dep(i,maxn-2,1) inv[i]=1ll*inv[i+1]*(i+1)%mod; while(~sc(n)) pf(&quot;%lld\\n&quot;,qpow(1ll*(n+1)*C(n,2*n+1)%mod,mod-2,mod));&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"不一样的训练日常","slug":"不一样的训练日常","date":"2020-07-12T11:11:59.000Z","updated":"2021-02-22T19:00:16.932Z","comments":true,"path":"2020/07/12/不一样的训练日常/","link":"","permalink":"http://wzgshyvin.github.io/2020/07/12/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E8%AE%AD%E7%BB%83%E6%97%A5%E5%B8%B8/","excerpt":"暑期训练日常记录（吐槽）","text":"暑期训练日常记录（吐槽） 个人训练记录在自己博客队伍训练记录在这里 7.12一开始看到A题的sa就快乐想题学妹过F后决定一起看J推了推式子感觉肯定和组合数有关 猜了个式子能过样例开始嗯写 tle我：这也能t？？？然后改方法好嘛 不t了 wa了然后就调了1e5年 调到学妹找到规律肯定了我猜的结论最后发现数组开小了没乘2对不起对不起对不起对不起对不起老刘还来坐了两小时 瑟瑟发抖晚上头痛就摸了 7.13今天特意八点起（也不是，其实想八点半，热醒的）开始补昨天的A补到裂开 一直wa在0.08% 对拍对得飞起 气得做了个图（……）最后发现没初始化 本地因为单组所以对到飞起对不起赛时啥题都看了 啥题都不会离谱的是我C想到正解了然后……忘了？后来心态崩了随机数交了三发没过赛后发现分数是90 70 90 笑死了F我最开始的写法被5000 5000 1 hack了我就感觉是假算法后来发现加句k==1的特判就过了对不起对不起对不起对不起对不起对不起对不起对不起因为真算法没有特判以为写了假算法所以开始写起假算法wa到自闭B写了一会到比赛结束刚好写完然后样例没过 嘻嘻吃饭时候看题解口出狂言：A应该只是不好想，感觉挺好写的然后写了两小时才过样例还wa了对不起对不起对不起对不起对不起对不起对不起对不起最后发现单模数哈希被针对了 被卡得飞起 自然溢出随便过 这个世界还能不能好了，我们单哈希要怎么活着你们才满意，眼泪不争气的流了下来，这个世界到处充斥着对单哈希的压迫，单哈希何时才能真正的站起来 最后写了双哈希 堂堂正正过题好吧 7.14早上博客崩了我裂开了 整了半天没弄好 不想搞了 随缘吧饿死了 我以后一定吃早餐吃完饭去实验室补题 昨天的B又给我补裂开了同样是余弦定理为什么有高低贵贱之分啊补完B真的身心俱疲 开始摸鱼和学妹去外面吃饭吃完饭沿着弗雷德转了三四圈回来继续补题 补了J又不想补了但鱼也不想摸了补之前还没写完的题写写摸摸 普通的一天过去了 7.15今天好摸牛客写了一题区间dp 一题概率 开了个莫队发现暴力可以过 然后不想写了 去补题了硬着头皮补E 感觉大家都会就我不会好丢人啊……就嗯补 其实fwt也不是很理解 板子也不一定会用 但这题算是过了 啊这样好敷衍啊然后摸了好久 眼睛贼痛 我再也不没事化妆了又开始写G G好补一点吧但还是好难顶day2的已经补了8题了 补不动了真的……回宿舍电脑都没带 7.16我～太～难～了～妹有早上下午在牛客随便写题其实本来想ACAM写写2A 但是看了好久不会 就算了写了三题三星累了 换二星的就是这个二星题 13253 气死了二星题嘛 一看 暴力求串然后kmp写了几发wa才发现题目看错了就这还能50%？？过了后看别人代码 发现有好短的Java 略微研究 妙啊！就自己写一发 调快读快出调了1e5年 气死了调完发现没快多少 更气了晚上想看看模块 翻知乎收藏看了会数学就困了 对不起看到ACAM 深受触动 我不能放弃练习的机会！我不能一直逃避！对不起！然后开始看小燕2A的ACAM看了半天写 然后样例没过……对不起 7.17依然妹有早上想了好久要穿什么 因为要开会 不好意思大裤衩今天没穿拖鞋 感天动地刚上楼外卖就到了 气死了吃饭后开会前把昨天在看的ACAM写了自己想了半天没明白为什么数组得开1.1e6 问小燕的 小燕永远滴神回来开始看博客 乱七八蕉地看开了平衡树 本来想整个手写板子 但是大家都是pbds我也懒得手写了（然后就学pbds 写了几题摸了会 淘宝看看假发（？回过头看看2K 感觉有点理解了 但不太敢写 怕一晚上调不完明天比赛一直想=。= 扔了个骰子是不写 之后再补吧！晚上老刘来实验室了 希望没来的人没事 7.18今天比赛日 果然 比赛日早醒 训练日晚起九点真不知道吃啥 吃太多午餐吃不下 不吃太饿了 当午餐吃太早了 再睡吧也睡不着了最后买了袋小饼干来实验室 第二个到的诶嘿嘿比赛比得我裂开了 dreamoon克我读题读得头疼开局队友说L签到 我就没看我看B 老往平衡树想 对不起卡思路卡了一年才走出来然后和学妹调A 我提出一个问题 然后过了一会又想 诶第一发没错啊？然后我发现第一发一个错误 交了一次 wa 对不起送了我交完学妹把第二版改了过了A过开C C先想了很复杂的思路 叫学妹给我写特判 写着写着发现不用特判（……）然后我样例没过 开始想怎么写 想着想着学妹过样例了 交了wa 我看了看代码说可能是eps的问题 求稳还是测组数据看看 妹错 我说那改eps！1e-2！改完就过了 学妹气死了C完看E 不想写 学妹们留E了 我看F贼好读就跑F了 于是开始自闭F贼好想 写写写 就开始wa写了个对拍看有没有处理了还是小于0的数据 跑着跑着死机了 我妹想到的 裂开开备用机登上牛客的时候前后两个队伍都过F了 我直接心态大崩凭什么啊！气死我了！自闭调试调了一年 一边调一边碎碎念：气死我了气死我了气死我了最后12min过了但电脑还是打不开 我裂开了 7.19其实摸了一天百度之星都写不来cf又是毒瘤场（还好没打）晚上看zfj写3F 他说没预处理可以过我说那我赛时凭啥t了算算人复杂度 感觉铁t 但才400-ms 飞快气抖冷重交一遍赛时代码过了更气抖冷了评 测 机 波 动花钱在牛客找气受 卡了我两个多小时的罚时和两天的心态 7.20今天又是早上被热醒的比赛日开局扫一眼标题 我果断gcd去了看了一下 就这？这也太简单了啪啦啪啦写 wa啊这 然后仔细看一下 1的时候没特判啪啦啪啦加 wa我找小庄帮我看看代码 读了一遍感觉完船没问题这时候小潘看了看 说这不应该是balabala吗我就发现我题意读错了 对不起 老瞎子了重写还想岔 卡到40分过B的时候学妹们也过F了继续gcd 开H题意继续读错 读复杂了 以为要i&lt;=gcd(a[i],b[i])想得天花乱坠 小庄想到带花树 过了不久听到两个队也在：“带花树……”和小潘交流后发现题意又读假了 对不起调了一会就过了老演员了之后的题完船写不动 C没啥想法（假串手）D感觉很好玩但不会写 E感觉很好玩很cf但不会写因为G实在太巨了 小潘闲着也是闲着 就认真读完了题读完说 其实思路还挺清晰的我说确实 大模拟前众生平等小转讲道理：其实大模拟是一个很好的机会 现在强的队伍不会考虑G 弱的队伍不敢开G小庄也一起看G 提出了matlab写的想法小转：写啊 这要是过了 甚至不能叫血赚 这是名垂青史啊 即使没过 也能在写的过程中学到新的知识 同样开启matlab写acm的先河最后还是没写我随缘写了一点D（指写了特判）听到对面讲I wcy说这题在出啥啊为啥不能全是0啊！越想越有道理 wcy说得对啊！但他们wa了但确实有道理嗷 7.21今天是杭电多校第一场 还是朝鲜场 双倍自闭开局看了几题都是令人恐惧的数据范围 无从下手1004一开始没读懂多读了一会 正好就是个签到讨论后知道思路 我脑子没动过来少说了个特判 wa加上又wa我问pls：你昨天拜佛那个是哪个网站？学妹扒了文曲星的图片到便签里 打字：求你了求你了求你了求你了我们看了一会 突然学妹说 是不是要换行啊我说 要啊……陷入沉默之后看1005过的挺多人的 就是开始被数据范围劝退的题 小转沉默学妹去整了 一个推公式一个想矩快（我真感觉是矩快 对不起我真学不来 我去串题了看了看过1011的人的时空 感觉不像SA/SAM等做法 像是乱搞 开始考虑乱搞一乱搞就搞了1e5年 没有啥方法能过我想的样例的wcy这时候也在疯狂卡1011 写SAM的时候 小燕大声说：这要是能t把我头拧下来！过一会：tle！顿时掌声雷动 可谓普天同庆（此时一个刚走进门的zls：？？？小潘把1005写了 算了算好正确的一个复杂度 t了我知道过1005的很多1500ms+的 知道是卡常题 我说我帮忙抠抠抠完还是t 因为我那时候没对着公式不知道能不能降log我问小潘log能不能降 小潘也不知道 那我也不知道然后发现我抠完的样例过不去 想不到的 我都不知道我改啥了 裂开五个小时飞快地过了 又爆零了呢看小燕调了一会最小表示法+kmp 施老师一直喊饿就先出去吃烤肉了回来看1011有没有乱搞过的 看到两个疑似乱搞的 喊小燕来一起看看我们两个 面面相觑 互相质问 这啥啊 写的锤子啊 看不懂啊施老师来看了一眼 震惊道 这就五行？那你（wcy）调了一下午？小燕嘤嘤嘤 7.22今天和字符串对线凌晨在研究1011的五行乱搞 处于悟和不悟中间的薛定谔状态最后终于搞明白了！痛苦万分地写题解也写上了！结果小燕中午起来就和我说 我觉得你这个乱搞就是Lyndon！我：我不听我不听 我不管我不管 我就是乱搞过的！！！下午学Lyndon 痛苦万分地发现真的挺像的呜呜呜呜呜呜呜 我不管 我就是乱搞的整完不想补杭电了 去牛客补4C研究科大队伍的神仙乱搞（知道可以SAM就是不看 老叛逆了）大概懂了思路 还是不明白为什么可以这样还有别的队伍的神仙哈希呜呜呜 写串题总喜欢看一些奇奇怪怪的做法 7.23今天又爆零了诶～一开始06卡思路 想到可以取模但不敢莽 我在干嘛啊01也想不出来 乱写了一发没过就算了 呜呜呜12也 知道是个不是很串的dp 但优先级没其他题那么高 就放着10就 干啥啥不会 想假算法第一名有rand然后0ms过的 太玄学了今天体验极差 呜呜呜 老废物了眉头跳了一天了 希望人没事呜呜呜让我明天被闹钟吵醒吧 我不想再被热醒了呜呜呜 7.24今天写了两道签到 老废物了一边看直播一边写题 没想到吧！把桌面换成了小马敬礼 小马老可爱鬼了 7.25比赛日 牛客5 就那样吧前一个小时一度前50 可以的小转I是嗯猜的 4发F妹看呢E是高精 刚想开idea的时候发现比赛机没有 裂开写完一发就过啦 虽然快读又调了一会赛后把取模删了直接76ms Java最快嘿嘿！D一开始以为是区间dp 后来以为是模拟 后来dp求LISpls后半小时没调过D 绝望地问我是不是区间dp我说有区间也有dp 那就是区间dp吧这场感觉补不太动啊 老废物了呜呜 7.26今天把队伍文档美化了老摸鱼了兄弟可能是最近太忙了 比赛也上限了 其他事情也上限了 心态又在崩溃边缘不过至少把牛客5C想懂了 写了一个应该比较清楚的题解 呜呜呜 7.27比赛日 醒来发现没水直接裂开啦今天对面好好笑啊（不是）数组开小三次今天嘴三个题猜一个题 有个特判愣是没看出来 代码五分钟 特判一小时好累啊好累啊 可能已经比赛上限了 明天又有比赛 难顶为什么这么废物啊 是本身就这么废物吧 和那三个月又有什么关系呢 7.28比赛日就是每次惊醒都要摸手机看时间怕自己睡过了今日演员生活从1001的第一发wa开始读完01觉得 啊这 不是比个长度？？？直接交了 勇于尝试嘛！wa 嘿嘿 6s的题比个长度 想啥呢wcy/zjq/lmj读了也都觉得 这不就比个长度？大家都一样w开始演04 04小潘wa了一发 我去看 想了想提了一个二分想法写着写着 不对啊我前缀和取模了二分个棒槌然后又想了个假的 勇敢提交 wa随手写了个数据把自己hack了这时候才想出正解心态小崩 歇了一会才敲之后小潘小庄搞09 我就去搞05纸上理了一页的思路 各种分情况讨论 各种递推 人裂开她们过09后小庄来一起看05 和小庄讲完题意忽有所悟原本思路是每次减去和自己同一个组的人数 就是记录和自己不同组的人数 突然感觉反过来记和自己同组的人数简单多了搞一发就过了过完05就丧失了所有的写题欲望 后一个半小时0贡献呜呜呜呜呜呜呜呜呜 7.29今天领导要来所以要早起副队长老撑场面了兄弟们写了两道数位dp可能是因为看了题解8 感觉杭电3的数位dp比牛客6的好写啊 呜呜呜牛客6H场上前期100%过率就很离谱 呜呜呜还是太菜了呗 7.30比赛日真的打不来杭电呗 又爆零了 心态还崩了 呜呜呜05没清空wa了一次 对不起 这就改叫清空打转转02三个人轮流wa 题意全没读对 三个瞎子11一直往复杂的想 对不起 最后小潘还给推出来了 太牛了04一看 先提了一个简单的状态继承dij wa了几发我提出可以拆点 难得搞图论真的感觉拆得其对无比 然后t 气抖冷我和小庄就 无法接受！无奈卡常t了一年 直接数组开大10倍 wa了？？？？？？这时候只剩15min了 回天无力赛后查出来是两条边建反了呜呜呜不t的话还是有可能查出来的 可惜小庄晚上还写了拆点后加单向边的写法 还研究出了我们第一版的wa法哈 哈 ACM 真 好 玩 啊 7.31明天就要计分了下午出去兜了最 后 的 放 纵晚上看了牛客3D 哇 心态崩了赛时没开是真的亏 裂开赛时在和F对线真的痛定思痛 想了想未来队伍发展算了算 确实就是 最好预期就是能有女生赛打 拿个金 或者老刘名额讨到足够多（虽然看老刘的意思不太可能）（补：如果一个队拉满有两次ccpc 那更没可能了 至少有六七队要拉满吧）这样子还能有一场ccpc真的能拿金吗 好迷茫啊小转还啥都不会呢 说是串手和数学选手 串只会写无脑题 数学只会写简单题 演啊卷啊筛啊还是不会 图论和数据结构又弱 思维题也不一定转得过来 这不就是啥都不会吗5555八月的小转 争点气吧 8.01早上热醒 头痛得要死又睡不着中午喝了杯一点点续命事实证明没啥用 演死了今天 北影欠我一封录取通知书好吧开D 题意太清晰了！然后想法就假了最后靠小庄的打表 55小转笨笨开H 题意太清晰了！思路太清晰了！这不就是数论分块随便写写！然后就想歪了 以为只能累加和累乘 wa了1e5年绝望地让小潘写了暴力对拍才发现哈哈！真是太厉害了呢！开J 模拟 可以搞！题意太不清晰了！开始读题……理完思路且脑过样例 一天的黑暗时刻就到达了wa到最后都没过赛后越写越委屈写哭了呜呜呜我又写题写哭了今日反思：最后一小时选择分别开题是对的 虽然今天结果不好但是还是对的写数学一点的题需要思路清晰 最好抓队友转一下题意和思路 8.02状态又差 在宿舍待到三点才来实验室把牛客3D写了 是真的好写 要是赛时for里没long long可能就能再出一题了qwq至少在实验室能笑得挺开心的 8.03自闭×2 最自闭的一场了bin巨：很多签到题 很友好bin巨的嘴 骗人的鬼最开始想C了 想了好久小庄一直卡I 二分图t到最后K小潘写完说wa了 我问小潘你确定没啥问题吧 小潘说没有 我说那就全改__int128发现我读入的板子还假了 想不到的 让小潘直接去扒小庄的开G 老笨蛋了想得好复杂总结就是：小转又写模拟写哭了今天是真的眼泪打转转 8.04自闭×3 想不到的 果然一记成绩就开始了吗A跪在不会算期望 而且板子看不来带分数的形式 推完式子还没看数据范围直接写了一发 老演员了小潘小庄折纸推式子小转也折纸 想不到的想了想感觉就是个模拟 然后又写自闭了 嘿嘿小转和模拟不共戴天好吧 下次赛时绝对不开模拟了剩一点点时间的时候感觉其实应该我和小潘小庄换题 害 8.05今天把两个欠着的模拟写了 之后就不碰模拟了 笨转今天实验室人好少哦 大家都在干嘛鸭 8.06今天还行吧其实前期签到顺利 09 01 虽然各一发罚时帮小潘调完02 5发 果然小转连调模拟都不会06卡到最后都没出来 呜呜呜10改了小庄的矩阵树 一交居然过了 牛的wcy：为啥这个队会矩阵树不会签到啊wcy：哦转爷那队啊我&amp;小庄：你再骂 8.07模拟 一生之敌补完4C就顺便补4D 顾老师的写法是真的牛 好短rls和我一起调 想了无数样例 50%调到75% 剩下25%死活找不出来无奈之下rls和我说 二分找bug吧 一段一段替换rls感觉我slove假了 换了还是75%我把qwq换了 rls说不可能这个错吧这个怎么错啊弹窗：你已通过此题！我：……rls：……啊这 8.08没想到的 居然还有场可以比kuangbin场还自闭 dreamoon场还气人A一看题面是模拟+高精 那就是我的题了后面的队9min就过了 呜呜呜Java嗯写 Java的左移里面参数还只能是int 这写个锤子啊（当时忘了BigInteger还有pow）看了一下发现全是python过的 Java提交就只有一个 先跑了卡语言是真的恶心 心态就开始崩了小庄就去看看python 我和小潘看I思路就贪一下就好了 看了一下python和Java全是tle的 那就c++写 得扒个大数板子感觉小潘写得有点乱 我就顺手写了过了I回头看A 一边写一边骂感觉模拟方法是对的 就让小庄别看python了 一队人不能全死在同一题调了一年 吐了 注释掉的代码比没注释的还多过A后开E 定睛一看gcd 好 我的题随便想想就知道咋写了 开始写咔咔写 wa找了1e5年bug 最后说 干脆把这个cnt开成__int128吧 过了时光倒流到半小时前 我和小潘说：这个绝对不会炸 long long够的哈 哈 哈 为什么算错了呢 因为少算了一个循环的3e6老演员了打完比赛就回去了 体验太差了 8.09六点多醒想不到的床上躺两小时越躺越精神 算了九点多第一个到实验室 坐了没一小时就困了好牛啊 实验室昨天的E幂次是可以取模的 就全改成int交了一次发现取模还没直接开__int128快 就这？晚上百度之星还是老废物了 小转怎么配呢 8.10今天个人状态不行 反思全程单刷一样 而且想的还是假的不该死磕不属于自己难度的题小潘赛后1A 我最后半小时不应该卡题应该帮忙查的确实确实确实 我直接看代码能看出来的可惜可惜可惜别卡题别卡题别卡题 8.11小转弱智场签到签了四个小时 想不到的没乘1ll卡了一小时J的连通块不会很大一下就想到了 规律没灵感又爆零又垫底了 呜呜呜 8.12我配写10G！我配写10G！我配写10G！我配写10G！我配写10G！我配写10G！不愧是赛场卡了5h的题 终于过了虽然参考了别的队的代码和数竞巨佬的crt讲解过了过了过了过了过了过了过了过了过了牛的牛的牛的牛的牛的牛的牛的牛的牛的 8.13今天排名新高了 虽然校内还是倒二 为什么都学得这么来啊06乍一看感觉是个dp 但我不会dp我就说我贪贪看贪wa了一次 自闭写了一会过了08早早就和小潘说很适合她写 我过了06也来一起推08根据小潘画的半径3的花花图扩展PS启动！老美工了规律找到了就扔给小庄小潘跑路了小庄：我们队名有转我们肯定转得来！小转：你们队里有我你们肯定转得来！09随便算了算感觉随便过（赛后发现我算了个寂寞）没取模wa了一次 想不到的wa的时候看了一眼500+ms 稳 以致我一直以为这题时限1s呢取模后就过了 这时候wcy还没过 可把我牛逼坏了一分钟后小潘1A了 队伍高光时刻之后两个多小时就没干啥了 三线卡题 老后劲不足了赛后被告知09假的复杂度 一算哦对哦 那我咋过那么快啊我对wcy：卡我卡我卡我卡我卡我wcy说了个数据 我以为稳卡没 结果贼快 自己也想不到的wcy不服 来看我代码 愤怒地说我把那种情况全continue了所以贼快诶～卡不掉我卡不掉我卡不掉我不过大家都是O(能过) 就是我尤其的快 自然溢出赛后499ms 双哈赛中718ms说实话 写代码的时候不感觉我有剪枝 赛后才发现是大力剪枝 8.14因为自动审批恢复了 群里说了一句不训练了！结果真的一天没训练 想不到的睡了一下午 到实验室后wcy给我推了一个知乎问题 答了就差不多该吃饭了！出门走两个小时 回实验室打开知乎发现首页一个问题格外眼熟？吃瓜吃着吃着自家房子塌了然后连了一晚上麦233 8.15自闭鸭dp又d不出来 namomo也打不好 还好是小号嘎不知道为什么下标从1开始读 然后卡了一年下午写了份兔设文案 晚上又被迫害一份namomo宣传离谱 小转老工具人了 两家工具文案手 8.16写了道cf 再也看不下去了 我现在这个鬼状态打cf必炸（或者等小马直播吧233）继续dp 我咋配dp啊那个写法是真的漂亮 但是真的看不懂实在不行就换写法吧 题解写法还是比较好懂的qwq 8.17毕竟是8.17 写道哈希？老废物写了一天cf1800- 呜呜呜这手速可以退役了 8.18神奇的比赛经历增加了杜杜大毒瘤 呜呜呜A最开始想了个结论（一定在最长链）成功卡思路卡了2h最后又dfs一遍回去过的赛后别人来看 这就是dp啊？我：？？？？这也配？这不是暴力？？？C小潘图画出来了 怎么出数据也知道 但是嗯写会mle我打了表出来看规律啥都看不出来翻板子看自己存的模型 诶 这不就 和威佐夫博弈有点像？去搜带式子的威佐夫证明和扩展威佐夫博弈都搜不到东西赛后发现别人怎么都搜到了啊 呜呜呜 我再也不用百度了.jpg赛中就没办法 对着式子嗯猜猜着猜着样例过了 这你不冲？wa了后对着小潘造了一页纸的数据拍 拍了三个问题出来后就直接交 过了 ohhhhh最后是+10 +7 就这还能rk200+？谢谢杜哥谢谢杜哥 8.19下午在实验室水群水到飞起想补题了 打开杭电8K 咔咔地把读入写了 然后倒头就睡醒来真的心情复杂 不会吧不会吧不会真有人读入写完就睡着了吧 8.20老废物最后一场是想尽力打好的啊 但还是炸了04从头卡到尾11可惜没早开03小潘写了全程 还好最好出来了10我和小庄各想通了一部分 感觉合起来这题就过了啊 所以当时为什么不交流呢07感觉其实可以写啊不过没有时间呜呜呜 20场多校就这么落幕了 假期要开始了给自己定个目标：假期两天一场教育场（没比赛的时候） 8.21以为放假的我会学习真是太天真了呢谁都想不到我现在在桌游馆敲这些话 笑死 8.22回家咯想在动车上写题的我又写完读入就睡着了 8.23继续补dp 我明明不是dp手为啥总在写dp下午fzu的比赛 fzu的oj就很裂开 老刘发在大群的又不好意思不打测一年后一个ce 就很离谱想hdu 呜呜签签完就挂机了 后半小时开博弈 感觉也写 然后就 wa到结束应该就是一句yes和no写反了 呜呜 8.24在家是真的摸啊非常碎片地写题 大部分时间都在摸晚上抽了一小时写cf 不是只想写签到是我配写个锤子的cf 那种1w+人过得题都写不来 弱智一样的 8.25重拾排版工作 初试公号运营招新是真的累啊兄弟晚上上车一场牛客七夕 但其实就签了个到 害然后打edu 果然 我配写个锤子cfA漏了一个+1 找了一年 因为我第一个值直接赋了没算lenB卡了 到C过才写 少了三个min wa2两发C多傻一题啊 死于特殊情况直接return导致没有清空 清空打转转D一看原题 拿以前代码改一下一交t6 定睛一看我以前是n3的 那没事了E说也是原题 但是是真不想写了害","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"}]},{"title":"抑郁小记","slug":"抑郁小记","date":"2020-06-28T07:08:01.000Z","updated":"2021-01-26T16:43:57.879Z","comments":true,"path":"2020/06/28/抑郁小记/","link":"","permalink":"http://wzgshyvin.github.io/2020/06/28/%E6%8A%91%E9%83%81%E5%B0%8F%E8%AE%B0/","excerpt":"都会好起来的","text":"都会好起来的 为什么突然就抑郁了？硬要解释的话，去年十月就有点苗头了，疫情期间长期在家过于压抑，集训队和课业的压力也很大，还有一些我不想多提的事，种种事情堆积在一起从而造成的这种结果吧。我也不想嘛。可以算是突发，有一天早上睁眼突然丧失了对各种美好追求的兴趣，而前一天我还状态很好地在训练。抑郁时候我都干了什么？除了消磨时间的不务正业，还有身体本能的训练。3.10我在cf的题数刚好达到300，现在快到500，中间有三次紫的机会，一次开小号翻车了（对不起对不起对不起）但其实也全是1A，一次和晚课冲突小号打了四题，一次就普普通通地紫了。虽然我怯弱、畏缩、心思不定，但我还是有可能性。期间喜欢上了小马，听着他的直播会很安心，反之如果有事听不了会很焦虑。平时听他的歌、听他听的歌、看他做的视频，现在电脑桌面和手机壁纸也全是他，老追星了233。可以懂这一种心理寄托吧，喜欢终归是很正面的情绪。和zxj又恢复了很好的关系，虽然本身就是很适合当朋友的人233。后期的调节和他们关系也很大。虽然都看不到。但还是。谢谢谢谢。分手是决定了很久的。给他两三次机会了吧，因为是一个很怕麻烦的人，也很心软的人。最后深夜理抑郁时间线的时候还是绷不住，我觉得我该对我自己好一点，就提了分手。同理在一起也是决定了很久的，没有随随便便，曾经也给了我很多正面影响。谁没有真情实感过呢，恋爱就这。感谢小任同学给我的药和给我的鼓励。感谢情感问题调节大师盛宝。还有请我吃仟诚和鲜芋仙的xy。还有总是劝我去看病但是总气我的歪宝和可可爱爱妹有脑袋的燕宝。还有列表各个朋友给我发的话和小作文。社交达到这个程度很开心了233。还在家的时候感觉太闷了就会出去玩，老调节情绪了。和媳妇儿去逛街，去吃吃喝喝，去江边吹泡泡，拍照发空间。真的在努力康复啊。之前在实验室呆着的时候有非常严重的焦虑，借机把队服画了。说实话，在工设还是压力很大且毫无解决办法，希望小转没事。下学期想和老师谈判一波，希望小转没事。要是挂了我大四还得修，再修再挂也没啥意思吧，那还是一样的水，干嘛不一次给我过了是吧，希望小转没事。“我只是想追求我的前途。我的前途不在工业设计。”逼逼赖赖到不知道说啥了。小转很棒小转该有光明的前途的。小转还没好全小转也不知道能不能好。千言万语汇成一句话：希望小转没事🙏。","categories":[{"name":"w&y","slug":"w-y","permalink":"http://wzgshyvin.github.io/categories/w-y/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://wzgshyvin.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"心心奇怪素材网站收集","slug":"心宝网站素材","date":"2020-06-27T15:08:01.000Z","updated":"2021-01-26T16:43:45.583Z","comments":true,"path":"2020/06/27/心宝网站素材/","link":"","permalink":"http://wzgshyvin.github.io/2020/06/27/%E5%BF%83%E5%AE%9D%E7%BD%91%E7%AB%99%E7%B4%A0%E6%9D%90/","excerpt":"努力当一个好美工？","text":"努力当一个好美工？ 文章头图来源 背景素材光球线条炫光渐变层液态流体背景生成发散光线花里胡哨举牌小人老黑客了生成代码图片 PNG 素材配色参考配色配色配色自由选色渐变配色板块配色日本传统色 图片处理双色图片故障艺术","categories":[{"name":"y","slug":"y","permalink":"http://wzgshyvin.github.io/categories/y/"}],"tags":[{"name":"素材","slug":"素材","permalink":"http://wzgshyvin.github.io/tags/%E7%B4%A0%E6%9D%90/"}]},{"title":"wz刷题汇总","slug":"wz刷题汇总","date":"2020-03-25T05:28:38.000Z","updated":"2021-02-22T14:03:32.096Z","comments":true,"path":"2020/03/25/wz刷题汇总/","link":"","permalink":"http://wzgshyvin.github.io/2020/03/25/wz%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"个人刷题记录（不完全）","text":"个人刷题记录（不完全） cf-contests存一些让我再写不一定写得来的或者我可能去扒原题的?1202D d3线下想的数学题1214D dfs可以搞 两次dfs 第一次把走过的路堵上(“D不是dinic板子题?”)1217B 是我最讨厌的打怪兽 但是做太多这种了… 要特判一次打死(wcy赛时四题睡前三题醒来两题那场)1209D 奇怪的并查集1220B 每个ans[i]为sqrt(a[i][j]*a[i][k]/a[j][k])1221D dp 增高栏杆使没有相同高度 只可能增0121251C a[i]和a[j]奇偶性不同可以交换 问字典序最小 奇偶分别存一个数组里 sort 然后贪心输出1252H 这b卡double精度1256A-F 自己博客1257D 贪心打怪兽1253D dfs求每个点能到mn和mx 再for一遍补1265A-E 自己博客…1295C 我最怕的二分题 多次选s的子序列加起来使最后结果等于t 问最少几次 开个cnt[26][maxn]去二分1295D 问有多少0&lt;=x&lt;=m-1%%gcd(a,m)==gcd(a+x,m) 结论题 求gcd(a,m)的phi1300E 任意选区间使区间中所有数变成区间平均数 问字典序最小什么样 贪心+算不算单调栈? for一下遇到小的就去和前面的平均1301D 自己博客1303C dfs 给你s问有没有合适的单行键盘序列使每次按都只用移一格1303D 袋子容量n 给你m个2^ki的物体 问最少拆几次能填满1304D 构造 给你&lt;和&gt;代表数组递增或者递减 求LIS的最小/最大情况 最小情况就增得少减得多 最大反过来 离散化后就是答案1305E 构造 递增数列且刚好k个三元组(i,j,k)满足ai+aj=ak1307D 加一条边使加后的1到n最短路最长 跑一遍所有点到1/n的最短路 根据差值排序 然后for1311D 暴力枚举 范围是坑 给abc问最少加减一次使b%a==0&amp;&amp;c%b==01312E 区间dp 两项相邻的相同可以合并成一项比原来大1的值 问最少剩下1315D 奇怪的并查集 根据时间大到小sort 并查集判点是否出现过1316D 带模拟1316E 状压dp 每个人可以选两种身份 贡献是a和b 选p个1身份和k个2身份的人使总贡献最大1321A-D 自己博客1326D2 自己博客1327D 置换群 给p找最小k使p^k存在颜色相同的环 找环后枚举因数再枚举所在环是不是颜色相同 cf-strings/hashing5C 常见括号匹配 单调栈板子题7D 自己博客8A implementation 题意有点难懂 正着find倒着find就完了25E kmp/hash板子题 多个串省略重复地相连31B implementation+greedy?合法只要是两个@相差2 注意首尾34C 断句题 断完了就implementation39J 给定串s和t 问s能不能删一个字符得到t hash完了for一下58D sort题 sort完暴力找匹配70B 恶心人的题 带模拟75B 断句+sort 模拟就完了432D kmp预处理后o1查某个前缀出现几次471D 差分后kmp一遍526D kmp 很考对nex的理解?985F 给出串s 每次询问以x和y为起点长度len的s子串字符能否形成一一映射 hash[maxn][26]记录 每次求出两个段每个字符的hash值 sort完一一比较1200E 字符串合并 hash/kmp板子1204D2 比较精妙的构造? cf-string suffix structures19C 自己博客123D 求所有子串出现次数和 sam板子128B 求第k小字典序子串的sa/sam板子 cf-geometry1C 海伦公式+正弦定理+余弦定理+double求gcd14C 给四个线段问能不能组成矩形 记个数18A 给三个点问能不能组成或者移一个点组成直角三角形 forforfor183B 这才1700?虽然是n3暴力190B 求和两个圆相切的圆的半径 cf-number theory7C exgcd10C 求出每位数有几个 然后加上所有组合 再扣掉合法组合16C 就这?没有binary search 所谓number theory只是gcd罢了17A 问2-n有几个符合题意的数 筛出素数然后暴力17D 十进制ksm板子题26A 就这2400?暴力完事27E 反素数板子题45G 哥德巴赫猜想(一个偶数为两个质数相加)?先判单色 枚举质数看能不能双色 不能的话肯定是奇数 -3 剩下的再枚举55D 数位dp+离散化 dp开[20][48][2520] 2520是1-9的lcm 有48个因数 对每个lcm离散化 搜到最后合法情况就是mod%lcm==066D 简单构造71C 枚举i到n/3(三角形) 每个n%i==0判合不合法73E 有1选1 没1选n内所有质数(不包含) 太大特判75C 求完gcd因数对于每个询问查找 暴力就行74C 很玄学反正求个gcd就没了78C 单根木头能分解并且木头总数是奇数 先手胜 pta-problemsetL1-064 自己博客 猛男带模拟 hdoj-problemset1439 置换群 找环记录环长 每次跳k余当前位所在环长次后的位置赋值si2838 树状数组 记录逆序对数和前缀和 每次存在逆序对的时候累加2486 k倍博弈板子1402 大数相乘 fft板子 Java快读板子2065 递推 推不出具体公式能找规律 循环节为204609 fft板子 通过fft算出所有两个数和的可能个数(?表述可能不是很清 想不起来可以看kuangbin博客) 减去选相同的 再总方案减可以构成三角形的1403 sa/sam板子 lcs","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://wzgshyvin.github.io/tags/Codeforces/"},{"name":"pintia","slug":"pintia","permalink":"http://wzgshyvin.github.io/tags/pintia/"},{"name":"hdoj","slug":"hdoj","permalink":"http://wzgshyvin.github.io/tags/hdoj/"}]},{"title":"Codeforces 1326D2. Prefix-Suffix Palindrome (Hard version)","slug":"Codeforces-1326D2","date":"2020-03-19T22:37:40.000Z","updated":"2021-01-26T16:40:49.713Z","comments":true,"path":"2020/03/20/Codeforces-1326D2/","link":"","permalink":"http://wzgshyvin.github.io/2020/03/20/Codeforces-1326D2/","excerpt":"比赛睡过去了=。=更一下D2的各种写法","text":"比赛睡过去了=。=更一下D2的各种写法 题目链接manacher hash pam都能搞upd:kmp也行思路还是比较清晰的先把原串分为三部分：前缀 后缀 中间比如acbba 分成a+cbb+a然后对中间这个部分找最长的以0开头或者以len-1结尾的回文串答案就是前缀+最长回文串+后缀 manacher1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;int che[2*maxn];string s,ma;void manacher(string s,int len0)&#123; ma=&quot;$#&quot;; rep(i,0,len0) ma+=s[i],ma+=&#x27;#&#x27;; // 别写成ma+=s[i]+&#x27;#&#x27;;了 换成&quot;#&quot;应该就行 呜呜呜血泪教训 int maxx=0,num=0,len=ma.size(); rep(i,0,len)&#123; che[i]=maxx&gt;i?min(che[2*num-i],maxx-i):1; while(ma[i+che[i]]==ma[i-che[i]]) che[i]++; if(i+che[i]&gt;maxx) maxx=i+che[i],num=i; &#125;&#125;void solve()&#123; cin&gt;&gt;s; int l=0,r=s.size()-1; while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); manacher(s,s.size()); int len=ma.size(),p(0),q(0),r1(0),r2(0); rep(i,0,len) if(p&lt;che[i]&amp;&amp;i-che[i]&lt;2) p=che[i],r1=i; dep(i,len-1,0) if(q&lt;che[i]&amp;&amp;i+che[i]==len) q=che[i],r2=i; // 这部分比较考对manacher数组的熟练?hhh自己手写一下应该就行 if(p&gt;=q) cout&lt;&lt;t1+s.substr(0,p-1)+t2&lt;&lt;&#x27;\\n&#x27;; else cout&lt;&lt;t1+s.substr(s.size()-q+1)+t2&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; hash还是seed和mod不公开 虽然我这次没有用常用的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;string s; int n;int seed,mod,hs1[maxn],hs2[maxn],bas[maxn]; // hs看情况开void init(int* hs)&#123; s=&#x27; &#x27;+s; bas[0]=1; rep(i,1,n+1)&#123; bas[i]=1ll*bas[i-1]*seed%mod; hs[i]=1ll*hs[i-1]*seed%mod+s[i]; if(hs[i]&gt;=mod) hs[i]-=mod; &#125; &#125;int getsum(int *h,int l,int r)&#123; int res=h[r]-1ll*h[l-1]*bas[r-l+1]%mod; if(res&lt;0) res+=mod; return res;&#125;void hash_init()&#123; seed=?,mod=?; init(hs1); reverse(s.begin(),s.end()); init(hs2);&#125;void solve()&#123; cin&gt;&gt;s; int l=0,r=s.size()-1,p(0),q(0); while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); n=s.size(); hash_init(); rep(i,1,n+1) if(getsum(hs1,1,i/2)==getsum(hs2,n-i+1,n-(i+1)/2)) p=i; rep(i,1,n+1) if(getsum(hs2,1,i/2)==getsum(hs1,n-i+1,n-(i+1)/2)) q=i; if(p&gt;q)&#123; reverse(s.begin(),s.end()); // 现在的s是&#x27; &#x27;+s+&#x27; &#x27; 所以要从1开始 cout&lt;&lt;t1+s.substr(1,p)+t2&lt;&lt;&#x27;\\n&#x27;; &#125; else cout&lt;&lt;t1+s.substr(1,q)+t2&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; pam呜呜呜好难啊pam好难 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;string s;struct PAM&#123; struct node&#123; int child[26],cnt,fail,num,len,pos; &#125;tt[maxn]; int last,n,tot; char s[maxn]; inline void clear()&#123; rep(i,0,tot+1)&#123; mst(tt[i].child,0); tt[i].cnt=tt[i].fail=tt[i].len=tt[i].num=tt[i].pos=0; &#125; last=n=0; tt[0].fail=tot=1; tt[1].len=-1; &#125; inline int getfail(int x)&#123; while(s[n-tt[x].len-1]!=s[n]) x=tt[x].fail; return x; &#125; inline void add(char ch)&#123; s[n]=ch; int cur=getfail(last); if(!tt[cur].child[ch-&#x27;a&#x27;])&#123; int now=++tot; tt[now].len=tt[cur].len+2; int p=getfail(tt[cur].fail); tt[now].fail=tt[p].child[ch-&#x27;a&#x27;]; tt[cur].child[ch-&#x27;a&#x27;]=now; tt[now].num=tt[tt[now].fail].num+1; &#125; last=tt[n].pos=tt[cur].child[ch-&#x27;a&#x27;]; ++tt[last].cnt; ++n; &#125; inline void count()&#123; dep(i,tot,0) tt[tt[i].fail].cnt+=tt[i].cnt; &#125;&#125;pam;int getpos(int n,int l,int r)&#123; int t=pam.tt[r].pos; while(l*2+pam.tt[t].len&gt;n) t=pam.tt[t].fail; return pam.tt[t].len;&#125;void solve()&#123; cin&gt;&gt;s; int l=0,r=s.size()-1,n=s.size(),p(0),q(0); while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; pam.clear(); dep(i,n-1,0) pam.add(s[i]); p=getpos(n,l,r); reverse(s.begin(),s.end()); pam.clear(); dep(i,n-1,0) pam.add(s[i]); q=getpos(n,l,r); reverse(s.begin(),s.end()); if(max(p,q)+2*l&gt;=n) cout&lt;&lt;s&lt;&lt;&#x27;\\n&#x27;; else if(p&gt;q) cout&lt;&lt;s.substr(0,p+l)+s.substr(r+1)&lt;&lt;&#x27;\\n&#x27;; else cout&lt;&lt;s.substr(0,l)+s.substr(r-q+1)&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; kmp12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e6 + 5;int nex[maxn];int getnext(string s)&#123; int i=0,j=-1,len=s.size(); nex[0]=-1; while(i&lt;len)&#123; if(j==-1||s[i]==s[j])&#123; i++; j++; nex[i]=j; &#125; else j=nex[j]; &#125; return nex[len];&#125;void solve()&#123; string s,t; cin&gt;&gt;s; int l=0,r=s.size()-1; while(s[l]==s[r]&amp;&amp;l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); t=s; reverse(t.begin(),t.end()); string a=s+&#x27;*&#x27;+t,b=t+&#x27;*&#x27;+s; string p=a.substr(0,getnext(a)); string q=b.substr(0,getnext(b)); cout&lt;&lt;t1&lt;&lt;(p.size()&gt;q.size()?p:q)&lt;&lt;t2&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://wzgshyvin.github.io/tags/Codeforces/"}]},{"title":"Codeforces 19C. Deletion of Repeats","slug":"Codeforces-19C","date":"2020-03-17T04:27:40.000Z","updated":"2021-01-26T16:39:14.996Z","comments":true,"path":"2020/03/17/Codeforces-19C/","link":"","permalink":"http://wzgshyvin.github.io/2020/03/17/Codeforces-19C/","excerpt":"事情为什么会发展成这样.jpg","text":"事情为什么会发展成这样.jpg 题目链接一开始感觉是求最短不包含重复段的后缀 卡了好久qwq 后来发现forfor就完事了本来想写sa hash 暴力三种写法的 结果写完暴力发现比sa还快 瞬间索然无味 我写sa干嘛呢离散化一下然后枚举就行 就当复习sa了555 后缀数组248 ms 25400 KB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int s[maxn];int sa[maxn],rk[maxn];int height[maxn];int t1[maxn],t2[maxn],c[maxn];int best[20][maxn];int a[maxn],b[maxn];vector&lt;int&gt;vv[maxn];void getsa(int *s,int n,int m)&#123; int *x=t1,*y=t2; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[i]=s[i]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[i]]]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p=0; rep(i,n-k,n) y[p++]=i; rep(i,0,n) if(sa[i]&gt;=k) y[p++]=sa[i]-k; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[y[i]]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[y[i]]]]=y[i]; swap(x,y); p=1; x[sa[0]]=0; rep(i,1,n) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++; if(p&gt;=n) break; m=p; &#125;&#125;void getheight(int n)&#123; int k=0; rep(i,1,n+1) rk[sa[i]]=i; rep(i,0,n)&#123; if(k) k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k]) k++; height[rk[i]]=k; &#125;&#125;void RMQ(int n)&#123; int lg=(int)(log(n*1.0)/log(2.0)); rep(i,1,n+1) best[0][i]=height[i]; rep(i,1,lg+1) for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++) best[i][j]=min(best[i-1][j],best[i-1][j+(1&lt;&lt;i&gt;&gt;1)]); &#125;int lcp(int x,int y)&#123; x=rk[x]; y=rk[y]; if(x&gt;y) swap(x,y); x++; int lg=(int)(log(1.0*(y-x+1))/log(2.0)); return min(best[lg][x],best[lg][y-(1&lt;&lt;lg)+1]);&#125; // 贴板子struct node&#123; int l,r,len; &#125;p[maxn*10]; // 十倍是因为题目的&quot;保证重复不过十次&quot;int cmp(node a,node b)&#123; return a.len&lt;b.len||a.len==b.len&amp;&amp;a.l&lt;b.l; &#125; // 按题意sortint solve()&#123; int n,cnt(0),ans(0); sc(n); rep(i,0,n) sc(a[i]),b[i]=a[i]; sort(b,b+n); int bn=unique(b,b+n)-b; rep(i,0,n)&#123; s[i]=lower_bound(b,b+bn,a[i])-b+1; vv[s[i]].push_back(i); &#125; getsa(s,n+1,maxn); getheight(n); RMQ(n); rep(i,0,maxn) rep(j,0,vv[i].size()) rep(k,j+1,vv[i].size())&#123; if(vv[i][k]-vv[i][j]&gt;n-vv[i][k]) continue; if(vv[i][k]-vv[i][j]&lt;=lcp(vv[i][j],vv[i][k])) p[cnt++]=&#123;vv[i][j],vv[i][k],vv[i][k]-vv[i][j]&#125;; // 只要算一下这一段是不是重复的就可以 改成hash也差不多 &#125; sort(p,p+cnt,cmp); rep(i,0,cnt) if(p[i].l&gt;=ans) ans=p[i].r; pf(&quot;%d\\n&quot;,n-ans); rep(i,ans,n) pf(&quot;%d &quot;,a[i]); return 0;&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; 暴力186 ms 5000 KB思路差不多的 不过算是优化了一下qwq 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;map&lt;int,int&gt;aaa;vector&lt;int&gt;vv[maxn];int a[maxn],q[maxn];int solve()&#123; int n,cnt(0),ans(0); sc(n); rep(i,0,n)&#123; sc(a[i]); if(!aaa.count(a[i])) aaa[a[i]]=++cnt; q[i]=aaa[a[i]]; vv[aaa[a[i]]].push_back(i); &#125; rep(i,0,n) for(auto x:vv[q[i]])&#123; if(x&gt;=i) break; if(i-x&gt;n-i||x&lt;ans) continue; int ff(0); rep(j,0,i-x) if(a[i+j]!=a[x+j])&#123; ff++; break; &#125; if(!ff)&#123; ans=i; break; &#125; &#125; pf(&quot;%d\\n&quot;,n-ans); rep(i,ans,n) pf(&quot;%d &quot;,a[i]);&#125;int main()&#123; /* int _; sc(_); while(_--) */ solve();&#125; upd:ylh把我暴力卡了 更没意思了数据: 1234567#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int main()&#123; cout&lt;&lt;100000&lt;&lt;&#x27;\\n&#x27;; rep(i,0,10) rep(j,0,10000) cout&lt;&lt;(j==9999?10001+i:j+1)&lt;&lt;&#x27;\\n&#x27;;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://wzgshyvin.github.io/tags/Codeforces/"}]},{"title":"Codeforces 7D. Palindrome Degree","slug":"Codeforces-7D","date":"2020-03-11T05:27:40.000Z","updated":"2021-01-26T16:39:08.071Z","comments":true,"path":"2020/03/11/Codeforces-7D/","link":"","permalink":"http://wzgshyvin.github.io/2020/03/11/Codeforces-7D/","excerpt":"最近在写string 这题manacher和hash各写了一遍","text":"最近在写string 这题manacher和hash各写了一遍 题目链接乍一看以为是pam 后来发现pam写不了233 不然要写三种的只要根据dp[i]=dp[i/2]+1;来推就行了 思路还是比较清晰的qwq manacher1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e6 + 5;char s[maxn],ma[2*maxn];int che[2*maxn],ww[2*maxn];void manacher(char* s,int len0)&#123; int len=0; ma[len++]=&#x27;$&#x27;; ma[len++]=&#x27;#&#x27;; rep(i,0,len0) ma[len++]=s[i],ma[len++]=&#x27;#&#x27;; ma[len]=0; int maxx=0,num=0; rep(i,0,len)&#123; che[i]=maxx&gt;i?min(che[2*num-i],maxx-i):1; while(ma[i+che[i]]==ma[i-che[i]]) che[i]++; if(i+che[i]&gt;maxx) maxx=i+che[i],num=i; &#125;&#125;void solve(int len)&#123; ll ans(0); rep(i,1,len+1)&#123; int l=2,r=2*i,m=l+r&gt;&gt;1; if(che[m]*2&gt;r-l+1) ww[r]=ww[m-1-(m-1)%2]+1; ans+=ww[r]; &#125; pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; scs(s); int len=strlen(s); manacher(s,len); solve(len);&#125; hash我的hash常数很大啊 抠抠才过还是seed和mod不公开了吧qwq 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e6 + 5;char s[maxn]; int n;struct haash&#123; int seed,mod,hs[maxn],bas[maxn]; // hs看情况开 void init()&#123; bas[0]=1; rep(i,1,n+1)&#123; bas[i]=1ll*bas[i-1]*seed%mod; hs[i]=1ll*hs[i-1]*seed%mod+s[i]; if(hs[i]&gt;=mod) hs[i]-=mod; &#125; &#125; int getsum(int *h,int l,int r)&#123; int res=h[r]-1ll*h[l-1]*bas[r-l+1]%mod; if(res&lt;0) res+=mod; return res; &#125;&#125;hh[2];void hash_init()&#123; hh[0].seed=?,hh[0].mod=?; hh[0].init(); reverse(s+1,s+n+1); hh[1].seed=?,hh[1].mod=?; hh[1].init();&#125;int ww[maxn];void solve()&#123; ll ans=1; ww[1]=1; rep(i,2,n+1)&#123; if(hh[0].getsum(hh[0].hs,1,i/2)==hh[1].getsum(hh[1].hs,n-i+1,n-(i+1)/2)) ww[i]=ww[i/2]+1; ans+=ww[i]; &#125; pf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; scs(s+1); n=strlen(s+1); hash_init(); solve();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://wzgshyvin.github.io/tags/Codeforces/"}]},{"title":"Codeforces Round #625解题报告","slug":"Codeforces-Round-625解题报告","date":"2020-03-02T01:42:16.000Z","updated":"2021-01-26T16:41:08.395Z","comments":true,"path":"2020/03/02/Codeforces-Round-625解题报告/","link":"","permalink":"http://wzgshyvin.github.io/2020/03/02/Codeforces-Round-625%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"记录丢人点滴","text":"记录丢人点滴 虽然真的很丢人 但是看了一下大家代码发现我至少代码还是短(? A: Contest for Robots题目链接题意：两种机器人对于n个问题有会和不会(1和0) 希望第一种的得分比第二种高 要如何安排问题分数分布 要求分数中最大的尽量小算一下第一种比第二种多的1和0 除一下可能会除零 要先判掉再除 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[105],b[105];int main()&#123; int n,c1(0),c2(0); sc(n); rep(i,0,n) sc(a[i]); rep(i,0,n)&#123; sc(b[i]); if(a[i]==b[i]) continue; else if(a[i]&gt;b[i]) c1++; else c2++; &#125; if(!c1) return pf(&quot;-1\\n&quot;),0; int ans=(c2+c1)/c1; pf(&quot;%d\\n&quot;,ans&gt;0?ans:0);&#125; B: Journey Planning题目链接题意：希望选择b的总和尽量大且满足选中的bi,bj有i-j==bi-bj每个b去减去i 找相同的数组存的话加上n也行 但是map就是香啊要ll 赛时比较草率qwq 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;#define int lltypedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[maxn];map&lt;int,int&gt;ans;signed main()&#123; int n,mx(0); sc(n); rep(i,1,n+1)&#123; sc(a[i]); int t=a[i]-i; ans[t]+=a[i]; &#125; for(auto&amp; x:ans) mx=max(mx,x.second); pf(&quot;%lld\\n&quot;,mx);&#125; C: Remove Adjacent题目链接题意：给一个字符串 对于每个字符 如果相邻字符有ascii码刚好比自己少1的 则可以删除 问最多能删多少个枚举z到a 每次for一遍删 O(26*n^3) 1234567891011#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;int main()&#123; ios::sync_with_stdio(0); int n,cnt(0); string s; cin&gt;&gt;n&gt;&gt;s; s+=&#x27; &#x27;; dep(k,25,1) rep(i,0,n) if(s[i]==k+&#x27;a&#x27;)&#123; if(s[i+1]==s[i]-1||(i&amp;&amp;s[i-1]==s[i]-1)) s.erase(i,1),n--,cnt++,i=i?i-2:-1; &#125; cout&lt;&lt;cnt;&#125; D: Navigation System题目链接题意：高德地图持续为您规划路线n个点m条边的有向无权图 给k个点是必须经过的 导航每次路线会选择最短路 如果不是最短路就rebuild重新找最短路 问rebuild的最少和最多次数无权图 bfs/dij/spfa啥的都行qwq判是不是最短路用dis就行mx和mn就差在有多条最短路的时候 这时候记一下就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;struct node&#123; int id,dt; bool operator &lt; (const node a) const&#123; return dt&gt;a.dt; &#125;&#125;;priority_queue&lt;node&gt;q;int n,m,k,s,t,tot;int dis[maxn],vis[maxn],head[maxn],cnt[maxn];int nex[maxn&lt;&lt;1],to[maxn&lt;&lt;1],val[maxn&lt;&lt;1];void addedge(int u,int v,int w)&#123; nex[++tot]=head[u]; head[u]=tot; to[tot]=v; val[tot]=w;&#125;void dij(int s)&#123; rep(i,1,n+1) dis[i]=1e9; dis[s]=0; q.push(&#123;s,0&#125;); while(!q.empty())&#123; int fr=q.top().id; q.pop(); if(vis[fr]) continue; vis[fr]++; for(int j=head[fr];j;j=nex[j]) if(dis[to[j]]&gt;val[j]+dis[fr]&amp;&amp;!vis[to[j]])&#123; dis[to[j]]=val[j]+dis[fr]; q.push(&#123;to[j],dis[to[j]]&#125;); &#125; else if(dis[to[j]]==val[j]+dis[fr]) cnt[to[j]]=1; &#125;&#125; // 板子闭着眼一套int p[maxn];int main()&#123; int mn(0),mx(0); sc(n); sc(m); while(m--)&#123; int u,v; sc(u); sc(v); addedge(v,u,1); &#125; sc(k); rep(i,1,k+1) sc(p[i]); dij(p[k]); rep(i,1,k+1)&#123; if(i!=k&amp;&amp;dis[p[i]]!=dis[p[i+1]]+1) mn++; else mx+=cnt[p[i]]; &#125; pf(&quot;%d %d\\n&quot;,mn,mn+mx);&#125; E: World of Darkraft: Battle for Azathoth题目链接补了加qwq","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://wzgshyvin.github.io/tags/Codeforces/"}]},{"title":"稳赚迷惑代码集","slug":"稳赚迷惑代码集","date":"2020-03-01T08:55:33.000Z","updated":"2021-01-26T16:43:38.925Z","comments":true,"path":"2020/03/01/稳赚迷惑代码集/","link":"","permalink":"http://wzgshyvin.github.io/2020/03/01/%E7%A8%B3%E8%B5%9A%E8%BF%B7%E6%83%91%E4%BB%A3%E7%A0%81%E9%9B%86/","excerpt":"自黑向 长期更新","text":"自黑向 长期更新 事情的起因是打了一场很丢人的周赛 赛后看自己代码说了一句 我赛时代码可以入选稳赚迷惑代码集了 好 说搞就搞从小到大好像为ACM哭得最多了 打个cf没打好觉得自己好笨 哭 暑假选拔以为自己没进 哭 发现被保送了 哭得更历害了… 知道自己这赛季没比赛时候忘了哭没哭了 反正过了很低谷的一段时间 还有一队ec亚军 我哭得好大声…稳赚笨笨的 学东西很慢 手速很慢 思路很容易被卡 一点点没发挥好就容易整场打崩 简直是队里蛀虫(确信 迷惑*1不知道在干嘛 多整了一个明明能用i判断的f 1rep(i,0,t) pf(&quot;%c&quot;,(f?&#x27;z&#x27;:&#x27;a&#x27;)),f^=1; 迷惑*21ans=ans*min(a[i],(n-i)%mod); 迷惑*31int n,l=0,r=n+1; sc(n); 迷惑*4CF1283C这也能过?.jpg假假地倒着for一遍这个是又菜又牛逼吧(?翻了一下大家的写的都挺长的(小声bb 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;const int maxn = 2e5 + 5;int a[maxn],b[maxn],v[maxn];int main()&#123; int n,t=-1,pos=1,tp=0,tp2=0; sc(n); rep(i,1,n+1) sc(a[i]),v[a[i]]++; dep(i,n,1) if(a[i]) b[i]=a[i]; else&#123; if(t!=-1)&#123; b[i]=t; t=-1; continue; &#125; rep(j,pos,n+1) if(!v[j]&amp;&amp;j==i) t=j,tp2=i; else if(!v[j]&amp;&amp;j!=i)&#123; b[i]=j; v[j]++; pos=j; tp=i; break; &#125; &#125; if(t!=-1) b[tp2]=b[tp],b[tp]=t; rep(i,1,n+1) pf(&quot;%d &quot;,b[i]);&#125; 迷惑*5噔 噔 咚你 在 干 什 么 123typedef long long ll;#define int ll#define %lld %d Can’t compile file:program.cpp:12:9: error: macro names must be identifiers#define %lld %d 123typedef long long ll;#define int ll#define lld d Test: #1, time: 2000 ms., memory: 180992 KB, exit code: -1, checker exit code: 0, verdict: TIME_LIMIT_EXCEEDED不愧是我 迷惑*6我:我压行了 我爽了队友:? 你 在 干 什 么 1pf(&quot;%lld\\n&quot;,dfs(m,1,0,0,0,p[i],sum[1]-a[i]*p[i],sum[0]-(1-a[i])*p[i],a[i]*2-1)); 打个正常版 12if(a[i]) pf(&quot;%lld\\n&quot;,dfs(m,1,0,0,0,p[i],sum[1]-p[i],sum[0],1));else pf(&quot;%lld\\n&quot;,dfs(m,1,0,0,0,p[i],sum[1],sum[0]-p[i],-1)); 迷惑*7有时候压了行也会哭着喊我再也不压了CF1312E","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"}]},{"title":"Codeforces 1301D. Time to Run","slug":"Codeforces-1301D","date":"2020-02-13T20:47:40.000Z","updated":"2021-01-26T16:39:21.704Z","comments":true,"path":"2020/02/14/Codeforces-1301D/","link":"","permalink":"http://wzgshyvin.github.io/2020/02/14/Codeforces-1301D/","excerpt":"压行带师船新大作","text":"压行带师船新大作 题目链接27行就问你牛不牛逼 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int qaq[5005]; string s=&quot;RDU&quot;,ans[5005];int main()&#123; int n,m,k,cnt(0); sc(n); sc(m); sc(k); int num=4*n*m-2*n-2*m; if(k&gt;num) return puts(&quot;NO&quot;),0; puts(&quot;YES&quot;); if(m==1)&#123; pf(&quot;%d\\n&quot;,k&gt;n-1?2:1); pf(&quot;%d %c\\n&quot;,min(k,n-1),&#x27;D&#x27;); k-=min(k,n-1); if(k) pf(&quot;%d %c\\n&quot;,k,&#x27;U&#x27;); return 0; &#125; rep(i,1,2*n+1)&#123; if(!k) break; if(i&amp;1)&#123; if(i==2*n-1) qaq[cnt]=min(k,m-1),ans[cnt++]=&quot;R&quot;,k-=min(k,m-1); else if(k/3&gt;=m-1) qaq[cnt]=m-1,ans[cnt++]=s,k-=3*m-3; else&#123; if(k/3) qaq[cnt]=k/3,ans[cnt++]=s; if(k%3)&#123; qaq[cnt]=1; rep(j,0,k%3) ans[cnt][j]=s[j]; cnt++; &#125; k=0; &#125; &#125; else&#123; int t=min(k,m-1); qaq[cnt]=t,ans[cnt++]=&quot;L&quot;,k-=t; if(t==m-1&amp;&amp;k&amp;&amp;i!=2*n) qaq[cnt]=1,ans[cnt++]=&quot;D&quot;,k--; &#125; &#125; if(k) qaq[cnt]=k,ans[cnt++]=&quot;U&quot;; pf(&quot;%d\\n&quot;,cnt); rep(i,0,cnt) pf(&quot;%d %s\\n&quot;,qaq[i],ans[i].c_str());&#125; 要讲清楚需要配图8 我懒 我就纪念一下我短的ep的代码就好了","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://wzgshyvin.github.io/tags/Codeforces/"}]},{"title":"PTA L1-064估值一亿的AI核心代码","slug":"PTA-L1-064估值一亿的AI核心代码","date":"2020-02-05T21:09:57.000Z","updated":"2021-01-26T16:41:29.786Z","comments":true,"path":"2020/02/06/PTA-L1-064估值一亿的AI核心代码/","link":"","permalink":"http://wzgshyvin.github.io/2020/02/06/PTA-L1-064%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/","excerpt":"猛男就该写猛题","text":"猛男就该写猛题 应该是过的代码中很短的一个了里面也有很多小心思 算是生涯中比较优秀的代码吧题目链接 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int main()&#123; int _; cin&gt;&gt;_; getchar(); while(_--)&#123; string s; getline(cin,s); cout&lt;&lt;s&lt;&lt;&quot;\\nAI:&quot;; while(s[0]==&#x27; &#x27;) s.erase(0,1); int len=s.length(); s=&#x27; &#x27;+s+&#x27; &#x27;; rep(i,1,len+1)&#123; if(s[i]!=&#x27;I&#x27;&amp;&amp;isupper(s[i])) s[i]=tolower(s[i]); else if(!isalnum(s[i])&amp;&amp;s[i]!=&#x27; &#x27;) s.insert(i,&quot; &quot;),s.insert(i+2,&quot;*&quot;),len+=2,i+=2; &#125; while(s.find(&quot;?&quot;)!=string::npos) s.replace(s.find(&quot;?&quot;),1,&quot;!&quot;); while(s.find(&quot; &quot;)!=string::npos) s.replace(s.find(&quot; &quot;),2,&quot; &quot;); while(s.find(&quot; I &quot;)!=string::npos) s.replace(s.find(&quot; I &quot;),3,&quot; You &quot;); while(s.find(&quot;*I &quot;)!=string::npos) s.replace(s.find(&quot;*I &quot;),3,&quot;*You &quot;); while(s.find(&quot; me &quot;)!=string::npos) s.replace(s.find(&quot; me &quot;),4,&quot; You &quot;); while(s.find(&quot;*me &quot;)!=string::npos) s.replace(s.find(&quot;*me &quot;),4,&quot;*You &quot;); while(s.find(&quot; can you &quot;)!=string::npos) s.replace(s.find(&quot; can you &quot;),9,&quot; I can* &quot;); while(s.find(&quot;*can you &quot;)!=string::npos) s.replace(s.find(&quot;*can you &quot;),9,&quot;*I can &quot;); while(s.find(&quot; could you &quot;)!=string::npos) s.replace(s.find(&quot; could you &quot;),11,&quot; I could &quot;); while(s.find(&quot;*could you &quot;)!=string::npos) s.replace(s.find(&quot;*could you &quot;),11,&quot;*I could &quot;); len=s.length(); rep(i,0,len) if(s[i]==&#x27;Y&#x27;) s[i]=&#x27;y&#x27;; else if(s[i]==&#x27;*&#x27;) s.erase(i,1),len--,i--; rep(i,2,len) if(!isalnum(s[i])&amp;&amp;s[i]!=&#x27; &#x27;&amp;&amp;s[i-1]==&#x27; &#x27;) s.erase(i-1,1),len--,i--; while(s[len-1]==&#x27; &#x27;) s.erase(len-1,1),len--; if(!len) cout&lt;&lt;&#x27; &#x27;; cout&lt;&lt;s&lt;&lt;&#x27;\\n&#x27;; &#125;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"pintia","slug":"pintia","permalink":"http://wzgshyvin.github.io/tags/pintia/"}]},{"title":"牛客小白月赛21解题报告","slug":"牛客小白月赛21解题报告","date":"2020-01-25T05:56:31.000Z","updated":"2021-01-26T16:43:18.842Z","comments":true,"path":"2020/01/25/牛客小白月赛21解题报告/","link":"","permalink":"http://wzgshyvin.github.io/2020/01/25/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B21%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"namo 怎么ak一场小白月赛这么难啊","text":"namo 怎么ak一场小白月赛这么难啊 比赛链接除了代码短度一无是处了 Audio找外心 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;double x1,y11,x2,y2,x3,y3,x,y;int main()&#123; cin&gt;&gt;x1&gt;&gt;y11&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3; double A1=2*(x2-x1),B1=2*(y2-y11),C1=x2*x2+y2*y2-x1*x1-y11*y11; double A2=2*(x3-x2),B2=2*(y3-y2),C2=x3*x3+y3*y3-x2*x2-y2*y2; x=((C1*B2)-(C2*B1))/((A1*B2)-(A2*B1)); y=((A1*C2)-(A2*C1))/((A1*B2)-(A2*B1)); printf(&quot;%.3lf %.3lf\\n&quot;,x,y);&#125; Bits12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;int n,t[5],s[15][5];void print()&#123; rep(i,1,3*(2*n+1)+5) putchar(&#x27;.&#x27;); putchar(&#x27;\\n&#x27;); dep(i,n+1,1)&#123; rep(j,1,4)&#123; rep(k,0,n-s[i][j]+1) putchar(&#x27;.&#x27;); rep(k,0,s[i][j]) putchar(&#x27;*&#x27;); putchar(s[i][j]?&#x27;*&#x27;:&#x27;|&#x27;); rep(k,0,s[i][j]) putchar(&#x27;*&#x27;); rep(k,0,n-s[i][j]) putchar(&#x27;.&#x27;); &#125; putchar(&#x27;.&#x27;); putchar(&#x27;\\n&#x27;); &#125;&#125;void move(int a,int b)&#123; s[++t[b]][b]=s[t[a]][a]; s[t[a]--][a]=0; rep(i,1,3*(2*n+1)+5) putchar(&#x27;-&#x27;); putchar(&#x27;\\n&#x27;); print();&#125;void solve(int n,int a,int b,int c)&#123; if(n==1) return move(a,c); solve(n-1,a,c,b); move(a,c); solve(n-1,b,a,c);&#125;int main()&#123; cin&gt;&gt;n; rep(i,1,n+1) s[++t[1]][1]=n-i+1; print(); solve(n,1,2+(n&amp;1),3-(n&amp;1));&#125; Channels123456#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll a,b; while(cin&gt;&gt;a&gt;&gt;b) cout&lt;&lt;b/60*50+min(50ll,b%60)-(a-1)/60*50-min(50ll,(a-1)%60)&lt;&lt;&#x27;\\n&#x27;;&#125; DDoS12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)using namespace std;const int maxn = 1e5 + 5;int in[maxn],vis[maxn];vector&lt;int&gt;vv[maxn];int main()&#123; int n,m; sc(n); sc(m); while(m--)&#123; int u,v,w; sc(u); sc(v); sc(w); vv[u].push_back(v); in[v]++; &#125; vis[1]=1; queue&lt;int&gt;q; q.push(1); while(!q.empty())&#123; int fr=q.front(); q.pop(); for(int t:vv[fr])&#123; vis[t]=(vis[t]+vis[fr])%20010905; if(!--in[t]) q.push(t); &#125; &#125; pf(&quot;%d\\n&quot;,vis[n]);&#125; Exams1234567#include&lt;bits/stdc++.h&gt;int main()&#123; int n; double a1(0),a2(0); std::cin&gt;&gt;n; while(n--)&#123; int a; double b,c,d,e,f,g,h; std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f&gt;&gt;g&gt;&gt;h; if(a==2) continue; a1+=b*(int)(c*d+e*f+g*h+0.5); a2+=b; &#125; printf(&quot;%.2lf&quot;,a1/a2);&#125; Fool Problem12345#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; cin&gt;&gt;s; puts((s[s.size()-1]-&#x27;0&#x27;)&amp;1?&quot;-1&quot;:&quot;1&quot;);&#125; Game1234567#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)int main()&#123; int n,cnt(0); std::cin&gt;&gt;n; rep(i,2,n+1) while(n%i==0) n/=i,cnt++; puts(cnt&amp;1?&quot;Nancy&quot;:&quot;Johnson&quot;);&#125; ”Happy New Year!“php 1&quot;Happy New Year!&quot; I love you1234567891011#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[10],mod=20010905;int main()&#123; string s,q=&quot; iloveyou&quot;; a[0]=1; cin&gt;&gt;s; int len=s.length(); rep(i,0,len)&#123; s[i]=tolower(s[i]); rep(j,1,9) a[j]=(a[j]+(s[i]==q[j])*a[j-1])%mod; &#125; cout&lt;&lt;a[8];&#125; Jelly我真的服了 这都能wa 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;char mp[105][105][105];int dir[6][3]=&#123;1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1&#125;;struct node&#123; int x,y,z,cnt;&#125;;int n,cnt;int vis[105][105][105];queue&lt;node&gt;q;int bfs()&#123; q.push(node&#123;0,0,0,1&#125;); vis[0][0][0]++; while(!q.empty())&#123; node fr=q.front(); q.pop(); rep(i,0,6)&#123; node c=fr; c.x+=dir[i][0],c.y+=dir[i][1],c.z+=dir[i][2]; if(c.x&lt;0||c.y&lt;0||c.z&lt;0||c.x&gt;=n||c.y&gt;=n||c.z&gt;=n) continue; if(vis[c.x][c.y][c.z]||mp[c.x][c.y][c.z]==&#x27;*&#x27;) continue; vis[c.x][c.y][c.z]++; c.cnt++; q.push(c); if(c.x==n-1&amp;&amp;c.y==n-1&amp;&amp;c.z==n-1) return cout&lt;&lt;c.cnt,0; &#125; &#125; return cout&lt;&lt;-1,0;&#125;int main()&#123; cin&gt;&gt;n; rep(i,0,n) rep(j,0,n) cin&gt;&gt;mp[i][j]; bfs();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"Wannafly Winter Camp 2020-Day7","slug":"Wannafly Winter Camp 2020-Day7","date":"2020-01-18T11:46:10.000Z","updated":"2021-01-26T16:42:40.468Z","comments":true,"path":"2020/01/18/Wannafly Winter Camp 2020-Day7/","link":"","permalink":"http://wzgshyvin.github.io/2020/01/18/Wannafly%20Winter%20Camp%202020-Day7/","excerpt":"今天也还好？队伍EHK三题 我EH 虽然说E是打表的（","text":"今天也还好？队伍EHK三题 我EH 虽然说E是打表的（ 前一个小时状态极差 属于看什么什么不会 看H没有一点思路 感慨：他们怎么都会啊手推了一下H前5项的情况 心里大概有了猜想 看了看ac队伍的用时也和想的式子一样 为了保险又手推了6 果然想的是对的 早知道莽了.jpg但还是因为计算范围错了炸int了wa了一发 我是废物过了H的生活因为K两个队友都在看 就去看新题了（加上我也不是很想推 开了E 又是手推了前几项 猜想了一个结论 顺利wa然后考虑到了其他情况 继续推式子 但队友K还没过 遂帮倒忙地看了看K 因为真的懒得推 队友推了好几遍我相信式子没问题！又去看E发现E在oeis直接有表 换Java写 因为语法不熟和改得太急成功wa*2队友也把K过了 +10 排名从100开外变成50+ 最终排名60+吧 还行（ 7E. 上升下降子序列123456789101112import java.math.*;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); int n=sc.nextInt(); BigInteger m=sc.nextBigInteger(); if(n==1)&#123; System.out.println(0); return; &#125; String[] s=&#123;&quot;2&quot;,&quot;6&quot;,&quot;22&quot;,&quot;86&quot;,&quot;340&quot;,&quot;1340&quot;,&quot;5254&quot;,&quot;20518&quot;,&quot;79932&quot;,&quot;311028&quot;,&quot;1209916&quot;,&quot;4707964&quot;,&quot;18330728&quot;,&quot;71429176&quot;,&quot;278586182&quot;,&quot;1087537414&quot;,&quot;4249391468&quot;,&quot;16618640836&quot;,&quot;65048019092&quot;,&quot;254814326164&quot;,&quot;998953992728&quot;,&quot;3919041821896&quot;,&quot;15385395144092&quot;,&quot;60438585676636&quot;,&quot;237563884988120&quot;,&quot;934311596780040&quot;,&quot;3676495517376184&quot;,&quot;14474185732012088&quot;,&quot;57011153530262480&quot;,&quot;224656915621201776&quot;,&quot;885652912419210822&quot;,&quot;3492861836026915782&quot;,&quot;13780479845245611084&quot;,&quot;54388113081432337380&quot;,&quot;214729932989712917668&quot;,&quot;848052809484541707556&quot;,&quot;3350334574655466140216&quot;,&quot;13239822072430180232232&quot;,&quot;52335808270599440879284&quot;,&quot;206934571189982074002548&quot;,&quot;818425886045480073365896&quot;,&quot;3237673398479042349060632&quot;,&quot;12811192923571669467870664&quot;,&quot;50704290989642196738527048&quot;,&quot;200721767558683308700217776&quot;,&quot;794758327136359419952519952&quot;,&quot;3147480247103506996680796444&quot;,&quot;12467371711588974170827212188&quot;,&quot;49393251191799570968275635832&quot;,&quot;195721323613651013964116220008&quot;,&quot;775681930753017847189773247816&quot;,&quot;3074691375740439617836809788744&quot;,&quot;12189592067181565816702419563248&quot;,&quot;48333049189844665620128143125968&quot;,&quot;191674487676565550273850199554424&quot;,&quot;760234106384599142912931614646008&quot;,&quot;3015721572748589992463595600401200&quot;,&quot;11964485381977151314836595373090960&quot;,&quot;47473780481353767802050510461474416&quot;,&quot;188394767873878618122620614886243696&quot;,&quot;747717213262848575274466080605467552&quot;,&quot;2967958428851480386917331132533607136&quot;,&quot;11782259592346823520686656131742782022&quot;,&quot;46778706886870096588550881954439021894&quot;,&quot;185744202455399051984941117140485426188&quot;,&quot;737612707907218431744486755161165283876&quot;,&quot;2929451267263567016070637982850089264452&quot;,&quot;11635570442457473175795713890168152798404&quot;,&quot;46220155055609632689452725735280292076408&quot;,&quot;183618435592218742042711461696686422730216&quot;,&quot;729526765909664873244748736973027445604932&quot;,&quot;2898712749488697136757456372292134404034564&quot;,&quot;11518796733262965478081905854113416167753128&quot;,&quot;45776865583236473399203960989099899119494776&quot;,&quot;181937009594320978873736215406788995917525032&quot;,&quot;723154688965889751097101396443192826411889064&quot;,&quot;2874588225169330729910266250097039087510781168&quot;,&quot;11427560208426660761216674193001922526450403536&quot;,&quot;45432226748523983679867488376304124899523401012&quot;,&quot;180636860154887532842333974035976978875788303284&quot;,&quot;718256924308840704281727251872444612431548985768&quot;,&quot;2856167234882640332177000885696057331411192948216&quot;,&quot;11358398642653256630400822038234943728547172796632&quot;,&quot;45173065721576308057178968529470878470010061869784&quot;,&quot;179667842488623618336093016334593779472760809719248&quot;,&quot;714642491229551839105935178063714692911965481155696&quot;,&quot;2842722058240330382759816822753037594153543736276232&quot;,&quot;11308537787442034315752841106800792975560381040259464&quot;,&quot;44988801505636138725613585002139650894736930818859728&quot;,&quot;178989582482503853042943703302031527717732898643340656&quot;,&quot;712157265987568127773494228152764511315128648488823312&quot;,&quot;2833664093821898191595666210009358256743525029610686224&quot;,&quot;11275728828895114632325888269455044211548265118705668448&quot;,&quot;44870838790971390745360943764893423662680647193816689696&quot;,&quot;178569214591821033028866839352551169428060985661714360092&quot;,&quot;710675533602207732686301380136130771528525107574404678684&quot;,&quot;2828512285392854707326223033551336688181493890435185846968&quot;,&quot;11258130303537041119524653026082830440762998748471762960936&quot;,&quot;44812126024908558505907621010943168569218082391894548561192&quot;&#125;; BigInteger q=new BigInteger(s[n-2]); q=q.mod(m); System.out.println(q); &#125;&#125; 7H. 游戏12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;ll n,cnt,ans,num,g;int main()&#123; scl(n); rep(i,1,n+1) rep(j,i+1,n+1) if(__gcd(i,j)==1) cnt++; if(n==1) return puts(&quot;0/1&quot;),0; if(n==2||n==3) return puts(&quot;1/1&quot;),0; ans=n*(n-1)/2; num=n/2; g=__gcd(num*cnt,ans); pf(&quot;%lld/%lld\\n&quot;,num*cnt/g,ans/g);&#125; 7K. 修炼1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int n,a1,a2,b1[maxn],b2[maxn];int check(int x)&#123; ll t1=1ll*a1*x,t2=1ll*a2*x,mn=1e18; rep(i,1,n+1)&#123; ll res=0; if(t1&gt;=b1[i]&amp;&amp;t2&gt;=b2[i]) return 0; res+=b1[i]-t1&gt;0?b1[i]-t1:0; res+=b2[i]-t2&gt;0?b2[i]-t2:0; mn=min(mn,res); &#125; return 1ll*x*(x+1)/2&lt;mn;&#125;int main()&#123; cin&gt;&gt;a1&gt;&gt;a2&gt;&gt;n; rep(i,1,n+1) cin&gt;&gt;b1[i]&gt;&gt;b2[i]; int l=-1,r=1e9; while(l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if(check(mid)) l=mid+1; else r=mid-1; &#125; pf(&quot;%d\\n&quot;,l);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day6","slug":"Wannafly Winter Camp 2020-Day6","date":"2020-01-17T11:12:31.000Z","updated":"2021-01-26T16:42:34.080Z","comments":true,"path":"2020/01/17/Wannafly Winter Camp 2020-Day6/","link":"","permalink":"http://wzgshyvin.github.io/2020/01/17/Wannafly%20Winter%20Camp%202020-Day6/","excerpt":"手速场 今天是废物","text":"手速场 今天是废物 开局挑了个题目 “自闭” 一看 哦 小模拟 这个我学得来和队友说 有个模拟 我去写了 同时立下flag：前三小时可能没我了写完后因为傻逼和语文太差被关了半小时这时候已经写得差不多了 没我啥事了去想J 然后被关到比赛结束 玄学做法果然不可取赛后dp补了 6C. 酒馆战棋最不爱写的题 队友代码 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;char s[1005];int main()&#123; int _; sc(_); while(_--)&#123; int n,a,b,c,d; sc(n),sc(a),sc(b),sc(c),sc(d),scs(s); int aa=a,bb=b,cc=c,dd=d,mx=0,mn=0; rep(i,0,n)&#123; if(s[i]==&#x27;0&#x27;)&#123; if(dd) dd--,cc++; else if(cc)&#123; &#125; else if(bb) bb--,aa++; &#125; else&#123; if(cc) mx++,cc--; else if(dd) dd--,cc++; else if(aa) aa--,mx++; else if(bb) bb--,aa++; &#125; &#125; aa=a,bb=b,cc=c,dd=d; rep(i,0,n)&#123; if(s[i]==&#x27;0&#x27;)&#123; if(cc)&#123; &#125; else if(dd) dd--,cc++; else if(aa)&#123; &#125; else if(bb) bb--,aa++; &#125; else&#123; if(dd) dd--,cc++; else if(cc) cc--,mn++; else if(bb) bb--,aa++; else if(aa) aa--,mn++; &#125; &#125; pf(&quot;%d %d\\n&quot;,mx,mn); &#125;&#125; 6F. 图与三角形12345678910111213#include&lt;bits/stdc++.h&gt;#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;ll n,a,b,c,p,d,ans;vector&lt;int&gt;vv[5005];int main()&#123; scl(n); scl(a); scl(b); scl(c); scl(p); scl(d); rep(i,1,n+1) rep(j,1,n+1) if(i!=j&amp;&amp;(a*(i+j)*(i+j)+b*(i-j)*(i-j)+c)%p&gt;d) vv[i].push_back(j); rep(i,1,n+1) ans+=vv[i].size()*(n-vv[i].size()-1); ans=n*(n-1)*(n-2)/6-ans/2; printf(&quot;%lld\\n&quot;,ans);&#125; 6K. 最大权值排列123456789101112#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 1e5 + 5;int a[maxn];int main()&#123; int n,cnt(1); sc(n); rep(i,1,n+1)&#123; if(i&amp;1) a[cnt]=i; else a[n-cnt+1]=i,cnt++; &#125; rep(i,1,n+1) pf(&quot;%d &quot;,a[i]);&#125; 6L. 你吓到我的马了.jpg123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;char mp[105][105];int n,m,vis[105][105],ans[105][105];int dir[8][2]=&#123;2,1,2,-1,-2,1,-2,-1,1,2,1,-2,-1,2,-1,-2&#125;;struct node&#123; int x,y,cnt; &#125;s;void bfs()&#123; ans[s.x][s.y]=0; vis[s.x][s.y]=1; queue&lt;node&gt;q; q.push(s); while(!q.empty())&#123; node fr=q.front(); q.pop(); ans[fr.x][fr.y]=fr.cnt; rep(i,0,8)&#123; node t=fr; t.x+=dir[i][0],t.y+=dir[i][1],t.cnt++; if(t.x&lt;0||t.y&lt;0||t.x&gt;=n||t.y&gt;=m) continue; if(vis[t.x][t.y]||mp[t.x][t.y]==&#x27;X&#x27;) continue; if(mp[fr.x+dir[i][0]/2][fr.y+dir[i][1]/2]==&#x27;X&#x27;) continue; q.push(t); vis[t.x][t.y]++; &#125; &#125;&#125;int main()&#123; sc(n); sc(m); rep(i,0,n)&#123; scs(mp[i]); rep(j,0,m) if(mp[i][j]==&#x27;M&#x27;) s.x=i,s.y=j,s.cnt=0; &#125; mst(ans,-1); bfs(); rep(i,0,n) rep(j,0,m) pf(&quot;%d%c&quot;,ans[i][j],j==m-1?&#x27;\\n&#x27;:&#x27; &#x27;);&#125; 6M. 自闭12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;int q[105][15][2]; //计数int vis[105],ac[105]; //vis这个人有没有交过 ac这个人有没有提交过int sd[15]; //solvedint wa[105][15];int main()&#123; int n,m,w; sc(n); sc(m); sc(w); rep(i,0,w)&#123; int x,y,c; sc(x); sc(y); sc(c); q[x][y][c]++; vis[x]++; if(c)&#123; //如果是ac if(q[x][y][0]) wa[x][y]=max(wa[x][y],q[x][y][0]),q[x][y][0]=0; ac[x]++; if(q[x][y][1]==1) sd[y]++; //不重复计算ac人数 &#125; &#125; rep(i,1,n+1) rep(j,1,m+1) if(q[i][j][0]) wa[i][j]=max(wa[i][j],q[i][j][0]); rep(i,1,n+1)&#123; if(!vis[i]) puts(&quot;998244353&quot;); //没提交 else if(!ac[i]) puts(&quot;1000000&quot;); //爆零 else&#123; int ak(1); rep(j,1,m+1) if(!q[i][j][1]) ak=0; if(ak) puts(&quot;0&quot;); else&#123; //4 有人a自己没a +20 //5 过半人a自己没a +10 int ans(0); rep(j,1,m+1) if(!q[i][j][1]&amp;&amp;sd[j])&#123; ans+=20; if(sd[j]&gt;=n/2) ans+=10; &#125; //6 连wa k次 +k^2 //7 连wa k次且没a +k^2 rep(j,1,m+1)&#123; int k=wa[i][j]; k*=k; ans+=k; if(!q[i][j][1]) ans+=k; &#125; pf(&quot;%d\\n&quot;,ans); &#125; &#125; &#125;&#125; 6N. 合并！12345678910111213#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;int a[2005];int main()&#123; int n; ll ans(0); sc(n); rep(i,0,n) sc(a[i]); sort(a,a+n); if(n==1) return pf(&quot;%d\\n&quot;,a[0]),0; rep(i,0,n-1) ans+=1ll*a[i]*a[i+1],a[i+1]+=a[i]; pf(&quot;%lld\\n&quot;,ans);&#125; 补题： 6G. 单调栈123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;int a[105],ans[105];int main()&#123; int _; sc(_); while(_--)&#123; int n; sc(n); rep(i,0,n) sc(a[i]); int cnt(0),pos(0); mst(ans,0); rep(i,1,n+1)&#123; while(pos&lt;n&amp;&amp;ans[pos]) pos++; if(pos==n) break; if(a[pos]==-1) a[pos]=i; dep(j,n-1,pos) if(a[j]==i) ans[j]=++cnt; &#125; rep(i,0,n) pf(&quot;%d%c&quot;,ans[i],i==n-1?&#x27;\\n&#x27;:&#x27; &#x27;); &#125;&#125; 6J. K重排列123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;int jc[55],inv[55];int dp[55],tmp[55];int q[55][55][55];int qpow(int x,int y)&#123; int ans=1; while(y)&#123; if(y&amp;1) ans=1ll*ans*x%mod; x=1ll*x*x%mod; y&gt;&gt;=1; &#125; return ans;&#125;int C(int s,int x)&#123; return 1ll*jc[x]*inv[s]%mod*inv[x-s]%mod;&#125;void init()&#123; jc[0]=inv[0]=1; rep(i,1,51) jc[i]=1ll*jc[i-1]*i%mod,inv[i]=qpow(jc[i],mod-2); rep(i,1,51) rep(j,i,51) rep(k,1,j/i+1) if(k==1) q[i][j][k]=C(i,j); else q[i][j][k]=1ll*q[i][j-i][k-1]*C(i,j)%mod;&#125;void solve()&#123; int n; ll k; sc(n); scl(k); mst(dp,0); dp[0]=1; rep(i,1,n+1)&#123; if(k%i) continue; memcpy(tmp,dp,sizeof(dp)); rep(j,0,n+1) for(int t=1,a=jc[i-1];j+t*i&lt;=n;++t,a=1ll*a*jc[i-1]%mod) dp[j+t*i]=(1ll*dp[j+t*i]+1ll*tmp[j]*q[i][n-j][t]%mod*a%mod*inv[t])%mod; &#125; pf(&quot;%d\\n&quot;,dp[n]);&#125;int main()&#123; init(); int _; sc(_); while(_--) solve();&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day5","slug":"Wannafly Winter Camp 2020-Day5","date":"2020-01-16T10:01:26.000Z","updated":"2021-01-26T16:42:28.349Z","comments":true,"path":"2020/01/16/Wannafly Winter Camp 2020-Day5/","link":"","permalink":"http://wzgshyvin.github.io/2020/01/16/Wannafly%20Winter%20Camp%202020-Day5/","excerpt":"今天不自闭了 rk31","text":"今天不自闭了 rk31 队里的罚时提供者 非ac的全是我交的(开场写G 当时范围还是1e16 打了个表 等表的时候去看A(一看 啊 啥玩意啊 咋写啊 我学不来啊再一看 k&lt;=3啊 那没事了然后傻逼错误wa了3次 哈哈然后表打完了 对着2e8想了一下 然后看看群 哦哦杜爹说改范围了我对队友:”哦,我会!”然后复杂度算错 -3 哈哈数组开小re一次 最后+4这时候是第七个过的!猛猛猛男我:”反正别人有+11的!我的+4也还好8”然后划水划了1h(?帮队友康了康E 找到了几个bug 调了一下 过样例了!我:”要不要交?”队友:”交交交”wa6演 wz 演然后写代码的队友找到了真正的bug!ac!快乐地离场了 5A. Alternative Accounts123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int q[3][maxn];vector&lt;int&gt;vv[6];int main()&#123; int n,k,m,a,cnt(0); sc(n); sc(k); rep(i,0,k)&#123; sc(m); rep(j,0,m) sc(a),q[i][a]++; &#125; if(k==1) pf(&quot;%d&quot;,m); else if(k==2)&#123; rep(i,1,n+1)&#123; if(q[0][i]+q[1][i]==2) cnt++; else if(q[0][i]) vv[0].push_back(i); else if(q[1][i]) vv[1].push_back(i); &#125; cnt+=max(vv[0].size(),vv[1].size()); pf(&quot;%d\\n&quot;,cnt); &#125; else if(k==3)&#123; rep(i,1,n+1)&#123; if(q[0][i]+q[1][i]+q[2][i]==3) cnt++; else if(q[0][i]+q[1][i]+q[2][i]==2)&#123; if(q[0][i]&amp;&amp;q[1][i]) vv[0].push_back(i); if(q[0][i]&amp;&amp;q[2][i]) vv[1].push_back(i); if(q[1][i]&amp;&amp;q[2][i]) vv[2].push_back(i); &#125; else if(q[0][i]+q[1][i]+q[2][i]==1)&#123; if(q[2][i]) vv[3].push_back(i); if(q[1][i]) vv[4].push_back(i); if(q[0][i]) vv[5].push_back(i); &#125; &#125; int sz[3]; mst(sz,0); rep(i,0,3) sz[i]=vv[i+3].size(); rep(i,0,3) cnt+=vv[i].size(),sz[i]-=vv[i].size(); rep(i,0,3) if(sz[i]&lt;0) sz[i]=0; cnt+=max(sz[0],max(sz[1],sz[2])); pf(&quot;%d\\n&quot;,cnt); &#125;&#125; 5E. Matching Problem1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int n,ans,a[305],b[5],sum[305][305];map&lt;int,int&gt;aaa;int getsum(int x,int y,int z)&#123; int res=n-x; res-=sum[x+1][a[x]]; if(a[x]!=a[y]) res-=sum[x+1][a[y]]; if(a[x]!=a[z]&amp;&amp;a[y]!=a[z]) res-=sum[x+1][a[y]]; return res;&#125;int main()&#123; sc(n); rep(i,1,n+1) sc(a[i]),aaa[a[i]]++; rep(i,1,5) sc(b[i]); dep(i,n,1)&#123; for(auto &amp;x:aaa) sum[i][x.first]=sum[i+1][x.first]; sum[i][a[i]]++; &#125; int pos(0); rep(i,1,4) if(b[i]==b[4]) pos=i; rep(i,1,n+1) rep(j,i+1,n+1) rep(k,j+1,n+1)&#123; int ff=(pos==1?i:pos==2?j:k); if((a[i]==a[j])==(b[1]==b[2])&amp;&amp;(a[j]==a[k])==(b[2]==b[3])&amp;&amp;(a[i]==a[k])&amp;&amp;(b[1]==b[3])) ans+=ff?sum[k+1][a[ff]]:getsum(k,j,i); &#125; pf(&quot;%d\\n&quot;,ans);&#125; 5G. Cryptographically Secure Pseudorandom Number Generator123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e5 + 5;pii a[2000]; int inv[maxn];int solve()&#123; int p,cnt(0),ff(0),mn; sc(p); if(p==1||p==2) return pf(&quot;0\\n&quot;); inv[0]=0,inv[1]=1,inv[2]=p/2+1,mn=inv[2]; rep(i,2,p)&#123; inv[i]=1ll*(p-p/i)*inv[p%i]%p; if(inv[i]&lt;=mn)&#123; if(inv[i]==a[cnt-1].first) break; mn=inv[i]; a[cnt++]=pii(i,inv[i]); if(i==inv[i])&#123; ff++; break; &#125; &#125; &#125; pf(&quot;%d\\n&quot;,cnt*2-ff); rep(i,0,cnt) pf(&quot;%d %d\\n&quot;,a[i].first,a[i].second); dep(i,cnt-1-ff,0) pf(&quot;%d %d\\n&quot;,a[i].second,a[i].first); return 0;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 补题： 5A. Alternative Accounts短的 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,k,t,a,b,q[100005];int main()&#123; cin&gt;&gt;n&gt;&gt;k; while(k--)&#123; cin&gt;&gt;m; a=max(a,m); while(m--) cin&gt;&gt;t,q[t]++; &#125; while(n--) if(q[n+1]&gt;1) b++; cout&lt;&lt;max(a,b)&lt;&lt;&#x27;\\n&#x27;; &#125; 5J. Xor on Figures1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;char s[50][50];bitset&lt;1050&gt;p[1050],q;int n,cnt,ans=1,mod=1e9+7;void change(int x,int y)&#123; rep(i,0,n) rep(j,0,n) q[(i+x)%n*n+(j+y)%n]=s[i][j]-&#x27;0&#x27;; rep(i,0,n*n) if(q[i]==1)&#123; if(!p[i].count())&#123; p[i]=q; cnt++; break; &#125; q^=p[i]; &#125;&#125;int main()&#123; sc(n); n=1&lt;&lt;n; rep(i,0,n) scs(s[i]); rep(i,0,n) rep(j,0,n) change(i,j); rep(i,0,cnt) ans=2ll*ans%mod; pf(&quot;%d\\n&quot;,ans); &#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day3","slug":"Wannafly Winter Camp 2020-Day3","date":"2020-01-14T14:55:49.000Z","updated":"2021-01-26T16:41:58.907Z","comments":true,"path":"2020/01/14/Wannafly Winter Camp 2020-Day3/","link":"","permalink":"http://wzgshyvin.github.io/2020/01/14/Wannafly%20Winter%20Camp%202020-Day3/","excerpt":"赛时爆零了 记的是补题qwq","text":"赛时爆零了 记的是补题qwq 3A. 黑色气球12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[1005][1005],h[1005];int main()&#123; int n; sc(n); ll sum(0); rep(i,0,n) rep(j,0,n) sc(a[i][j]),sum+=1ll*a[i][j],h[i]+=a[i][j]; if(n==2) return pf(&quot;1 1\\n&quot;),0; sum/=(2ll*n-2); rep(i,0,n) pf(&quot;%d &quot;,(-1*sum+h[i])/(n-2));&#125; 3C. 无向图定向1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int n,m,ans,c[20];vector&lt;int&gt;vv[20];int judge(int x,int id)&#123; for(int t:vv[x]) if(c[t]==id) return 1; return 0;&#125;void dfs(int x,int num)&#123; if(ans&lt;=num) return; if(x&gt;n) return ans=min(ans,num),(void)0; rep(i,1,num+1) if(!judge(x,i))&#123; c[x]=i; dfs(x+1,num); c[x]=0; &#125; c[x]=num+1; dfs(x+1,num+1); c[x]=0;&#125;int main()&#123; sc(n); sc(m); ans=1e9; while(m--)&#123; int u,v; sc(u); sc(v); vv[u].push_back(v); vv[v].push_back(u); &#125; dfs(1,0); printf(&quot;%d\\n&quot;,ans-1);&#125; 3E. 棋技哥123456789101112#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;char s[505],c;int main()&#123; int _; sc(_); while(_--)&#123; int n,m; sc(n); sc(m); scs(s); c=s[0]; rep(i,1,n) scs(s); puts(c==&#x27;0&#x27;?&quot;aoligei&quot;:&quot;call&quot;); &#125;&#125; 3G. 火山哥周游世界1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; pii;const int maxn = 5e5 + 5;int n,k,vis[maxn];ll num[maxn],sum[maxn];ll mx1[maxn],mx2[maxn];vector&lt;pii&gt;vv[maxn];void upd(int id,ll x)&#123; if(x&gt;=mx1[id]) mx2[id]=mx1[id],mx1[id]=x; else if(x&gt;mx2[id]) mx2[id]=x;&#125;void dfs1(int x,int f)&#123; if(vis[x]) num[x]++; sum[x]=mx1[x]=mx2[x]=0; for(pii t:vv[x])&#123; ll y=t.first,z=t.second; if(y==f) continue; dfs1(y,x); num[x]+=num[y]; sum[x]+=sum[y]+(num[y]&gt;0)*z; upd(x,mx1[y]+(num[y]&gt;0)*z); &#125;&#125;void dfs2(int x,int f)&#123; for(pii t:vv[x])&#123; ll y=t.first,z=t.second; if(y==f) continue; sum[y]=sum[x]-z*(num[y]&gt;0)+z*(n-num[y]&gt;0); if(num[y]!=n&amp;&amp;mx1[y]+z==mx1[x]) upd(y,mx2[x]+z); else if(num[y]!=n) upd(y,mx1[x]+z); dfs2(y,x); &#125;&#125;int main()&#123; sc(n); sc(k); rep(i,1,n)&#123; ll u,v,w; scl(u); scl(v); scl(w); vv[u].push_back(make_pair(v,w)); vv[v].push_back(make_pair(u,w)); &#125; int a0; sc(a0); vis[a0]++; k--; while(k--)&#123; int a; sc(a); vis[a]++; &#125; dfs1(a0,0); dfs2(a0,0); rep(i,1,n+1) pf(&quot;%lld\\n&quot;,sum[i]*2-mx1[i]);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day2","slug":"Wannafly Winter Camp 2020-Day2","date":"2020-01-13T14:55:49.000Z","updated":"2021-01-26T16:41:51.171Z","comments":true,"path":"2020/01/13/Wannafly Winter Camp 2020-Day2/","link":"","permalink":"http://wzgshyvin.github.io/2020/01/13/Wannafly%20Winter%20Camp%202020-Day2/","excerpt":"真的隔了好久才补 赛时爆零了qwq","text":"真的隔了好久才补 赛时爆零了qwq 2A. 托米的字符串123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;char s[maxn];double p[maxn],q[maxn],ans;int judge(char c)&#123; if(c==&#x27;a&#x27;||c==&#x27;e&#x27;||c==&#x27;i&#x27;) return 1; if(c==&#x27;o&#x27;||c==&#x27;u&#x27;||c==&#x27;y&#x27;) return 1; return 0;&#125;int main()&#123; scs(s+1); int len=strlen(s+1); rep(i,1,len+1) p[i]=p[i-1]+1.0/i; rep(i,1,len+1) q[i]=q[i-1]+p[i]; rep(i,1,len+1) if(judge(s[i])) ans+=q[len]-q[len-i]-q[i-1]; pf(&quot;%.9lf\\n&quot;,2.0*ans/(1.0*len*(len+1)));&#125; 2C. 纳新一百的石子游戏123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;ll x,q[65];int main()&#123; int n; sc(n); rep(i,0,n)&#123; ll a; scl(a); x^=a; int cnt=0; while(a)&#123; cnt++; if(a&amp;1) q[cnt]++; a&gt;&gt;=1; &#125; if(!x) pf(&quot;0\\n&quot;); else&#123; cnt=0; ll x1=x; while(x1)&#123; cnt++; x1&gt;&gt;=1; &#125; pf(&quot;%d\\n&quot;,q[cnt]); &#125; &#125;&#125; 2K. 破忒头的匿名信12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;const int maxn = 5e5 + 5;char s[maxn];ll tot,ch[maxn][26],nex[maxn];ll len[maxn],val[maxn],f[maxn];void insert(char* s,ll x)&#123; int n=strlen(s+1),p=1; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!ch[p][tmp]) ch[p][tmp]=++tot,len[tot]=len[p]+1; p=ch[p][tmp]; &#125; if(!val[p]) val[p]=x; else val[p]=min(val[p],x);&#125;void build()&#123; queue&lt;ll&gt;q; q.push(1); nex[1]=0; while(!q.empty())&#123; int fr=q.front(); q.pop(); rep(i,0,26) if(!ch[fr][i]) ch[fr][i]=ch[nex[fr]][i]; else nex[ch[fr][i]]=ch[nex[fr]][i],q.push(ch[fr][i]); &#125;&#125;int find(char* s)&#123; int n=strlen(s+1),p=1; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;,k=ch[p][tmp]; while(k&gt;1)&#123; if(val[k]) f[i]=min(f[i],f[i-len[k]]+val[k]); k=nex[k]; &#125; p=ch[p][tmp]; &#125; if(f[n]&gt;1e18) return puts(&quot;-1&quot;); return pf(&quot;%lld\\n&quot;,f[n]);&#125;int main()&#123; ll n,a; scl(n); mst(f,0x3f); f[0]=0; rep(i,0,26) ch[0][i]=1; tot=1; rep(i,0,n) scs(s+1),scl(a),insert(s,a); build(); scs(s+1); find(s);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"}]},{"title":"Wannafly Winter Camp 2020-Day1","slug":"Wannafly Winter Camp 2020-Day1","date":"2020-01-12T14:55:49.000Z","updated":"2021-01-26T16:41:44.005Z","comments":true,"path":"2020/01/12/Wannafly Winter Camp 2020-Day1/","link":"","permalink":"http://wzgshyvin.github.io/2020/01/12/Wannafly%20Winter%20Camp%202020-Day1/","excerpt":"第一场比赛还算比较顺利8","text":"第一场比赛还算比较顺利8 队伍BCH三题 rk55 我写了CH两题 算是没丢数学选手兼Java选手的脸吧233开题时看到H的题目“最大公约数”就直接点进去了 然后有思路开始写 wa2 造了几个小数据发现自己有地方假了 调过了一交还是wa2 然后想了想极限数据 啊好像long long必炸 就换Java写了 然后AC在我调H的时候队友已经把B过了 然后好像是对着F自闭？H过了惊闻刘老师把C秒了 我:刘老师能秒我们应该也能A! 就看看C 很快有了想法 手推了一下样例验证了猜想开始写 因为我是没有化出式子的QAQ 就一堆中间过程 写得头都没了 写完一测样例四个没过 开始自闭 然后当时以为五点半就结束了有点想放弃了 一看比赛时间还一个小时 又充满了信心继续调 终于把第四个样例调对了 一比对第五个样例的对的 直接交了 1A 激动得要死最后45min试着想F 实在是没思路QAQ 比赛结束!晚上听jls讲题 啊jls真的太帅了 我永远喜欢jry附赛时代码 2020 CCPC Wannafly Winter Camp Day1 B. 密码学1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;char s[1005][105];int n,m,x[1005],y[1005];int change(char c)&#123; if(c&gt;=&#x27;a&#x27;) return c-&#x27;a&#x27;; else return c-&#x27;A&#x27;+26;&#125;void solve(int a,int b)&#123; int l1=strlen(s[a]),l2=strlen(s[b]); rep(i,0,l2)&#123; int p=change(s[a][i%l1]),q=change(s[b][i]),t=(q-p+52)%52; if(t&lt;26) s[b][i]=&#x27;a&#x27;+t; else s[b][i]=&#x27;A&#x27;+t-26; &#125;&#125;int main()&#123; sc(n); sc(m); rep(i,1,m+1) sc(x[i]),sc(y[i]); rep(i,1,n+1) scs(s[i]); dep(i,m,1) solve(x[i],y[i]); rep(i,1,n+1) pf(&quot;%s\\n&quot;,s[i]);&#125; 2020 CCPC Wannafly Winter Camp Day1 C. 染色图想了想公式确实是可以化出来的 但我没有(调傻了( 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;int main()&#123; int _; sc(_); while(_--)&#123; ll n,l,r; scl(n); scl(l); scl(r); ll ans=n*(n-1)/2%mod,res=0; ans=ans*(r-l+1)%mod; for(ll i=1;i*i&lt;=n;i++)&#123; ll r1=n/i,l1=n/(i+1)+1; if(l1&gt;r1) l1=r1; //上下界 if(i&gt;=l)&#123; ll ys=n%i,sy=i-ys; //余数 剩余 res+=ys*(r1*(r1+1)/2)%mod+sy*(r1*(r1-1)/2)%mod; res%=mod; //i时的数量 &#125; if(r1==i) break; l1=max(l1,l); r1=min(r1,r); if(l1&gt;r1) continue; ll a1=n%r1,a2=n%l1; ll num=(r1-l1+1),sum=(a1+a2)*num/2%mod; ll rem=(l1+r1)*num/2-sum; rem%=mod; ll t1=i*(i-1)/2%mod,t2=i*(i+1)/2%mod; res+=t1*rem%mod; res%=mod; res+=t2*sum%mod; res%=mod; &#125; ans-=res; ans=(ans+mod)%mod; pf(&quot;%lld\\n&quot;,ans); &#125;&#125; 2020 CCPC Wannafly Winter Camp Day1 H. 最大公约数wa了两次才想到用Java( 1234567891011121314151617181920212223import java.math.*;import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc=new Scanner(System.in); int t=sc.nextInt(); while(t--&gt;0)&#123; int n=sc.nextInt(); int x=sc.nextInt(); int[] vis=new int[505]; for(int i=1;i&lt;=n;i++) vis[i]=0; if(n&lt;2*x) Syst,em.out.println(x); else&#123; for(int i=2*x;i&lt;=n;i+=x) vis[i]=1; for(int i=2*x;i&lt;=n;i+=x) for(int j=i*2;j&lt;=n;j+=i) if(vis[j]==1) vis[j]=0; BigInteger ans=BigInteger.valueOf(x); ans=ans.multiply(new BigInteger(&quot;2&quot;)); for(int i=2*x+1;i&lt;=n;i++) if(vis[i]==1)&#123; BigInteger tmp=BigInteger.valueOf(i); tmp=tmp.divide(ans.gcd(BigInteger.valueOf(i))); ans=ans.multiply(tmp); &#125; System.out.println(ans); &#125; &#125; &#125;&#125; 补题: 2020 CCPC Wannafly Winter Camp Day1 A. 期望逆序对123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e3 + 5;const int mod = 998244353;pii p[maxn];ll inv[maxn];int cmp(pii a,pii b)&#123; return a.first+a.second&lt;b.first+b.second;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1) ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;ll count(pii a,pii b)&#123; if(b.first&gt;a.second) return 0; int l=max(a.first,b.first),r=min(a.second,b.second); ll ans=1ll*(l-b.first+r-b.first)*(r-l+1)/2%mod; ans=(ans+1ll*(a.second-r)*(b.second-b.first+1))%mod; return ans;&#125;int main()&#123; int n; sc(n); rep(i,0,n) sc(p[i].first),sc(p[i].second); sort(p,p+n,cmp); rep(i,0,n) inv[i]=qpow(p[i].second-p[i].first+1,mod-2); ll ans(0); rep(i,0,n) rep(j,i+1,n) ans=(ans+inv[i]*inv[j]%mod*count(p[i],p[j])%mod)%mod; pf(&quot;%lld\\n&quot;,ans);&#125; 2020 CCPC Wannafly Winter Camp Day1 F. 乘法生 涯 之 耻 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;ll n,m,k,a[maxn],b[maxn],an[3],bn[3];ll getsum(ll c,ll x)&#123; int l=1,r=m; while(l&lt;=r)&#123; int mid=(l+r)/2; if(b[mid]*c&gt;=x) c&gt;0?r=mid-1:l=mid+1; else c&gt;0?l=mid+1:r=mid-1; &#125; return c&gt;0?m-l+1:r;&#125;int check(ll x)&#123; ll sum(0); rep(i,1,n+1) sum+=getsum(a[i],x); return sum&gt;=k;&#125;ll solve(ll l,ll r)&#123; while(l&lt;=r)&#123; ll mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; return r;&#125;int main()&#123; scl(n); scl(m); scl(k); rep(i,1,n+1) scl(a[i]),an[a[i]?a[i]&gt;0?0:1:2]++; rep(i,1,m+1) scl(b[i]),bn[b[i]?b[i]&gt;0?0:1:2]++; sort(a+1,a+n+1); sort(b+1,b+m+1); ll t=an[0]*bn[0]+an[1]*bn[1]; if(k&lt;=t) return pf(&quot;%lld\\n&quot;,solve(1ll,max(a[1]*b[1],a[n]*b[m]))),0; t+=an[2]*m+bn[2]*n-an[2]*bn[2]; if(k&lt;=t) return puts(&quot;0&quot;),0; return pf(&quot;%lld\\n&quot;,solve(min(a[1]*b[m],b[1]*a[n]),-1ll)),0;&#125; 2020 CCPC Wannafly Winter Camp Day1 I. K小数查询namo n2可以过 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;int a[maxn],p[maxn];int main()&#123; int n,m; sc(n); sc(m); rep(i,1,n+1) sc(a[i]); while(m--)&#123; int op,l,r,x; sc(op); sc(l); sc(r); sc(x); if(op==1) rep(i,l,r+1) a[i]=min(a[i],x); else&#123; mst(p,0); rep(i,l,r+1) p[a[i]]++; int ans(0); rep(i,1,n+1)&#123; int at=ans; ans+=p[i]; if(at&lt;ans&amp;&amp;ans&gt;=x)&#123; pf(&quot;%d\\n&quot;,i); break; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"}]},{"title":"一道快乐的井字棋带模拟","slug":"带模拟","date":"2020-01-11T03:28:38.000Z","updated":"2021-01-26T16:43:02.633Z","comments":true,"path":"2020/01/11/带模拟/","link":"","permalink":"http://wzgshyvin.github.io/2020/01/11/%E5%B8%A6%E6%A8%A1%E6%8B%9F/","excerpt":"我过了带模拟 我好快乐 我是快乐的小熊软糖","text":"我过了带模拟 我好快乐 我是快乐的小熊软糖 题目链接吉首大学新生赛的带模拟 下井字棋问自己两步能不能赢其实也不算很大233代码长度3185 生涯之耻（不是注释应该蛮清楚的（挠头要注意的一点是如果初始局面自己已经获胜了 这个时候算wrong 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 5e5 + 5;char mp[3][3],c,d,t,p;map&lt;char,int&gt;aaa;int judge(char x)&#123; rep(i,0,3) if(mp[i][0]==x&amp;&amp;mp[i][1]==x&amp;&amp;mp[i][2]==x) return 1; rep(i,0,3) if(mp[0][i]==x&amp;&amp;mp[1][i]==x&amp;&amp;mp[2][i]==x) return 1; if(mp[0][0]==x&amp;&amp;mp[1][1]==x&amp;&amp;mp[2][2]==x) return 1; if(mp[0][2]==x&amp;&amp;mp[1][1]==x&amp;&amp;mp[2][0]==x) return 1; return 0;&#125;int count(char x)&#123; rep(i,0,3) if((mp[i][0]==x)+(mp[i][1]==x)+(mp[i][2]==x)&gt;=2 &amp;&amp;(mp[i][0]==&#x27;.&#x27;||mp[i][1]==&#x27;.&#x27;||mp[i][2]==&#x27;.&#x27;)) return t=1,p=i,1; rep(i,0,3) if((mp[0][i]==x)+(mp[1][i]==x)+(mp[2][i]==x)&gt;=2 &amp;&amp;(mp[0][i]==&#x27;.&#x27;||mp[1][i]==&#x27;.&#x27;||mp[2][i]==&#x27;.&#x27;)) return t=2,p=i,1; if((mp[0][0]==x)+(mp[1][1]==x)+(mp[2][2]==x)&gt;=2 &amp;&amp;(mp[0][0]==&#x27;.&#x27;||mp[1][1]==&#x27;.&#x27;||mp[2][2]==&#x27;.&#x27;)) return t=3,1; if((mp[2][0]==x)+(mp[1][1]==x)+(mp[0][2]==x)&gt;=2 &amp;&amp;(mp[2][0]==&#x27;.&#x27;||mp[1][1]==&#x27;.&#x27;||mp[0][2]==&#x27;.&#x27;)) return t=4,1; return 0;&#125;int find(char x)&#123; rep(i,0,3) if(mp[i][0]!=x&amp;&amp;mp[i][1]!=x&amp;&amp;mp[i][2]!=x) return t=1,p=i,1; rep(i,0,3) if(mp[0][i]!=x&amp;&amp;mp[1][i]!=x&amp;&amp;mp[2][i]!=x) return t=2,p=i,1; if(mp[0][0]!=x&amp;&amp;mp[1][1]!=x&amp;&amp;mp[2][2]!=x) return t=3,1; if(mp[0][2]!=x&amp;&amp;mp[1][1]!=x&amp;&amp;mp[2][0]!=x) return t=4,1; return 0;&#125;int solve()&#123; getchar(); aaa.clear(); rep(i,0,3) rep(j,0,3)&#123; mp[i][j]=getchar(); aaa[mp[i][j]]++; getchar(); &#125; c=getchar(); d=&#x27;o&#x27;+&#x27;x&#x27;-c; if(aaa[c]!=aaa[d]) return puts(&quot;wrong!&quot;); if(!aaa[&#x27;.&#x27;]||judge(d)||judge(c)) return puts(&quot;wrong!&quot;); if(aaa[&#x27;.&#x27;]==9||aaa[c]==1) return puts(&quot;Cannot win!&quot;); //一种是 自己第一步能赢 if(count(c)) return puts(&quot;LeeLdler win!&quot;); //一种是 自己不能一步赢 人机能一步赢 先堵人机 //count d 然后根据t去改mp 改完再去count c if(count(d))&#123; if(t==1) rep(i,0,3) if(mp[p][i]==&#x27;.&#x27;) mp[p][i]=c; else if(t==2) rep(i,0,3) if(mp[i][p]==&#x27;.&#x27;) mp[p][i]=c; else if(t==3) rep(i,0,3) if(mp[i][i]==&#x27;.&#x27;) mp[i][i]=c; else rep(i,0,3) if(mp[i][2-i]==&#x27;.&#x27;) mp[i][2-i]=c; return puts(count(c)?&quot;LeeLdler win!&quot;:&quot;Cannot win!&quot;); &#125; //一种是 自己和人机不能一步赢 下自己的 人机去堵 //这时候你选的应该是一个空列 指一行只有自己和空位 //如果没有空列 肯定赢不了 //一个空列有两种情况 两种都判一下 if(!find(d)) return puts(&quot;Cannot win!&quot;); else&#123; int tp1,tp2; if(t==1)&#123; rep(i,0,3) if(mp[p][i]==&#x27;.&#x27;)&#123; mp[p][i]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[p][i]==&#x27;.&#x27;)&#123; mp[p][i]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[p][tp1]=d,mp[p][tp2]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; else if(t==2)&#123; rep(i,0,3) if(mp[i][p]==&#x27;.&#x27;)&#123; mp[i][p]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[i][p]==&#x27;.&#x27;)&#123; mp[i][p]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[tp1][p]=d,mp[tp2][p]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; else if(t==3)&#123; rep(i,0,3) if(mp[i][i]==&#x27;.&#x27;)&#123; mp[i][i]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[i][i]==&#x27;.&#x27;)&#123; mp[i][i]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[tp1][tp1]=d,mp[tp2][tp2]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; else&#123; rep(i,0,3) if(mp[i][2-i]==&#x27;.&#x27;)&#123; mp[i][2-i]=c,tp1=i; break; &#125; rep(i,0,3) if(mp[i][2-i]==&#x27;.&#x27;)&#123; mp[i][2-i]=d,tp2=i; &#125; if(count(c)) return puts(&quot;LeeLdler win!&quot;); mp[tp1][2-tp1]=d,mp[tp2][2-tp2]=c; if(count(c)) return puts(&quot;LeeLdler win!&quot;); return puts(&quot;Cannot win!&quot;); &#125; &#125; &#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; 哈哈我过了！写模拟能直接a真的好快乐！！","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"ACM模板-稳赚个人版","slug":"ACM模板-稳赚个人版","date":"2020-01-01T12:36:36.000Z","updated":"2021-01-26T16:38:24.090Z","comments":true,"path":"2020/01/01/ACM模板-稳赚个人版/","link":"","permalink":"http://wzgshyvin.github.io/2020/01/01/ACM%E6%A8%A1%E6%9D%BF-%E7%A8%B3%E8%B5%9A%E4%B8%AA%E4%BA%BA%E7%89%88/","excerpt":"稳赚又丑又T的板子","text":"稳赚又丑又T的板子 头文件1234567891011121314151617#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scd(x) scanf(&quot;%lf&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=(s); i&lt;(e); ++i)#define dep(i,e,s) for(int i=(e); i&gt;=(s); --i)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;const double eps = 1e-10;const double PI = acos(-1.0); 字符串操作char函数1234567891011char s1[maxn], s2[maxn];char c; int n;strcat(s1,s2); // s1+=s2;strncat(s1,s2,n); // 加上s2的前n个字符strchr(s1,c); // 返回s1中第一次出现c的位置strnchr(s1,c); // 返回s1中最后一次出现c的位置strstr(s1,s2); // 返回s1中第一次出现s2的位置strcmp(s1,s2); // 比较 能比大小的strncmp(s1,s2,n); // 比前n个strcpy(s1,s2); // s1=s2;strncpy(s1,s2,n); // s1为s2前n个字符 string函数1234567891011121314string s1,s2;int pos,len; char c;s1.find(s2);// 返回值为s2第一次出现在s1的位置 // 若s2不是s1子串返回 string::nposs1.replace(pos,len,s2);// s1从pos位开始长度len的子串替换成s2s1.substr(pos,len);s1.insert(pos,s2);s1.insert(pos,s2,len);// 插入s2的前len个字符s1.insert(pos,len,c);// 插入len个cs1.erase(pos,len); 字典树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 数组版int trie[maxn][26];int cnt[maxn];void insert(char *s)&#123; int u=0; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!trie[u][tmp])&#123; trie[u][tmp]=++n; cnt[n]++; &#125; else cnt[trie[u][tmp]]++; u=trie[u][tmp]; &#125;&#125;int find(char *s)&#123; int u=0,len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!trie[u][tmp]) return 0; u=trie[u][tmp]; &#125; return cnt[u];&#125;// 指针版struct trie &#123; int cnt; trie *next[26]; trie()&#123; cnt=0; rep(i,0,26) next[i]=NULL; &#125;&#125;;trie *root,*p;void insert(char* s)&#123; p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if (p-&gt;next[tmp]==NULL) p-&gt;next[tmp]=new trie(); p=p-&gt;next[tmp]; p-&gt;cnt++; &#125;&#125;int find(char* s)&#123; p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if (p-&gt;next[tmp] == NULL) return 0; p=p-&gt;next[tmp]; &#125; return p-&gt;cnt;&#125; KMP12345678910111213141516171819202122232425262728293031323334353637int nex[maxn];void getnext(char* s)&#123; int i=0,j=-1,len=strlen(s); nex[0]=-1; while(i&lt;len)&#123; if(j==-1||s[i]==s[j])&#123; i++; j++; nex[i]=j; &#125; else j=nex[j]; &#125;&#125;int kmp(char *s1,char *s2)&#123; int i=0,j=0; getnext(s2); int len1=strlen(s1),len2=strlen(s2); while(i&lt;len1&amp;&amp;j&lt;len2)&#123; if(j==-1||s1[i]==s2[j])&#123; i++; j++; &#125; else j=nex[j]; if(j==len2) return i-j+1; &#125; return 0;&#125;/* 关于next数组应用如if(nex[pos]&amp;&amp;pos%(pos-nex[pos])==0)即有s的前pos位有(pos/(pos-nex[pos]))个长度为pos-nex[pos]的前缀*///求总前缀数 dprep(i,1,len+1)&#123; int tmp=nex[i]; while(tmp) sum++,tmp=nex[tmp];&#125;// 根据nex求s1和s2尾头衔接重叠部分s2+=&#x27;*&#x27;+s1; int q=getnext(s2); ans=s2.substr(0,q);// 套娃nex求前缀和后缀相同部分// on预处理求每个前缀在字符串中出现了几次void getnum(int len)&#123; rep(i,1,len+1) num[nex[i]]++; dep(i,len,1) num[nex[i]]+=num[i]; int t=len; while(t)&#123; vv.push_back(t),t=nex[t]; &#125; pf(&quot;%d\\n&quot;,vv.size()); sort(vv.begin(),vv.end()); for(int x:vv) pf(&quot;%d %d\\n&quot;,x,num[x]+1); // 长度和次数&#125; EXKMP12345678910111213141516171819202122232425262728293031int nex[maxn], extend[maxn];void getnext(char* s)&#123; int aa=0,len=strlen(s); nex[0]=len; while(aa&lt;len-1&amp;&amp;s[aa]==s[aa+1]) aa++; nex[1]=aa; aa=1; rep(i,2,len)&#123; int p=aa+nex[aa]-1; int l=nex[i-aa]; if(i+l-1&gt;=p)&#123; int j=(p-i+1)&gt;0?p-i+1:0; while(i+j&lt;len&amp;&amp;s[i+j]==s[j]) j++; nex[i]=j; aa=i; &#125; else nex[i]=l; &#125;&#125;void getextend(char* s1,char* s2)&#123; int aa=0; mst(nex,0); getnext(s2); int len1=strlen(s1),len2=strlen(s2); int minl=min(len1,len2); while(aa&lt;minl&amp;&amp;s1[aa]==s2[aa]) aa++; extend[0]=aa; aa=0; rep(i,1,len1)&#123; int p=aa+extend[aa]-1,l=nex[i-aa]; if(i+l-1&gt;=p)&#123; int j=(p-i+1)&gt;0?p-i+1:0; while(i+j&lt;len1&amp;&amp;j&lt;len2&amp;&amp;s1[i+j]==s2[j]) j++; extend[i]=j; aa=i; &#125; else extend[i]=l; &#125;&#125; 马拉车123456789101112int che[2*maxn];char s[maxn],ma[2*maxn];void manacher(char* s,int len0)&#123; int len=0; ma[len++]=&#x27;$&#x27;; ma[len++]=&#x27;#&#x27;; rep(i,0,len0) ma[len++]=s[i],ma[len++]=&#x27;#&#x27;; ma[len]=0; int maxx=0,num=0; rep(i,0,len)&#123; che[i]=maxx&gt;i?min(che[2*num-i],maxx-i):1; while(ma[i+che[i]]==ma[i-che[i]]) che[i]++; if(i+che[i]&gt;maxx) maxx=i+che[i],num=i; &#125;&#125; AC自动机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 计每个单词有无出现 注释里写记单词数的 以*开头int ans;struct node&#123; node* next[26]; // 最大100够的 所有题 node* fail; int end; // 在单词末尾做标记 //* int id; node()&#123; end=0; //* id=0; fail=0; mst(next,0); &#125;&#125;;node* root;// 建字典树//* int tot;void insert(char* s)&#123; node* p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; if(p-&gt;next[tmp]==NULL) p-&gt;next[tmp]=new node(); p=p-&gt;next[tmp]; &#125; p-&gt;end++; //* p-&gt;id=++tot;&#125;queue&lt;node*&gt;q;// fail数组：root指向NULL 没出现过的指向root 出现过的指向前一个void getfail()&#123; root-&gt;fail=NULL; q.push(root); while(!q.empty())&#123; node* fr=q.front(); q.pop(); rep(i,0,26) if(fr-&gt;next[i])&#123; node* tem=fr-&gt;fail; while(tem)&#123; if(tem-&gt;next[i])&#123; fr-&gt;next[i]-&gt;fail=tem-&gt;next[i]; break; &#125; tem=tem-&gt;fail; &#125; if(tem==NULL) fr-&gt;next[i]-&gt;fail=root; q.push(fr-&gt;next[i]); &#125; &#125;&#125;//* num[maxn], mark[maxn], cnt;void ac_auto(char* s)&#123; node* p=root; int len=strlen(s); rep(i,0,len)&#123; int tmp=s[i]-&#x27;a&#x27;; while(!p-&gt;next[tmp] &amp;&amp; p!=root) p=p-&gt;fail; p=p-&gt;next[tmp]; if(!p) p=root; node* tem=p; while(tem!=root)&#123; if(tem-&gt;end&gt;=0)&#123; ans+=tem-&gt;end; tem-&gt;end=-1; // 出现过了第二次遇到不再统计 &#125; else break; /* if(tem-&gt;id)&#123; *if(!mark[tem-&gt;id]) *num[cnt++]=tem-&gt;id; // num按在s串中出现顺序存id *mark[tem-&gt;id]++; //mark存出现与否 顺便存次数 &#125;*/ tem=tem-&gt;fail; &#125; &#125;&#125;// 虽然指针版怪弱智的 但舍不得了struct ACAM&#123; int ch[maxn][26]; int tot,num[maxn],nex[maxn]; void init()&#123; tot=1; rep(i,0,26) ch[0][i]=1; rep(i,0,26) ch[1][i]=0; &#125; void insert(char* s,int x)&#123; int n=strlen(s+1),p=1; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;; if(!ch[p][tmp])&#123; ch[p][tmp]=++tot; rep(j,0,26) ch[tot][j]=0; num[tot]=0; &#125; p=ch[p][tmp]; &#125; num[p]++; &#125; void getfail()&#123; queue&lt;int&gt;q; q.push(1); nex[1]=0; while(!q.empty())&#123; int fr=q.front(); q.pop(); rep(i,0,26) if(!ch[fr][i]) ch[fr][i]=ch[nex[fr]][i]; else nex[ch[fr][i]]=ch[nex[fr]][i],q.push(ch[fr][i]); &#125; &#125; void query(char* s)&#123; int n=strlen(s+1),p=1; cnt=0; rep(i,1,n+1)&#123; int tmp=s[i]-&#x27;a&#x27;,k=ch[p][tmp]; while(k&gt;1) ...,k=nex[k]; p=ch[p][tmp]; &#125; &#125;&#125;ac; 后缀数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int s[maxn];int sa[maxn],rk[maxn];int height[maxn];int t1[maxn],t2[maxn],c[maxn];int best[20][maxn];char ss[maxn];void getsa(int *s,int n,int m)&#123; int *x=t1,*y=t2; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[i]=s[i]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[i]]]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p=0; rep(i,n-k,n) y[p++]=i; rep(i,0,n) if(sa[i]&gt;=k) y[p++]=sa[i]-k; rep(i,0,m) c[i]=0; rep(i,0,n) c[x[y[i]]]++; rep(i,1,m) c[i]+=c[i-1]; dep(i,n-1,0) sa[--c[x[y[i]]]]=y[i]; swap(x,y); p=1; x[sa[0]]=0; rep(i,1,n) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++; if(p&gt;=n) break; m=p; &#125;&#125;void getheight(int n)&#123; int k=0; rep(i,1,n+1) rk[sa[i]]=i; rep(i,0,n)&#123; if(k) k--; int j=sa[rk[i]-1]; while(s[i+k]==s[j+k]) k++; height[rk[i]]=k; &#125;&#125;void RMQ(int n)&#123; int lg=(int)(log(n*1.0)/log(2.0)); rep(i,1,n+1) best[0][i]=height[i]; rep(i,1,lg+1) for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++) best[i][j]=min(best[i-1][j],best[i-1][j+(1&lt;&lt;i&gt;&gt;1)]); &#125;int lcp(int x,int y)&#123; x=rk[x]; y=rk[y]; if(x&gt;y) swap(x,y); x++; int lg=(int)(log(1.0*(y-x+1))/log(2.0)); return min(best[lg][x],best[lg][y-(1&lt;&lt;lg)+1]);&#125; 后缀自动机1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374struct SAM&#123; int next[maxn&lt;&lt;1][26],link[maxn&lt;&lt;1],len[maxn&lt;&lt;1]; int a[maxn&lt;&lt;1],id[maxn&lt;&lt;1],right[maxn&lt;&lt;1]; int tot,root,last; inline void init()&#123; rep(i,0,tot+1) mst(next[i],0),right[i]=0; mst(len,0); mst(link,0); tot=last=root=1; &#125; inline void extend(int x)&#123; int p=last,now=++tot; right[now]=1; len[now]=len[p]+1; while(p&amp;&amp;!next[p][x]) next[p][x]=now,p=link[p]; if(!p) link[now]=root; else&#123; int q=next[p][x]; if(len[q]==len[p]+1) link[now]=q; else&#123; int tmp=++tot; memcpy(next[tmp],next[q],sizeof(next[q])); link[tmp]=link[q]; link[q]=link[now]=tmp; len[tmp]=len[p]+1; while(p&amp;&amp;next[p][x]==q) next[p][x]=tmp,p=link[p]; &#125; &#125; last=now; &#125; inline void slove()&#123; // 拓扑排序 rep(i,1,tot+1) ++a[len[i]]; rep(i,1,tot+1) a[i]+=a[i-1]; rep(i,1,tot+1) id[a[len[i]]--]=i; // wz可能会记不得的sam简单运用： // ·s是否包含t：跑一遍t的点看next是不是都有值 // ·s不同子串个数：累加len[id[i]]-len[link[id[i]]] // ·s不同子串总长度：累加(len[id[i]]+1)*len[id[i]]/2-(len[link[id[i]]]+1)*len[link[id[i]]]/2 // ·s所有子串出现次数： int las=1; rep(i,0,n)&#123; num[next[las][s[i]-&#x27;a&#x27;]]=1; las=next[las][s[i]-&#x27;a&#x27;]; &#125; ll ans(0); dep(i,tot,1)&#123; num[link[id[i]]]+=num[id[i]]; ans+=1ll*(len[id[i]]-len[link[id[i]]])*num[id[i]]; &#125; // ·字典序第k大子串： //* op为0指计算本质不同子串 为1计算全部 if(!op) rep(i,1,tot+1) right[i]=1; else dep(i,tot,1)&#123; int t=id[i]; right[fa[t]]+=right[t]; &#125; right[1]=0; dep(i,tot,1)&#123; int t=id[i]; num[t]+=right[t]; rep(j,0,26) if(next[t][j]) num[t]+=num[next[t][j]]; &#125; if(k&gt;num[1]) return (void)pf(&quot;No such line.\\n&quot;); int now=1,cnt=0; while(k&gt;0)&#123; rep(i,0,26) if(next[now][i])&#123; if(k&lt;=num[next[now][i]])&#123; ans[cnt++]=&#x27;a&#x27;+i; now=next[now][i]; k-=right[now]; break; &#125; else k-=num[next[now][i]]; &#125; &#125; ans[cnt]=0; pf(&quot;%s\\n&quot;,ans); // ·t在s出现次数 // ·t在s出现位置 // ·多个字符串间的最长公共子串 &#125; inline void lcs()&#123; int las=1,mx(0),cnt(0); rep(i,0,m)&#123; if(!next[las][t[i]-&#x27;a&#x27;])&#123; while(las&amp;&amp;!next[las][t[i]-&#x27;a&#x27;]) las=link[las]; if(las) cnt=len[las]+1,las=next[las][t[i]-&#x27;a&#x27;]; else las=1,cnt=0; &#125; else ++cnt,las=next[las][t[i]-&#x27;a&#x27;]; mx=max(mx,cnt); &#125; pf(&quot;%d\\n&quot;,mx); &#125;&#125;sam; 最大最小表示法12345678910111213141516171819202122int getmin(char* s)&#123; int len=strlen(s); int i=0,j=1,k=0; while(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)&#123; int tmp=s[(i+k)%len]-s[(j+k)%len]; if(!tmp) k++; else&#123; if(tmp&gt;0) i+=k+1; else j+=k+1; if(i==j) j++; k=0; &#125; &#125; return min(i,j);&#125;int getmax(char* s)&#123; int len=strlen(s); int i=0,j=1,k=0; while(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)&#123; int tmp=s[(i+k)%len]-s[(j+k)%len]; if(!tmp) k++; else&#123; if(tmp&lt;0) i+=k+1; else j+=k+1; if(i==j) j++; k=0; &#125; &#125; return min(i,j);&#125; 回文树123456789101112131415161718192021222324252627282930313233343536373839// 回文树初始节点01 表示偶/奇数长度串的根节点struct PAM&#123; struct node&#123; int child[26],cnt,fail,num,len,pos; // len是从开头开始最长回文串长度 // num是以这个结点结束的回文串数 // cnt是节点表示的本质不同回文串数 &#125;tt[maxn]; int last,n,tot; char s[maxn]; inline void clear()&#123; rep(i,0,tot+1)&#123; mst(tt[i].child,0); tt[i].cnt=tt[i].fail=tt[i].len=tt[i].num=0; &#125; last=n=0; tt[0].fail=tot=1; tt[1].len=-1; &#125; inline int getfail(int x)&#123; while(s[n-tt[x].len-1]!=s[n]) x=tt[x].fail; return x; &#125; inline void add(char ch)&#123; s[++n]=ch; int cur=getfail(last); if(!tt[cur].child[ch-&#x27;a&#x27;])&#123; int now=++tot; tt[now].len=tt[cur].len+2; int p=getfail(tt[cur].fail); tt[now].fail=tt[p].child[ch-&#x27;a&#x27;]; tt[cur].child[ch-&#x27;a&#x27;]=now; tt[now].num=tt[tt[now].fail].num+1; &#125; last=tt[n].pos=tt[cur].child[ch-&#x27;a&#x27;]; ++tt[last].cnt; &#125; inline void count()&#123; dep(i,tot,0) tt[tt[i].fail].cnt+=tt[i].cnt; &#125;&#125;pam; hash123456789101112131415161718int seed[2]=&#123;27174403,19260817&#125;;// 18052103// 18271131 小燕学号 不是质数int mod; // 998244353 100000007 // 大质数 9999999999999937/17int hs[2][maxn],bas[2][maxn];void init()&#123; bas[0][0]=bas[1][0]=1; rep(j,0,2) rep(i,1,n+1)&#123; bas[j][i]=1ll*bas[j][i-1]*seed[j]%mod; hs[j][i]=1ll*hs[j][i-1]*seed[j]%mod+s[i]; if(hs[j][i]&gt;=mod) hs[j][i]-=mod; &#125; &#125;int getsum(int j,int l,int r)&#123; int res=hs[j][r]-1ll*hs[j][l-1]*bas[j][r-l+1]%mod; if(res&lt;0) res+=mod; return res;&#125; 自闭图论dijkstra1234567891011121314151617181920212223242526struct node&#123; int id,dt; bool operator &lt; (const node a) const&#123; return dt&gt;a.dt; &#125;&#125;;priority_queue&lt;node&gt;q;int n,m,s,t,tot;int dis[maxn],vis[maxn],head[maxn];int nex[maxn&lt;&lt;1],to[maxn&lt;&lt;1],val[maxn&lt;&lt;1];void addedge(int u,int v,int w)&#123; nex[++tot]=head[u]; head[u]=tot; to[tot]=v; val[tot]=w;&#125;void dij(int s)&#123; rep(i,1,n+1) dis[i]=1e9; dis[s]=0; q.push(&#123;s,0&#125;); while(!q.empty())&#123; int fr=q.top().id; q.pop(); if(vis[fr]) continue; vis[fr]++; for(int j=head[fr];j;j=nex[j]) if(dis[to[j]]&gt;val[j]+dis[fr]&amp;&amp;!vis[to[j]])&#123; dis[to[j]]=val[j]+dis[fr]; q.push(&#123;to[j],dis[to[j]]&#125;); &#125; &#125;&#125; 同余最短路12345678910// n个数有Σai*xi=b b∈[b0,b1]void slove()&#123; rep(i,0,a[0]-1) rep(j,0,n) addedge(i,(i+a[j])%a[0],a[j]); dij(0); rep(i,0,a[0]-1)&#123; int t=dis[i]; if(t&lt;b0) ans+=(b1-t)/a[0]-(b0-t-1)/a[0]; else if(t&lt;=b1) ans+=(b1-t)/a[0]+1; &#125;&#125; 稳定婚姻问题12345678910111213141516171819202122232425262728int b[maxn][maxn],g[maxn][maxn];// b 每个男生按好感位次排下来的女生// g 每个女生对应每个男生的好感度int bm[maxn],gm[maxn];// 对应异性号数int vis[maxn][maxn];void stable_marriage()&#123; mst(bm,-1); mst(gm,-1); mst(vis,0); queue&lt;int&gt; q; rep(i,1,n+1) q.push(i); int fr,nex; while(!q.empty())&#123; fr=q.front(); q.pop(); rep(i,1,m+1)&#123; nex=b[fr][i]; if(vis[fr][nex]) continue; vis[fr][nex]=1; if(gm[nex]==-1)&#123; gm[nex]=fr; bm[fr]=nex; break; &#125; else if(g[nex][gm[nex]]&gt;g[nex][fr])&#123; q.push(gm[nex]); gm[nex]=fr; bm[fr]=nex; break; &#125; &#125; &#125;&#125; 二分匹配匈牙利算法1234567891011121314151617int ans;int mp[maxn][maxn];int vis[maxn],line[maxn];void init()&#123; ans=0; mst(mp,0); mst(line,0);&#125;int dfs(int x)&#123; rep(i,1,n+1) if(!vis[i]&amp;&amp;mp[i][x])&#123; vis[i]=1; if(!line[i]||dfs(line[i])) &#123; line[i]=x; return 1; &#125; &#125; return 0;&#125;void slove()&#123; rep(i,1,n+1)&#123; mst(vis,0); if(dfs(i)) ans++; &#125;&#125; 强连通tarjan123456789101112131415161718192021222324252627282930313233int n,m,cnt,id;int dfn[maxn],low[maxn];int ins[maxn],scc[maxn];stack&lt;int&gt;s;vector&lt;int&gt;vv[maxn];void init()&#123; cnt=id=0; rep(i,0,n+1)&#123; vv[i].clear(); dfn[i]=low[i]=ins[i]=scc[i]=0; &#125;&#125;void tarjan(int x)&#123; dfn[x]=low[x]=++id; ins[x]=1; s.push(x); rep(i,0,vv[x].size())&#123; int tmp=vv[x][i]; if(!dfn[tmp])&#123; tarjan(tmp); low[x]=min(low[x],low[tmp]); &#125; else if(ins[tmp]) low[x]=min(low[x],dfn[tmp]); &#125; if(low[x]==dfn[x])&#123; int tmp; cnt++; do&#123; tmp=s.top(); s.pop(); ins[tmp]=0; scc[tmp]=cnt; &#125; while(x!=tmp); &#125;&#125;void slove()&#123; rep(i,1,n+1) if(!dfn[i]) tarjan(i); mst(ins,0); mst(out,0); rep(i,1,n+1) rep(j,0,vv[i].size()) if(scc[i]!=scc[vv[i][j]])&#123; ins[scc[vv[i][j]]]++; out[scc[i]]++; &#125;&#125; 双连通分量123456789101112131415161718192021222324252627282930313233343536// 割点：这个点一旦被删除，这张图的连通块数量会增加// 桥：这条边一旦被删除，这张图的连通块数量会增加// 带*边双int n,m,cnt,id,child;int dfn[maxn],low[maxn],isc[maxn];int num[maxn],ans,sum;vector&lt;int&gt;vv[maxn];//* vector&lt;pii&gt;bri;void init()&#123; cnt=id=child=0; rep(i,0,n+1)&#123; vv[i].clear(); dfn[i]=low[i]=isc[i]=0; &#125;&#125;void tarjan(int x,int f)&#123; dfn[x]=low[x]=++id; int ff(0); rep(i,0,vv[x].size())&#123; int tmp=vv[x][i]; if(tmp==f&amp;&amp;!ff)&#123; ff++; continue; &#125; // 重边 if(!dfn[tmp])&#123; child++; tarjan(tmp,x); low[x]=min(low[x],low[tmp]); if(low[tmp]&gt;dfn[x])&#123; isc[x]=1; // 判断这个点是否为割点 //* bri.push_back(pii(x,tmp)); &#125; &#125; else if(dfn[tmp]&lt;dfn[x]) low[x]=min(low[x],dfn[tmp]); &#125; if(f==-1&amp;&amp;child==1) isc[x]=0; // 关于根节点的特判 // 带缩点 if(dfn[x]==low[x])&#123; scc++; do...while...; &#125;&#125;void slove()&#123; rep(i,1,n+1) if(!dfn[i]) tarjan(i,-1);&#125; LCA123456789101112131415161718192021222324252627282930313233343536373839int n,m,tot,best[20][maxn&lt;&lt;1];int dis[maxn],vis[maxn],head[maxn];int nex[maxn&lt;&lt;1],to[maxn&lt;&lt;1],val[maxn&lt;&lt;1];int id[maxn&lt;&lt;1],num[maxn],dep[maxn&lt;&lt;1],cnt;void addedge(int u,int v,int w)&#123; nex[++tot]=head[u]; head[u]=tot; to[tot]=v; val[tot]=w;&#125;void dfs(int x,int f,int d)&#123; id[++cnt]=x; num[x]=cnt; dep[cnt]=d; for(int i=head[x];i;i=nex[i])&#123; int y=to[i],z=val[i]; if(y==f) continue; dis[y]=dis[x]+z; dfs(y,x,d+1); id[++cnt]=x; dep[cnt]=d; &#125;&#125;void ST(int n)&#123; int lg=(int)(log(n*1.0)/log(2.0)); rep(i,1,n+1) best[0][i]=i; rep(i,1,lg+1) for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++)&#123; int t1=best[i-1][j],t2=best[i-1][j+(1&lt;&lt;i&gt;&gt;1)]; best[i][j]=dep[t1]&lt;dep[t2]?t1:t2; &#125;&#125;int RMQ(int x,int y)&#123; if(x&gt;y) swap(x,y); int lg=(int)(log(1.0*(y-x+1))/log(2.0)); int t1=best[lg][x],t2=best[lg][y-(1&lt;&lt;lg)+1]; return dep[t1]&lt;dep[t2]?t1:t2;&#125;int LCA(int x,int y)&#123; int t1=num[x],t2=num[y]; return id[RMQ(t1,t2)];&#125;int getdis(int x,int y)&#123; return dis[x]+dis[y]-2*dis[LCA(x,y)];&#125;void slove()&#123; dfs(1,-1,1); ST(2*n-1);&#125; 数据结构并查集1234567int find(int x)&#123; return vis[x]==x?x:vis[x]=find(vis[x]);&#125;void change(int x, int y)&#123; int c=find(x),d=find(y); if(c!=d) vis[c]=d;&#125; 树状数组12345678910int tree[maxn];int lowbit(int i)&#123; return i&amp;(-i); &#125;void update(int i,int x)&#123; for(;i&lt;=maxn;i+=lowbit(i)) tree[i]+=x;&#125;int query(int n)&#123; int ans=0; for(int i=n;i&gt;0;i-=lowbit(i)) ans+=tree[i]; return ans;&#125; 线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 单点更新，加*区间更新#define lson (rt&lt;&lt;1)#define rson ((rt&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)int segtree[4*maxn];//* int lazy[4*maxn];void pushup(int rt)&#123; segtree[rt]=segtree[lson]+segtree[rson];&#125;/** void pushdown(int rt,int begin,int end)&#123; if (!lazy[rt]) return; segtree[lson]+=(mid-begin+1)*lazy[rt]; segtree[rson]+=(end-mid)*lazy[rt]; lazy[lson]+=lazy[rt]; lazy[rson]+=lazy[rt]; lazy[rt]=0;&#125;*/void build(int rt,int begin,int end)&#123; //* lazy[rt]=0; if(begin==end)&#123; sc(segtree[rt]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushup(rt);&#125;void update(int rt,int begin,int end,int pos,int a)&#123; if(pos&lt;begin||pos&gt;end) return; if(begin==end)&#123; segtree[rt]+=a; return; &#125; update(lson,begin,mid,pos,a); update(rson,mid+1,end,pos,a); pushup(rt);&#125;/** void update(int rt,int begin,int end,int left,int right,int a)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; segtree[rt]+=(end-begin+1)*a; lazy[rt]+=a; return; &#125; pushdown(rt,begin,end); update(lson,begin,mid,left,right,a); update(rson,mid+1,end,left,right,a); pushup(rt);&#125;*/int slove(int rt,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segtree[rt]; //* pushdown(rt,begin,end); int ans=0; ans+=slove(lson,begin,mid,left,right); ans+=slove(rson,mid+1,end,left,right); return ans;&#125; DP数位dp12345678910111213141516171819202122int a[20]; // 位数 一般题目最大1e18ll dp[20][state];ll dfs(int pos,int pre,/*int state,*/int limit)&#123; // pos位数 pre之前状态 与dp数组对应 // state各种情况包括前导零 具体看题目 limit前一位限制 if(pos==-1) return 1; // 计数，具体看题目 if(!limit&amp;&amp;dp[pos][pre]!=-1/*&amp;&amp;!state*/) return dp[pos][pre]; int last=limit?a[pos]:9; ll ans=0; rep(i,0,last+1)&#123; if(...) ans+=dfs(pos-1,...,/*...,*/limit&amp;&amp;i==a[pos]); else(...) &#125; if(!limit/*&amp;&amp;!state*/) dp[pos][pre]=ans; return ans;&#125;ll slove(ll x)&#123; mst(dp,-1); // 多组数据只用最开始mst一次 因为保证边界就可以了 int pos=0; while(x)&#123; a[pos++]=x%10; x/=10; &#125; return dfs(pos-1,0,/*...,*/1);&#125; 数学常见公式12// 1-n的平方和 n*(n+1)*(2*n+1)/6// 1-n的立方和 n*n*(n+1)*(n+1)/4 快速幂12345678910111213ll qpow(ll a,ll b)&#123; ll ans=1; for(;b&gt;0;b&gt;&gt;=1)&#123; if(b&amp;1) ans=ans*a%mod; a=a*a%mod; &#125; return ans;&#125;// 十进制ksm 大数幂次ll qpow(ll a,char* s)&#123; int len=strlen(s); ll res=1,q=1; dep(i,len-1,0)&#123; rep(j,1,s[i]-&#x27;0&#x27;+1) res=res*a%mod; a=a*a%mod; q=a*a%mod; q=q*q%mod; a=q*a%mod; &#125; return res;&#125; 快速乘123456789101112131415ll qmul(ll a,ll b,ll p)&#123; a%=p; ll ans(0); while(b&gt;0)&#123; if(b&amp;1) ans+=a; if(ans&gt;=p) ans-=p; b&gt;&gt;=1; a+=a; if(a&gt;=p) a-=p; &#125; return ans;&#125; // ologll modMul(ll a,ll b,ll p)&#123; if(p&lt;=1000000000) return a*b%p; else if(p&lt;=1000000000000ll) return (((a*(b&gt;&gt;20)%p)&lt;&lt;20)+(a*(b&amp;((1&lt;&lt;20)-1))))%p; else&#123; ll d=(ll)floor(a*(long double)b/p+0.5); ll ret=(a*b-d*p)%p; if (ret&lt;0) ret+=p; return ret; &#125;&#125; // o1 模逆元12345678910111213// exgcdvoid exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1; y=0; return; &#125; exgcd(b,a%b,y,x); y-=(a/b)*x; return;&#125;ll inv(ll a,ll p)&#123; ll x,y; exgcd(a,p,x,y); return (x%p+p)%p;&#125; // 好像比ksm快的// qpowinv=qpow(a,mod-2,mod);// 递推inv[i]=(mod-mod/i)*inv[mod%i]%mod; 组合数12345678910111213141516// 预处理写法int jc[maxn],inv[maxn];void init()&#123; jc[0]=inv[0]=1; rep(i,1,maxn) jc[i]=1ll*jc[i-1]*i%mod; inv[maxn-1]=qpow(jc[maxn-1],mod-2,mod); dep(i,maxn-2,1) inv[i]=1ll*inv[i+1]*(i+1)%mod;&#125;int C(int s,int x)&#123; return 1ll*jc[x]*inv[s]%mod*inv[x-s]%mod;&#125;// lucasll Lucas(ll n,ll m,ll p)&#123; ll ans=1; while(n|m) ans=ans*C(n%p,m%p)%p,n/=p,m/=p; return ans;&#125; 素数判断12345678910111213141516171819202122232425262728bool isPrime(ll n)&#123; if(n==2||n==3||n==5) return 1; if(n%2==0||n%3==0||n%5==0||n==1) return 0; ll c=7,a[8]=&#123;4,2,4,2,4,6,2,6&#125;; while(c*c&lt;=n) for(auto i:a)&#123; if(n%c==0) return 0; c+=i; &#125; return 1;&#125; // 抠// n极大时素数测试算法ll Rand()&#123; static ll x=(srand((int)time(0)),rand()); x+=1000003; if(x&gt;mod) x-=mod; return x;&#125;bool Witness(ll a,ll n)&#123; ll t=0,u=n-1; while(!(u&amp;1)) u&gt;&gt;=1,t++; ll x=fpow(a,u,n),y; while(t--)&#123; y=x*x%n; if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1) return true; x=y; &#125; return x!=1;&#125;bool MillerRabin(ll n,ll s)&#123; if(n==2||n==3||n==5) return 1; if(n%2==0||n%3==0||n%5==0||n==1) return 0; while(s--) if(Witness(Rand()%(n-1)+1,n)) return false; return true;&#125; 求最小素因数123456789int p[maxn/3],mpf[maxn],pn;void init()&#123; int tmp; rep(i,2,maxn)&#123; if(!mpf[i]) p[pn++]=i,mpf[i]=i; for(int j=0;(tmp=i*p[j])&lt;maxn;j++)&#123; mpf[tmp]=p[j]; if(!(i%p[j])) break; &#125; &#125;&#125; Pollard’s rho123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 对于比较大的数分解因数typedef pair&lt;ll,int&gt; pli;namespace pollard_rho&#123; const int C=2307; const int S=10; mt19937 rd(time(0)); vector&lt;ll&gt;ve; ll gcd(ll a,ll b)&#123; while((a%=b)&amp;&amp;(b%=a)); return a+b; &#125; ll mul(ll a,ll b,ll mod)&#123; return (__int128)a*b%mod; &#125; ll qpow(ll a,ll b,ll mod)&#123; ll res=1; a%=mod; while(b&gt;0)&#123; if(b&amp;1) res=mul(res,a,mod); b&gt;&gt;=1; a=mul(a,a,mod); &#125; return res; &#125; bool check(ll a,ll n)&#123; ll m=n-1,x,y; int j=0; while(!(m&amp;1))m&gt;&gt;=1,j++; x=qpow(a,m,n); for(int i=1;i&lt;=j;x=y,i++)&#123; y=mul(x,x,n); if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1) return 1; &#125; return y!=1; &#125; bool miller_rabin(ll n)&#123; ll a; if(n==1) return 0; if(n==2) return 1; if(!(n&amp;1)) return 0; for(int i=0;i&lt;S;i++) if(check(rd()%(n-1)+1,n)) return 0; return 1; &#125; ll pollard_rho(ll n,int c)&#123; ll i=1,k=2,x=rd()%n,y=x,d; while(1)&#123; i++; x=(mul(x,x,n)+c)%n,d=gcd(y-x,n); if(d&gt;1&amp;&amp;d&lt;n) return d; if(y==x) return n; if(i==k) y=x,k&lt;&lt;=1; &#125; &#125; void findfac(ll n,int c)&#123; if(n==1) return; if(miller_rabin(n))&#123; ve.push_back(n); return; &#125; ll m=n; while(m==n) m=pollard_rho(n,c--); findfac(m,c); findfac(n/m,c); &#125; vector&lt;pli&gt; solve(ll n)&#123; vector&lt;pli&gt;res; ve.clear(); findfac(n,C); sort(ve.begin(),ve.end()); for(auto x:ve)&#123; if(res.empty()||res.back().first!=x) res.push_back(&#123;x,1&#125;); else res.back().second++; &#125; return res; &#125;&#125; 中国剩余定理123456789101112131415161718192021ll a[maxn],r[maxn];ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1; y=0; return a; &#125; else&#123; ll ans=exgcd(b,a%b,y,x); y-=(a/b)*x; return ans; &#125;&#125;int excrt()&#123; ll m1,r1,m2,r2; ll x,y,t,c,d; m1=a[0],r1=r[0]; rep(i,1,tot)&#123; m2=a[i],r2=r[i]; c=r2-r1; d=exgcd(m1,m2,x,y); if(c%d) return puts(&quot;-1&quot;); t=m2/d; x*=c/d; x=(x%t+t)%t; r1=x*m1+r1; m1=m1*m2/d; r1=(r1%m1+m1)%m1; &#125; return pf(&quot;%d\\n&quot;,r1);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 大数版import java.math.*;import java.util.*;public class Main &#123; public static BigInteger[] exgcd(BigInteger a,BigInteger b)&#123; BigInteger ans; BigInteger[] result=new BigInteger[3]; if(b.compareTo(BigInteger.ZERO)==0)&#123; result[0]=a; result[1]=BigInteger.ONE; result[2]=BigInteger.ZERO; return result; &#125; BigInteger[] tmp=exgcd(b,a.mod(b)); ans=tmp[0]; result[0]=ans; result[1]=tmp[2]; result[2]=tmp[1].subtract((a.divide(b).multiply(tmp[2]))); return result; &#125; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); BigInteger a[]=new BigInteger[105]; BigInteger r[]=new BigInteger[105]; int n; n=sc.nextInt(); for(int i=0;i&lt;n;i++)&#123; a[i]=sc.nextBigInteger(); r[i]=sc.nextBigInteger(); &#125; BigInteger m1,m2,r1,r2,t,c; BigInteger[] d; m1=a[0]; r1=r[0]; for(int i=1;i&lt;n;i++)&#123; m2=a[i]; r2=r[i]; c=r2.subtract(r1); d=exgcd(m1,m2); if(c.mod(d[0]).compareTo(BigInteger.ZERO)!=0)&#123; System.out.println(&quot;-1&quot;); return; &#125; t=m2.divide(d[0]); d[1]=d[1].multiply(c.divide(d[0])).mod(t); r1=d[1].multiply(m1).add(r1); m1=m1.multiply(t); r1=r1.mod(m1); &#125; d=exgcd(BigInteger.ONE,m1); if(r1.mod(d[0]).compareTo(BigInteger.ZERO)!=0)&#123; System.out.println(&quot;-1&quot;); return; &#125; t=m1.divide(d[0]); d[1]=d[1].multiply(r1.divide(d[0])).mod(t); System.out.println(d[1]); &#125;&#125; (ex)bsgs1234567891011121314// 求解a^x=b(mod p)ll bsgs(ll a,ll b,ll p)&#123; unordered_map&lt;ll,ll&gt;tab; tab.clear(); ll u=(ll)ceil(sqrt(p)),ans; rep(i,0,u+1)&#123; if(!i) ans=b%p,tab[ans]=i; else ans=ans*a%p,tab[ans]=i; &#125; ll sum=qpow(a,u,p); ans=1; if(!sum) return b?-1:1; rep(i,1,u+1)&#123; ans=ans*sum%p; if(tab[ans]) return u*i-tab[ans]; &#125; return -1;&#125; 打表素数及莫比乌斯函数 1234567891011int p[maxn],u[maxn],vis[maxn],pn;void init()&#123; u[1]=1; rep(i,2,maxn)&#123; if(!vis[i]) p[pn++]=i,u[i]=-1; for(int j=0;j&lt;pn&amp;&amp;i*p[j]&lt;maxn;j++)&#123; vis[i*p[j]]=1; if(i%p[j]) u[i*p[j]]=-u[i]; else &#123; u[i*p[j]]=0; break; &#125; &#125; &#125;&#125; 反素数123456789101112int n,p[]=&#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53&#125;;ll ans=1e18; // n个因数void dfs(int pos,ll v,int num)&#123; if(num&gt;n||pos&gt;15) return; if(num==n) return ans=min(ans,v),(void)0; for(int i=1;i&lt;64;i++)&#123; if(v&gt;ans/p[pos]||num*(i+1)&gt;n) break; v*=p[pos]; if(!(n%(num*(i+1)))) dfs(pos+1,v,num*(i+1)); &#125;&#125;void slove()&#123; dfs(0,1,1); &#125;// ans是因数有n个的最小正整数 欧拉函数12345678910ll getphi(ll x)&#123; ll res=x; rep(i,2,x+1)&#123; if(1ll*i*i&gt;x) break; if(x%i==0)&#123; res=res/i*(i-1); while(x%i==0) x/=i; &#125; &#125; if(x&gt;1) res=res/x*(x-1); return res;&#125; 欧拉降幂1234// 求qpow(a,b,p)有if(__gcd(a,p)==1) ans=qpow(a,b%phi(p),p);else if(__gcd(a,p)&gt;1&amp;&amp;b&lt;phi(p)) ans==qpow(a,b,p);else ans=qpow(a,b%phi(p)+phi(p),p); BM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657namespace linear_seq&#123; const int N=101100; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt;Md; void mul(ll *a,ll *b,int k)&#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if(_c[i]) rep(j,0,Md.size()) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int slove(ll n,vector&lt;int&gt; a,vector&lt;int&gt; b)&#123; // a系数 b初值 b[n+1]=a[0]*b[n]+... ll ans=0,pnt=0; int k=a.size(); assert((int)a.size()==(int)b.size()); Md.clear(); rep(i,0,k) _md[k-1-i]=-a[i]; _md[k]=1; rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while((1ll&lt;&lt;pnt)&lt;=n) pnt++; dep(p,pnt,0)&#123; mul(res,res,k); if((n&gt;&gt;p)&amp;1)&#123; dep(i,k-1,0) res[i+1]=res[i];res[0]=0; rep(j,0,Md.size()) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if(ans&lt;0) ans+=mod; return ans; &#125; vector&lt;int&gt; BM(vector&lt;int&gt; s)&#123; vector&lt;int&gt; C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,s.size())&#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if(d==0) ++m; else if(2*L&lt;=n)&#123; vector&lt;int&gt; T=C; ll c=mod-d*qpow(b,mod-2)%mod; while((int)C.size()&lt;(int)B.size()+m) C.push_back(0); rep(i,0,B.size()) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else&#123; ll c=mod-d*qpow(b,mod-2)%mod; while((int)C.size()&lt;(int)B.size()+m) C.push_back(0); rep(i,0,B.size()) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int qaq(vector&lt;int&gt; a,ll n)&#123; vector&lt;int&gt; c=BM(a); c.erase(c.begin()); rep(i,0,c.size()) c[i]=(mod-c[i])%mod; return slove(n,c,vector&lt;int&gt;(a.begin(),a.begin()+(int)c.size())); &#125;&#125;;int slove()&#123; vector&lt;int&gt;vv; ll tmp(0); rep(i,1,maxn)&#123; tmp=...; vv.push_back(tmp); &#125; ll ans=linear_seq::qaq(vv,n-1); return printf(&quot;%lld\\n&quot;,ans);&#125; 二次剩余12345678910111213141516171819202122bool judge(ll a,ll p)&#123; // 判断a是否为p的二次剩余 p是素数 return qpow(a,(p-1)&gt;&gt;1,p)==1;&#125;ll Shanks(ll a,ll p)&#123; // 求解二次同余方程x^2=a(mod p) p是素数 if(a==0) return 0; ll q=p-1,e=0; while(!(q&amp;1)) q&gt;&gt;=1,e++; static mt19937_64 rd(time(0)); ll n=rd()%(p-1)+1; // 随机选取p的一个非二次剩余，若p为定值，n也可为定值 while(judge(n,p)) n=rd()%(p-1)+1; ll z=qpow(n,q,p),y=z,r=e,x=qpow(a,(q-1)&gt;&gt;1,p),b=a*x%p*x%p; x=a*x%p; while(b!=1)&#123; ll temp=b*b%p,m=1; while(temp!=1) (temp*=temp)%=p,m++; if(m==r) return -1; ll t=y; rep(i,1,r-m-1)(t*=t)%=p; y=t*t%p,r=m%p,x=x*t%p,b=b*y%p; &#125; return x;&#125; fft123456789101112131415161718192021222324252627282930313233typedef complex&lt;double&gt; cd;const double PI = acos(-1.0);void change(cd* f,int n)&#123; int j=n&gt;&gt;1; rep(i,1,n-1)&#123; if(i&lt;j) swap(f[i],f[j]); int k=n&gt;&gt;1; while(j&gt;=k)&#123; j-=k; k&gt;&gt;=1; &#125; if(j&lt;k) j+=k; &#125;&#125;void fft(cd* f,int n,int dft)&#123; // n为多项式位数 change(f,n); for(int step=1;step&lt;n;step&lt;&lt;=1)&#123; // 合并 cd wn=exp(cd(0,dft*PI/step)); for(int j=0;j&lt;n;j+=step&lt;&lt;1)&#123; cd wnk(1,0); for(int k=j;k&lt;j+step;k++)&#123; cd x=f[k],y=wnk*f[k+step]; f[k]=x+y; // F(x)=G(x)+ωH(x) f[k+step]=x-y; wnk*=wn; &#125; &#125; &#125; if(dft==-1) rep(i,0,n) f[i]/=n; // IDFT需要整个矩阵的内容乘上1/n &#125;cd a[maxn],b[maxn]; int ans[maxn];void slove()&#123; int mx=...,L=1; while(L&lt;mx*2) L&lt;&lt;=1; mst(ans,0); fft(a,L,1); fft(b,L,1); rep(i,0,L) a[i]=a[i]*b[i]; fft(a,L,-1); rep(i,0,L) ans[i]=(int)(a[i].real()+0.5);&#125; fwt123456789101112131415161718192021222324void fwt_or(int *a,int op)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;++k) if(op==1) a[i+j+k]=(a[j+k]+a[i+j+k])%mod; else a[i+j+k]=(a[i+j+K]-a[j+K]+mod)%mod;&#125; void fwt_and(int *a,int op)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;++k) if(op==1) a[j+k]=(a[j+k]+a[i+j+k])%mod; else a[j+k]=(a[j+K]-a[i+j+K]+mod)%mod;&#125; void fwt_xor(int *a,int op)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;++k)&#123; int x=a[j+k],y=a[i+j+k]; a[j+k]=(x+y)%mod,a[i+j+k]=(x-y+mod)%mod; if(op==-1) a[j+k]=1ll*a[j+k]*inv2%mod, a[i+j+k]=1ll*a[i+j+k]*inv2%mod; &#125;&#125; 拉格朗日插值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465namespace polysum&#123; const int D = 1e5 + 5; ll a[D],f[D],g[D],p1[D],p2[D],b[D],h[D][2],C[D]; ll qpow(ll a,ll b)&#123; ll ans=1; for(;b;b&gt;&gt;=1)&#123; if(b&amp;1) ans=ans*a%mod; a=a*a%mod; &#125; return ans; &#125; void init(int M)&#123; f[0]=f[1]=g[0]=g[1]=1; rep(i,2,M+5) f[i]=f[i-1]*i%mod; g[M+4]=qpow(f[M+4],mod-2); dep(i,M+3,2) g[i]=g[i+1]*(i+1)%mod; &#125; // 已知f(0),f(1)..f(d) 求 f(n) ll calcn(ll d,ll *a,ll n)&#123; // a[0].. a[d] a[n] if(n&lt;=d) return a[n]; p1[0]=p2[0]=1; rep(i,0,d+1)&#123; ll t=(n-i+mod)%mod; p1[i+1]=p1[i]*t%mod; &#125; rep(i,0,d+1)&#123; ll t=(n-d+i+mod)%mod; p2[i+1]=p2[i]*t%mod; &#125; ll ans(0); rep(i,0,d+1)&#123; ll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod; if((d-i)&amp;1) ans=(ans-t+mod)%mod; else ans=(ans+t)%mod; &#125; return ans; &#125; // 已知 f(0),f(1)...f(m),求\\sum_&#123;i=0 &#125;^&#123;n&#125; f[i] ll polysum(ll m,ll *a,ll n)&#123; // a[0].. a[m] ll b[D]; rep(i,0,m+1) b[i]=a[i]; b[m+1]=calcn(m,b,m+1); rep(i,1,m+2) b[i]=(b[i-1]+b[i])%mod; return calcn(m+1,b,n-1); &#125; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i ll qpolysum(ll R,ll n,ll *a,ll m) &#123; if(R==1) return polysum(n,a,m); a[m+1]=calcn(m,a,m+1); ll r=qpow(R,mod-2),p3=0,p4=0,c,ans; h[0][0]=0; h[0][1]=1; rep(i,1,m+2)&#123; h[i][0]=(h[i-1][0]+a[i-1])*r%mod; h[i][1]=h[i-1][1]*r%mod; &#125; rep(i,0,m+2)&#123; ll t=g[i]*g[m+1-i]%mod; if(i&amp;1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod; else p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod; &#125; c=qpow(p4,mod-2)*(mod-p3)%mod; rep(i,0,m+2) h[i][0]=(h[i][0]+h[i][1]*c)%mod; rep(i,0,m+2) C[i]=h[i][0]; ans=(calcn(m,C,n)*qpow(R,n)%mod-c)%mod; if(ans&lt;0) ans+=mod; return ans; &#125;&#125; 博弈1234567891011121314151617181920212223242526272829/* 巴什博弈：一堆物品n两人轮流取物，一次最多m根据n%(m+1)是否为零判断胜者 *//* 威佐夫博奕：两堆物品a、b两人轮流取物，一次只能在一堆任意取或是两堆取同样多 //默认a&lt;b根据(int)((double)(1.0+sqrt(4.0))/2.0)*(b-a))是否等于a判断胜者扩展威佐夫博弈：两堆物品a、b两人轮流取物，一次只能在一堆任意取或是两堆取相差不超过k的 //默认a&lt;b */if(a&gt;b) swap(a,b);if(a==1) return puts(b==k+2?&quot;0&quot;:&quot;1&quot;);if(a==k+2||b==k+2) return puts(&quot;1&quot;);ll r=(b-a)%(k+1); if(r) return puts(&quot;1&quot;);double t=(1.0-k+sqrt(1ll*(k+1)*(k+1)+4.0))/2.0;ll q=(b-a)/(k+1); q=(ll)q*t;return puts(q==a?&quot;0&quot;:&quot;1&quot;);/* Fibonacci博弈：一堆物品n，两人轮流取物，每一次能取的个数是上一次的两倍以内，最后取完胜n为Fibonacci数时先手败 */// k倍动态减法// 一堆石头 第一步可以拿1~n-1个石头 之后每步最多拿上一步的k倍int a[maxn],b[maxn];int slove()&#123; int n,k; sc(n); sc(k); a[0]=b[0]=1; int i=0,j=0; while(n&gt;a[i])&#123; i++; a[i]=b[i-1]+1; while(a[j+1]*k&lt;a[i]) j++; if(a[j]*k&lt;a[i]) b[i]=b[j]+a[i]; else b[i]=a[i]; &#125; if(a[i]==n) return puts(&quot;lose&quot;); // 先手败 int ans; while(n)&#123; if(n&gt;=a[i]) n-=a[i],ans=a[i]; i--; &#125; return pf(&quot;%d\\n&quot;,ans); // 第一步所拿最少数&#125; 斐波那契求循环节1234567/*给定一个数n 求%n的斐波那契循坏节长度len·n为质数且5是模n的二次剩余 len为(n-1)的因子·n为质数且5不为模n的二次剩余 len为(2n+2)的因子·n为质数p的k次 len为lenp*p^(k-1)·n分解为质因数 len为每个质因数循环节长度的lcm*/ 计算几何二维几何123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// 一般形式// 直线L上两点(x1,y1),(x2,y2);// 直线外一点P(x0,y0);// L表示为Ax+By+C=0;double A,B,C;A=y2-y1; B=x1-x2; C=x2*y1-x1*y2;// 点到直线距离ddouble d=fabs(A*x0+B*y0+C)/sqrt(A*A+B*B);// 点到直线垂足H(x, y)double x,y;x=(B*B*x0-A*B*y0-A*C)/(A*A+B*B);y=(-A*B*x0+A*A*y0-B*C)/(A*A+B*B);// 点关于直线的对称点P&#x27;(_x, _y);double k,_x,_y;k=-2*(A*x0+B*y0+C)/(A*A+B*B); _x=x0+k*A; _y=y0+k*B;// 求三角形内整数点个数// 三角形三个顶点坐标(x1, y1), (x2, y2), (x3, y3) 都为整数点int t1,t2,t3; // 三边上整数点个数t1=gcd(abs(x1-x2),abs(y1-y2));t2=gcd(abs(x3-x2),abs(y3-y2));t3=gcd(abs(x1-x3),abs(y1-y3));int num; // 三角形内整数点num=abs((x2-x1)*(y3-y2)-(x3-x2)*(y2-y1))/2;num-=(t1+t2+t3)/2-1; // 皮克定理// 一个格点多边形有 S=a+b/2-1;// S面积 a内部格点数 b边上格点数// 结构体形式struct point&#123; double x,y; point(double _x=0,double _y=0)&#123; x=_x,y=_y; &#125; point operator+ (const point&amp; a) const&#123; return point(x+a.x,y+a.y); &#125; point operator- (const point&amp; a) const&#123; return point(x-a.x,y-a.y); &#125; point operator* (double a) const&#123; return point(x*a,y*a); &#125;&#125;; // 点struct line&#123; point s,e; line(point a,point b)&#123; s=a,e=b; &#125; line()&#123;&#125;&#125;; // 线int dcmp(double x)&#123; if(x&gt;eps) return 1; return x&lt;-eps?-1:0;&#125;double getdis(point a, point b)&#123; double xx=a.x-b.x,yy=a.y-b.y; return sqrt(xx*xx+yy*yy);&#125; // 两点距离double multi(point a,point b,point c)&#123; double xa,ya,xb,yb; xa=b.x-a.x; ya=b.y-a.y; xb=c.x-b.x; yb=c.y-b.y; return xa*xb+ya*yb;&#125; // 点乘double cross(point a,point b,point c)&#123; double xa,ya,xb,yb; xa=b.x-a.x; ya=b.y-a.y; xb=c.x-a.x; yb=c.y-a.y; return xa*yb-xb*ya;&#125; // 叉乘int judgec(line a,line b)&#123; if (max(a.s.x,a.e.x)&gt;=min(b.s.x,b.e.x) &amp;&amp; max(a.s.y,a.e.y)&gt;=min(b.s.y,b.e.y) &amp;&amp; max(b.s.x,b.e.x)&gt;=min(a.s.x,a.e.x) &amp;&amp; max(b.s.y,b.e.y)&gt;=min(a.s.y,a.e.y) &amp;&amp; cross(a.s,b.s,b.e)*cross(a.e,b.s,b.e)&lt;=0 &amp;&amp; cross(b.s,a.s,a.e)*cross(b.e,a.s,a.e)&lt;=0 ) return 1; else return 0;&#125; // 判断线段是否相交point getpoi(point a,point b,point c,point d)&#123; double u=cross(a,b,c),v=cross(b,a,d); return point((c.x*v+d.x*u)/(u+v),(c.y*v+d.y*u)/(u+v));&#125; // 求交点double parea(point p[],int n)&#123; if(n&lt;3) return 0; double ans=0; p[n]=p[0]; rep(i,0,n) ans+=p[i].x*p[i+1].y-p[i+1].x*p[i].y; return ans/2;&#125; // 多边形面积// 求两个多边形面积交/并double CPIA(point a[],point b[],int n1,int n2)&#123; if(n2&lt;3) return 0; point p[15],t[15]; a[n1]=a[0]; b[n2]=b[0]; memcpy(p,b,sizeof(point)*(n2+1)); rep(i,0,n1)&#123; int f1=dcmp(cross(a[i],a[i+1],p[0])),tn=0; rep(j,0,n2)&#123; if(f1&gt;=0) t[tn++]=p[j]; int f2=dcmp(cross(a[i],a[i+1],p[j+1])); if((f1^f2)==-2) t[tn++]=getpoi(a[i],a[i+1],p[j],p[j+1]); f1=f2; &#125; memcpy(p,t,sizeof(point)*tn); n2=tn; p[n2]=p[0]; &#125; return parea(p,n2);&#125;double SPIA(point a[],point b[],int n1,int n2)&#123; point t1[5],t2[5]; a[n1]=t1[0]=a[0]; b[n2]=t2[0]=b[0]; double res=0; rep(i,2,n1)&#123; t1[1]=a[i-1]; t1[2]=a[i]; int f1=dcmp(cross(t1[0],t1[1],t1[2])); if(f1&lt;0) swap(t1[1],t1[2]); rep(j,2,n2)&#123; t2[1]=b[j-1]; t2[2]=b[j]; int f2=dcmp(cross(t2[0],t2[1],t2[2])); if(f2&lt;0) swap(t2[1],t2[2]); res+=CPIA(t1,t2,3,3)*f1*f2; &#125; &#125; return fabs(res); //面积交 //return fabs(parea(a,n1)+parea(b,n2)-res); //面积并 &#125;double gx, gy;void find_gra()&#123; double area=0,tmp; rep(i,1,n-1)&#123; tmp=(p[i].x-p[0].x)*(p[i+1].y-p[0].y)-(p[i+1].x-p[0].x)*(p[i].y-p[0].y); area+=tmp; gx+=(p[0].x+p[i].x+p[i+1].x)*tmp; gy+=(p[0].y+p[i].y+p[i+1].y)*tmp; &#125; gx=gx/3/area, gy=gy/3/area;&#125; // 求重心坐标 二维凸包12345678910111213141516171819// 以下凸包Grahamint top;point p[maxn],s[maxn];int iszero(double x)&#123; return fabs(x)&lt;eps; &#125;int cmp(point a,point b)&#123; double tt=multi(a,b,p[0]); if(tt&gt;0||iszero(tt)&amp;&amp;getdis(a,p[0])&lt;getdis(b,p[0])) return 1; return 0;&#125;void graham() &#123; point tmp; rep(i,1,n) if(p[i].y&lt;p[0].y||(p[i].y==p[0].y&amp;&amp;p[i].x&lt;p[0].x)) swap(p[0],p[i]); sort(p+1,p+n,cmp); s[0]=p[0]; s[1]=p[1]; s[2]=p[2]; top=2; rep(i,3,n)&#123; while(top&gt;=2&amp;&amp;multi(s[top-1],s[top],p[i])&lt;=eps) top--; s[++top]=p[i]; &#125;&#125; Java快读123456789101112131415161718192021222324252627282930import java.io.*;public class Main &#123; public static void main(String[] args) throws IOException &#123; // 这句是io流包装，记住就好 StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); /*in.resetSyntax(); in.whitespaceChars(0, 32); in.wordChars(&#x27;0&#x27;, &#x27;9&#x27;); in.wordChars(&#x27;-&#x27;, &#x27;.&#x27;); in.wordChars(&#x27;+&#x27;, &#x27;+&#x27;); in.wordChars(&#x27;a&#x27;, &#x27;z&#x27;); in.wordChars(&#x27;A&#x27;, &#x27;Z&#x27;); in.wordChars(0xa0, 0xff); in.slashSlashComments(true); in.slashStarComments(true); in.quoteChar(&#x27;&quot;&#x27;); in.quoteChar(&#x27;\\&#x27;&#x27;);*/ // 以上加上可以将数字当字符串读 // StreamTokenizer.TT_EOF这个是个参数，就是EOF while (in.nextToken() != StreamTokenizer.TT_EOF) &#123; String n = in.sval; in.nextToken(); // 没记错是换行 double m = in.nval; int a = (int) in.nval; out.println(m); out.flush(); // 刷新，不然max会留在缓冲区 &#125; &#125;&#125; 高精度123456789101112131415161718import java.math.*;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); // 普通读入 while(sc.hasNext())&#123; // 大数常见函数 BigInteger.valueOf(); // int转大数 BigInteger a = new BigInteger(/*val:*/&quot;&quot;); BigInteger b = new BigInteger(/*String*/); BigInteger array[]=new BigInteger[maxn]; add(); subtract(); multiply(); divide(); compareTo(); mod(); pow(); gcd(); // 理论上大部分有补全的 System.out.println(a.stripTrailingZeros().toPlainString()); // 实数的输出去除末尾0 Arrays.sort(a,0,n); // 数组排序 &#125; &#125;&#125; 其他各种函数12345is_sorted(a+l,a+r); // 判断数组a在区间是否有序__builtin_popcount(x); // 计算二进制x有几个1__builtin_popcountll(x); // ll模式 末尾加个llprev_permutation(iterator strat,iterator end);next_permutation(iterator strat,iterator end); pbds1234567891011121314151617181920212223// 平衡树#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/tree_policy.hpp&gt;using namespace __gnu_pbds;tree&lt;/*int*/,null_type,greater&lt;/*int*/&gt;,rb_tree_tag,tree_order_statistics_node_update&gt; T;// 第一个参数是数据类型// 第二个要填null_type，低版本编译器填null_mapped_type// 第三个填比较函数 std::greater&lt;&gt; or std::less&lt;&gt; or cmp// 第四个填树的类型，有rb_tree_tag红黑树和splay_tree_tag// 第五个是为了支持查询第k大和排名的一个参数T.insert(x); T.erase(x); T.lower_bound(x);int rk=(int)T.order_of_key(x)+1; // 查询一个数的排名int num=(int)*T.find_by_order(x-1)); //查询第k大的数 返回迭代器// rope#include&lt;ext/rope&gt;using namespace __gnu_cxx;rope&lt;/*int*/&gt;r;r.push_back(x); // 在末尾添加xr.insert(pos,x); // 在pos插入x，自然支持整个char数组的一次插入r.erase(pos,x); // 从pos开始删除x个r.copy(pos,len,x); // 从pos开始到pos+len为止用x代替r.replace(pos,x); // 从pos开始换成xr.substr(pos,x); // 提取pos开始x个 指令集优化123#pragma GCC optimize(3)#pragma GCC optimize(&quot;Ofast,no-stack-protector&quot;)#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native&quot;) 关同步1ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 快读123456inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch)) w|=ch==&#x27;-&#x27;,ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-&#x27;0&#x27;,ch=getchar(); return w?-x:x;&#125; __int128输入输出1234567891011void scan(__int128 &amp;x)&#123; x=0; int op=1; char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;) op=(c==&#x27;-&#x27;?-1:1),c=getchar(); while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#x27;0&#x27;,c=getchar(); x*=op;&#125;void print(__int128 x)&#123; if(x&lt;0)&#123; x=-x; putchar(&#x27;-&#x27;); &#125; if(x&gt;9) print(x/10); putchar(x%10+&#x27;0&#x27;);&#125; 随机12mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count());int rnd(int x)&#123; return mrand()%x; &#125; 给逆元求概率123456789101112void slove(ll pa,ll xa,ll pb,ll xb,ll &amp;a,ll &amp;b)&#123; ll tmp=(pa-1)/xa; if(tmp+1&lt;=pb/xb)&#123; a=tmp+1; b=1; return; &#125; pa-=tmp*xa; pb-=tmp*xb; slove(xb,pb,xa,pa,b,a); a+=tmp*b; &#125;void getsample()&#123; ll p,x,a,b; scl(p); scl(x); // p模的质数 x结果 slove(p,x,p,x-1,a,b); ll c=x*a-p*b; pf(&quot;%lld/%lld\\n&quot;,c,a);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"板子","slug":"板子","permalink":"http://wzgshyvin.github.io/tags/%E6%9D%BF%E5%AD%90/"}]},{"title":"2019流水账总结","slug":"2019流水账总结","date":"2019-12-31T12:08:01.000Z","updated":"2021-02-22T16:14:41.582Z","comments":true,"path":"2019/12/31/2019流水账总结/","link":"","permalink":"http://wzgshyvin.github.io/2019/12/31/2019%E6%B5%81%E6%B0%B4%E8%B4%A6%E6%80%BB%E7%BB%93/","excerpt":"没干什么的 2019","text":"没干什么的 2019 2019 对我来说 是很没有概念的一年日常生活都是训练画稿摸鱼 每天都很一样一月开始寒假的专题训练二月画了 hgame 的稿三月进了正式队四月做了 vidar 兔初设五月染了个头 保持每日写题打卡 挺拼的经常趴在电脑旁就睡着了 qwq六月有了世界上最好看的老婆海洋之星 但是打铜了呜呜七月留着暑假集训了 开心八月继续集训 好喜欢集训的日子 睡到中午然后去实验室打比赛/补题 很纯粹九月开始忙招新 cf rating 开始涨十月好像也没干嘛？可能是没比赛打心态有点小崩 不过养起来了各种好习惯十一月恢复训练了 cf 蓝了 睡了两次实验室 开始忙 d3 的稿 两头跑累死十二月cf1802了 当上了副队其实每天都一样 很普通 普通到一眨眼 2019 就已经过去了对于 acm 有过迷茫 有过挣扎 有过痛苦 但更多的还是热爱吧 “如果你觉得打 acm 痛苦多于快乐 那才算不适合” 希望 wenzhuan 继续加油 希望 cf 稳在 1800 还希望自己能当一个独当一面的选手 保证单刷稳铜 qwqqq有在看我博客的 新年快乐呀 嘻嘻","categories":[{"name":"w&y","slug":"w-y","permalink":"http://wzgshyvin.github.io/categories/w-y/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://wzgshyvin.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"哈理工2019新生赛解题报告","slug":"哈理工2019新生赛解题报告","date":"2019-12-21T07:30:28.000Z","updated":"2021-01-26T16:43:12.585Z","comments":true,"path":"2019/12/21/哈理工2019新生赛解题报告/","link":"","permalink":"http://wzgshyvin.github.io/2019/12/21/%E5%93%88%E7%90%86%E5%B7%A52019%E6%96%B0%E7%94%9F%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"没啥好写的但毕竟也是ak了","text":"没啥好写的但毕竟也是ak了 来看压行小天才的表演 A: 会长的烦心事题目链接 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int len[15];int change(char c)&#123; if(c==&#x27;l&#x27;) return 0; if(c==&#x27;e&#x27;) return 1; if(c==&#x27;a&#x27;) return 2; if(c==&#x27;g&#x27;) return 3; if(c==&#x27;u&#x27;) return 4; if(c==&#x27;o&#x27;) return 5; if(c==&#x27;f&#x27;) return 6; return 7;&#125;int main()&#123; string s; while(cin&gt;&gt;s)&#123; int n=s.length(); rep(i,0,7) len[i]=0; rep(i,0,n) len[change(s[i])]++; len[0]/=2; len[1]/=2; int mn=1e9; rep(i,0,7) mn=min(mn,len[i]); cout&lt;&lt;mn&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; B: 快来秒掉我！题目链接嗯！第一次写php（逃 1Do you want to play ACM?(yes\\no) C: 素数圆环题目链接暴搜 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int n,cas,ans[25],vis[25];int p[25]=&#123;0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1&#125;;void dfs(int x)&#123; if(x&gt;n&amp;&amp;p[ans[n]+1]) rep(i,1,n+1) cout&lt;&lt;ans[i]&lt;&lt;(char)(i==n?&#x27;\\n&#x27;:&#x27; &#x27;); if(x&lt;=n) rep(i,2,n+1) if(!vis[i]&amp;&amp;p[i+ans[x-1]])&#123; vis[i]=1; ans[x]=i; dfs(x+1); vis[i]=0; &#125;&#125;void solve()&#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;++cas&lt;&lt;&quot;:\\n&quot;; ans[1]=1; if(n%2==0) dfs(2); cout&lt;&lt;&#x27;\\n&#x27;;&#125;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) solve();&#125; D: 电脑磨损程度题目链接委屈，它卡cout精度 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int solve(int n)&#123; if(n&lt;=4) return cout&lt;&lt;10&lt;&lt;&#x27;\\n&#x27;,0; int r=n%8,c=n/8; if(!r) return cout&lt;&lt;c*18&lt;&lt;&#x27;\\n&#x27;,0; if(r==1) return cout&lt;&lt;c*18+2&lt;&lt;&quot;.4&quot;&lt;&lt;&#x27;\\n&#x27;,0; if(r==2) return cout&lt;&lt;c*18+4&lt;&lt;&quot;.8&quot;&lt;&lt;&#x27;\\n&#x27;,0; if(r==3) return cout&lt;&lt;c*18+7&lt;&lt;&quot;.2&quot;&lt;&lt;&#x27;\\n&#x27;,0; if(r==4) return cout&lt;&lt;c*18+9&lt;&lt;&quot;.6&quot;&lt;&lt;&#x27;\\n&#x27;,0; return cout&lt;&lt;c*18+10+(r-4)*2&lt;&lt;&#x27;\\n&#x27;,0;&#125;int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n) solve(n);&#125; E: ACMer如何拯救小学生题目链接 123456789101112#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;string s;int main()&#123; int _; cin&gt;&gt;(_); getchar(); while(_--)&#123; getline(cin,s); int n=s.length(); string t=&quot;&quot;; t+=toupper(s[0]); rep(i,1,n)&#123; if(s[i-1]==&#x27; &#x27;&amp;&amp;s[i]!=&#x27; &#x27;) t+=toupper(s[i]); &#125; cout&lt;&lt;t&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; F: 当会长和一群手贱的耗子在电梯相遇题目链接算因数个数 123456789101112#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(ll i=s; i&lt;e; ++i)using namespace std;typedef long long ll;void solve(ll n)&#123; ll cnt(0); rep(i,1,1e8)&#123; if(i*i&gt;n) break; if(n%i==0) cnt+=i*i==n?1:2; &#125; puts(cnt&amp;1?&quot;Goddess,I&#x27;m coming~~~&quot;:&quot;Farewell~&quot;);&#125;int main()&#123; ll n; while(cin&gt;&gt;n&amp;&amp;n) solve(n);&#125; G: ACMer分奖金题目链接 1234567891011121314#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int main()&#123; int _; cin&gt;&gt;_; while(_--)&#123; int num[10]; rep(i,0,6) num[i]=0; int n; cin&gt;&gt;n; rep(i,0,n)&#123; int a; cin&gt;&gt;a; num[0]+=a/100; a%=100; num[1]+=a/50; a%=50; num[2]+=a/20; a%=20; num[3]+=a/10; a%=10; num[4]+=a/5; a%=5; num[5]+=a; &#125; int sum(0); rep(i,0,6) sum+=num[i]; cout&lt;&lt;sum&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; H: 放轻松题目链接 12345678910#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;double a[15];int main()&#123; int n; while(cin&gt;&gt;n)&#123; rep(i,0,n) cin&gt;&gt;a[i]; sort(a,a+n); rep(i,0,n) printf(&quot;%.2lf &quot;,a[i]); cout&lt;&lt;&#x27;\\n&#x27;; &#125;&#125; I: ACM协会晚会题目链接组合数 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;const int mod = 1e18;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1,y=0; return; &#125; else&#123; exgcd(b,a%b,y,x); y-=(a/b)*x; return; &#125;&#125;ll C(int s,int x)&#123; if(s&gt;x-s) s=x-s; ll ans=1,tmp=1,xx,y; rep(i,1,s+1) ans=ans*(x-i+1)%mod,tmp=tmp*i%mod; exgcd(tmp,mod,xx,y); ans=(ans*xx%mod+mod)%mod; return ans;&#125;int solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; if(m&gt;n) return puts(&quot;0&quot;); return cout&lt;&lt;C(m,n)&lt;&lt;&#x27;\\n&#x27;,0;&#125;int main()&#123; int _; cin&gt;&gt;_; while(_--) solve();&#125; J: 会长爱旅游题目链接bfs 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 1e5 + 5;vector&lt;int&gt;vv[maxn];int vis[maxn],ans[maxn];void bfs(int s)&#123; queue&lt;int&gt;q; q.push(s); while(!q.empty())&#123; int fr=q.front(); q.pop(); for(int t:vv[fr]) if(!vis[t]) vis[t]=1,ans[t]=fr,q.push(t); &#125;&#125;int main()&#123; int _; cin&gt;&gt;_; while(_--)&#123; int n,s; cin&gt;&gt;n&gt;&gt;s; mst(vv,0); rep(i,1,n)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; vv[x].push_back(y); vv[y].push_back(x); &#125; ans[s]=-1; vis[s]=1; bfs(s); rep(i,1,n+1) cout&lt;&lt;ans[i]&lt;&lt;(char)(i==n?&#x27;\\n&#x27;:&#x27; &#x27;); &#125;&#125; 压行选手是这么牛逼的","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"}]},{"title":"余心往期graffiti归档","slug":"余心graffiti作品集","date":"2019-12-15T04:00:11.000Z","updated":"2021-02-22T16:14:59.442Z","comments":true,"path":"2019/12/15/余心graffiti作品集/","link":"","permalink":"http://wzgshyvin.github.io/2019/12/15/%E4%BD%99%E5%BF%83graffiti%E4%BD%9C%E5%93%81%E9%9B%86/","excerpt":"持续更新。","text":"持续更新。 上海 17.9graffiti初尝试 风格模仿很像土嗨= = MATURITY 17.9风格模仿配色还是ok的意为理性成熟 调侃高三的班主任 Monster 17.11经 典 配 色用了好几年的头像 浙江 18.7新学校在浙江了那就 ZXJ 18.8爱上了cdr喜欢过的人的名字缩写 后来做成了衣服 HDU 18.12第一次户外涂鸦 Respite 18.12.31第一次真·上墙坐标：31号楼地下车库btw 车也是自己漆的 HDUART 19.3-19.4和学姐一起的涂墙！自己只做了一小点点点","categories":[{"name":"y","slug":"y","permalink":"http://wzgshyvin.github.io/categories/y/"}],"tags":[{"name":"design","slug":"design","permalink":"http://wzgshyvin.github.io/tags/design/"}]},{"title":"余心往期字设归档","slug":"余心字设作品集","date":"2019-12-15T03:59:39.000Z","updated":"2021-02-22T16:46:55.939Z","comments":true,"path":"2019/12/15/余心字设作品集/","link":"","permalink":"http://wzgshyvin.github.io/2019/12/15/%E4%BD%99%E5%BF%83%E5%AD%97%E8%AE%BE%E4%BD%9C%E5%93%81%E9%9B%86/","excerpt":"持续更新。","text":"持续更新。 2017AM 山鬼 Respite 怒放 青山见我 世界和平合唱节 第一次做仿凹凸风 凹凸相关 更多见余心的lofter 林余心仿风格 THREE班服稿 清平乐粗糙指绘 清鹤体“参加方正字体设计比赛是我的梦想，只要参加就够了”很羡慕当时的热情 2018平心静气 扇子高考前的摸鱼 莲子清如水 疏狂 2019HGAME logo最开始搞了朴素和炫彩两版现在每年logo都会换一个底2020 hgame2021 hgame HDUACM集训队logo我自己感觉不好看了 不过队员挺喜欢的 Vidar-Team 2019夏季会服ai拼笔刷 痛苦痛苦 灵感 Vidar-Team 2019招新海报兔子好难画（为了海报把兔设做出来了） D^3CTF相关自己设计的logo 其他主要靠字体和模板 Vidar-Team 2019秋冬会服yyds好吧 yyds 2020Hgame 2020海报第一次接触照片调色 新清平乐 Accepted队服～ 附中应援大字是力扬的 正看倒看都一样的字体 小字（水印）才是我的233 不好意思放太多张了 就放一张底也是自己拍的吧 高考应援 草书千字文其实只是临摹 小燕生贺他当时的个性签名 一路顺风济南前祝我们bonvoyage一路顺风（然后他们金了 好耶） 江纠郎课程作业","categories":[{"name":"y","slug":"y","permalink":"http://wzgshyvin.github.io/categories/y/"}],"tags":[{"name":"design","slug":"design","permalink":"http://wzgshyvin.github.io/tags/design/"}]},{"title":"Codeforces Round #604解题报告","slug":"Codeforces-Round-604解题报告","date":"2019-12-06T03:53:26.000Z","updated":"2021-01-26T16:41:02.354Z","comments":true,"path":"2019/12/06/Codeforces-Round-604解题报告/","link":"","permalink":"http://wzgshyvin.github.io/2019/12/06/Codeforces-Round-604%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"突然想更博呗","text":"突然想更博呗 rk553 rating+35一边打一边看学弟改的稿子233 有点小炸下辈子再也不倒开了.jpg A: Beautiful String题目链接题意：希望构造一个邻位不相同的只有abc的字符串 给定一个带有’?’的串 ‘?’可以任意替换为abc 问能不能构造出符合要求的串一开始被卡了一下 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define sc(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e5 + 5;char s[maxn];int solve()&#123; scs(s); int len=strlen(s); if(s[0]==&#x27;?&#x27;&amp;&amp;s[1]!=&#x27;a&#x27;) s[0]=&#x27;a&#x27;; else if(s[0]==&#x27;?&#x27;) s[0]=&#x27;b&#x27;; if(s[len-1]==&#x27;?&#x27;&amp;&amp;s[len-2]!=&#x27;a&#x27;) s[len-1]=&#x27;a&#x27;; else if(s[len-1]==&#x27;?&#x27;) s[len-1]=&#x27;b&#x27;; rep(i,1,len-1) if(s[i]==&#x27;?&#x27;)&#123; if(s[i-1]==&#x27;a&#x27;)&#123; if(s[i+1]!=&#x27;b&#x27;) s[i]=&#x27;b&#x27;; else s[i]=&#x27;c&#x27;; &#125; else&#123; if(s[i+1]!=&#x27;a&#x27;) s[i]=&#x27;a&#x27;; else if(s[i-1]==&#x27;b&#x27;) s[i]=&#x27;c&#x27;; else s[i]=&#x27;b&#x27;; &#125; &#125; rep(i,1,len) if(s[i-1]==s[i]) return puts(&quot;-1&quot;); pf(&quot;%s\\n&quot;,s); return 0;&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; B: Beautiful Numbers题目链接题意：给定n和初始序列 问在1到n中的i有哪些满足在初始序列中存在区间长度为i且区间内只有1-i的数真好写啊 我为什么不先写B判一下左右就行 写得复杂了一点 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define sc(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[maxn],ans[maxn];pii p[maxn];int solve()&#123; int n,pos; sc(n); rep(i,1,n+1)&#123; sc(a[i]); p[i].first=a[i]; p[i].second=i; &#125; sort(p+1,p+n+1); ans[1]=1; int l=1e9,r=0; rep(i,1,n+1)&#123; l=min(l,p[i].second); r=max(r,p[i].second); if(r-l&gt;=i) ans[i]=0; else if(r-l&lt;i) ans[i]=1; else ans[i]=0; &#125; rep(i,1,n+1) pf(&quot;%d&quot;,ans[i]); pf(&quot;\\n&quot;);&#125;int main()&#123; int _; sc(_); while(_--) solve();&#125; C: Beautiful Regional Contest题目链接题意：分金银铜牌 规则是获得金牌的人题数严格大于得银牌的 银牌的严格大于铜牌的 金牌数严格小于银牌数和铜牌数 三个牌子的总和不多于总人数的一半 给定人数和过题数 希望牌子尽量多 输出方案贪心 金牌只取最多过题数的人数 银牌取到比金牌多就break 铜剩下 判是否符合要求 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 1e6 + 5;int a[maxn],vis[maxn];int main()&#123; int _; sc(_); while(_--)&#123; int n,a0; sc(n); sc(a0); rep(i,0,a0+1) vis[i]=0; a[1]=a0; vis[a0]++; rep(i,2,n+1) sc(a[i]),vis[a[i]]++; int mid=n/2; if(a[mid]==a[mid+1])&#123; while(a[mid]==a[mid+1]) mid--; &#125; int aa,b=0,c=0; aa=vis[a0]; dep(i,a0-1,0) if(vis[i])&#123; b+=vis[i]; if(b&gt;aa) break; &#125; if(b&lt;=aa||aa+b&gt;=mid)&#123; pf(&quot;0 0 0\\n&quot;); continue; &#125; c=mid-aa-b; if(c&lt;=aa)&#123; pf(&quot;0 0 0\\n&quot;); continue; &#125; pf(&quot;%d %d %d\\n&quot;,aa,b,c); &#125;&#125; D: Beautiful Sequence题目链接题意：给abcd四个数 代表有a个0 b个1 c个2 d个3 问能不能构成相邻位差值绝对值为1的序列本来以为是细节题 思维还是不够缜密很多请况没考虑到233看了dls代码 写的是按题意模拟 真好看啊 wxhtxdytxdy 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;int a[5],b[5];vector&lt;int&gt;vv; int main()&#123; rep(i,0,4) sc(a[i]); rep(i,0,4)&#123; rep(j,0,4) b[j]=a[j]; if(!b[i]) continue; int x=i; vv.clear(); while(1)&#123; vv.push_back(x); b[x]--; if(x&amp;&amp;b[x-1]) x--; else if(x!=3&amp;&amp;b[x+1]) x++; else break; &#125; if(!b[0]&amp;&amp;!b[1]&amp;&amp;!b[2]&amp;&amp;!b[3])&#123; pf(&quot;YES\\n&quot;); rep(i,0,vv.size()) pf(&quot;%d &quot;,vv[i]); return pf(&quot;\\n&quot;),0; &#125; &#125; return pf(&quot;NO\\n&quot;),0;&#125; E: Beautiful Mirrors题目链接文字先咕了 好困 随缘更 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e5 + 5;const int mod = 998244353;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1) ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;ll a[maxn],q1[maxn],q2[maxn];int main()&#123; int n; sc(n); rep(i,0,n) scl(a[i]); ll t=qpow(100,mod-2); q1[n]=q2[n]=0; dep(i,n-1,0)&#123; q1[i]=a[i]*t%mod*q1[i+1]%mod; q1[i]++; q1[i]%=mod; q2[i]=a[i]*t%mod*q2[i+1]%mod; q2[i]+=t*(100-a[i])%mod; q2[i]%=mod; &#125; ll ans=q1[0]*qpow((1-q2[0]+mod)%mod,mod-2)%mod; pf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://wzgshyvin.github.io/tags/Codeforces/"}]},{"title":"Codeforces Round #598解题报告","slug":"Codeforces-Round-598解题报告","date":"2019-11-06T05:35:17.000Z","updated":"2021-01-26T16:40:56.175Z","comments":true,"path":"2019/11/06/Codeforces-Round-598解题报告/","link":"","permalink":"http://wzgshyvin.github.io/2019/11/06/Codeforces-Round-598%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"全绿的第一场不好意思说是题解 就解题报告吧（天哪稳赚终于更博了","text":"全绿的第一场不好意思说是题解 就解题报告吧（天哪稳赚终于更博了 先反思一下 B这个傻逼暴力场上没调出来 真的弟弟这场+11 我什么时候上蓝啊555贪心场√ A: Payment Without Change题目链接题意：有a个n b个1 问能不能凑到s以为会炸int 赛后想了想好像也不会233 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)using namespace std;typedef long long ll;ll a,b,n,s;int solve()&#123; if(a*n+b&lt;s) return puts(&quot;NO&quot;),0; int x=min(a,s/n); if(x*n+b&gt;=s) return puts(&quot;YES&quot;),0; else return puts(&quot;NO&quot;),0;&#125;int main()&#123; int _; sc(_); while(_--)&#123; scl(a); scl(b); scl(n); scl(s); solve(); &#125;&#125; B: Minimize the Permutation题目链接题意：给定一个1~n的排列 要操作最多n-1次相邻位交换且每个位置只能交换一次 使最终结果序列字典序最小 输出此序列暴力莽 写得有点丑 一个活脱脱的&gt;号我开始压行后就没写过这么丑的代码 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[105],v[105];int main()&#123; int _; sc(_); while(_--)&#123; int n; sc(n); rep(i,1,n+1) sc(a[i]),v[i]=0; int c(0); rep(i,1,n+1)&#123; rep(j,1,n+1)&#123; if(a[j]==i)&#123; int k=j; while(k&gt;1)&#123; if(v[k]) break; if(a[k]&lt;a[k-1])&#123; swap(a[k],a[k-1]); c++; v[k]++; &#125; else break; k--; &#125; break; &#125; &#125; if(c==n) break; &#125; rep(i,1,n+1) pf(&quot;%d &quot;,a[i]); pf(&quot;\\n&quot;); &#125;&#125; C: Platforms Jumping题目链接题意：一道河长n 有m个木板 第i个木板长c[i] 人一次可以跳d格 问这个人能否过河 能的话输出方案贪心 判完YES后先让这个人一直跳尽量远 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;int a[1005],s;int main()&#123; int n,m,k; sc(n); sc(m); sc(k); rep(i,1,m+1) sc(a[i]),s+=a[i]; if(n-s&gt;(m+1)*(k-1)) pf(&quot;NO\\n&quot;); else&#123; int n1=n; pf(&quot;YES\\n&quot;); n-=s; n++; rep(i,1,m+2)&#123; int t=min(k,n); rep(j,0,t-1) pf(&quot;0 &quot;); rep(j,0,a[i]) pf(&quot;%d &quot;,i); n-=t-1; &#125; &#125;&#125; D: Binary String Minimizing题目链接题意：给定一个长度为n的01串 问交换最多k次后字典序最小的串是什么贪心 直接for一遍 不过还是写麻烦了233k没开ll wa了一次 qswl 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define pf printf#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, &amp;x)#define scl(x) scanf(&quot;%lld&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;typedef long long ll;const int maxn = 1e6 + 5;char s[maxn];vector&lt;int&gt;v;int main()&#123; int _; sc(_); while(_--)&#123; int n; ll k; sc(n); scl(k); scs(s); v.clear(); rep(i,0,n) if(s[i]==&#x27;0&#x27;) v.push_back(i); int pos(0); rep(i,0,n) if(s[i]==&#x27;0&#x27;) pos++; else break; rep(i,0,v.size())&#123; if(v[i]&lt;pos) continue; int t=min(1ll*v[i]-1ll*pos,k); if(t&lt;k) swap(s[v[i]],s[pos]); else swap(s[v[i]],s[v[i]-k]); k-=t; pos++; if(k&lt;=0) break; &#125; pf(&quot;%s\\n&quot;,s); &#125;&#125; E: Yet Another Division Into Teams题目链接题意：n个人每个人能力为a[i] 一个队的差距指最大值减最小值 要把这些人划分成k个至少3人的队 希望每个队差异总和最小 求总和 队数 成员划分是个dp 我看题解写的呜呜呜 没什么好说的 官方题解更好懂 wtcl 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define pf printf#define INF 0x3f3f3f3f#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define rep(i,s,e) for(int i=s; i&lt;e; ++i)#define dep(i,e,s) for(int i=e; i&gt;=s; --i)using namespace std;const int maxn = 2e5 + 5;pair&lt;int,int&gt;a[maxn];int dp[maxn],t[maxn],r[maxn];int main()&#123; int n,cnt(0); sc(n); rep(i,0,n) sc(a[i].first),a[i].second=i; sort(a,a+n); rep(i,1,n+1) dp[i]=INF; rep(i,0,n) rep(j,3,6)&#123; if(i+j&gt;n) break; if(dp[i+j]&gt;dp[i]+a[i+j-1].first-a[i].first)&#123; dp[i+j]=dp[i]+a[i+j-1].first-a[i].first; r[i+j]=i; &#125; &#125; int now=n; while(now)&#123; dep(i,now-1,r[now]) t[a[i].second]=cnt; cnt++; now=r[now]; &#125; pf(&quot;%d %d\\n&quot;,dp[n],cnt); rep(i,0,n) pf(&quot;%d &quot;,t[i]+1); pf(&quot;\\n&quot;);&#125; F: Equalizing Two Strings题目链接题意：给定串s和t 每次可以在s和t中翻转长度相同的子串 问是否有可能使s和t相同问施老师的 11-nb！翻转长度为len的区间可以等价为多次相邻交换 将字符串换成递增的 需要逆序对次 如果逆序对数相同或者差为偶数（换两次等同于不变）则可以 如果有一个串的字母有两个以上 这就可以和这个字母不受限地交换 所以也可以啊我说的啥啊 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define sc(x) scanf(&quot;%d&quot;, &amp;x)#define scs(x) scanf(&quot;%s&quot;, x)#define mst(a,x) memset(a, x, sizeof(a))#define rep(i,s,e) for(int i=s; i&lt;e; ++i)using namespace std;const int maxn = 2e5 + 5;int n,c[30],d[30];char s[maxn],t[maxn];int solve()&#123; int t1(0),t2(0); rep(i,0,n)&#123; c[s[i]-&#x27;a&#x27;]++,d[t[i]-&#x27;a&#x27;]++; rep(j,s[i]-&#x27;a&#x27;+1,26) t1+=c[j]; rep(j,t[i]-&#x27;a&#x27;+1,26) t2+=d[j]; &#125; rep(i,0,26) if(c[i]!=d[i]) return 0; rep(i,0,26) if(c[i]&gt;=2||d[i]&gt;=2) return 1; return (t1-t2)%2==0;&#125;int main()&#123; int _; sc(_); while(_--)&#123; sc(n); scs(s); scs(t); mst(c,0); mst(d,0); if(solve()) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://wzgshyvin.github.io/tags/Codeforces/"}]},{"title":"Java大数基本操作","slug":"Java大数基本操作","date":"2019-05-10T09:32:07.000Z","updated":"2021-01-26T16:41:15.222Z","comments":true,"path":"2019/05/10/Java大数基本操作/","link":"","permalink":"http://wzgshyvin.github.io/2019/05/10/Java%E5%A4%A7%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"试着整理我看Java的过程嗷","text":"试着整理我看Java的过程嗷 一直知道Java大数nb 一直口嗨学Java 一直没动机缘巧合之下 看到我rank10058 想快乐rank四位数 又懒得开新题 干脆Java搞个1042（求N!）先搜题解一行行搜看懂什么意思后交了我看的题解是BigDecimal 但这题BigInteger就行我后来也BigInteger过了下面就放BigInteger的ac代码了=。= 1234567891011121314151617181920212223import java.math.BigInteger; import java.util.Scanner;// 大数头文件和输入头文件public class Main &#123; public static void main(String[] args) &#123; // 格式吧 Scanner sc = new Scanner(System.in); // Scanner输入 这应该就是一句标准格式吧233 while(sc.hasNext())&#123; // while(有输入) BigInteger n = sc.nextBigInteger(); // 格式 BigInteger m=new BigInteger(&quot;1&quot;); // 格式 for(int i=2;i&lt;=n.intValue();i++)&#123; // 一个挺c的for m = m.multiply(BigInteger.valueOf(i)); // 函数格式 &#125; System.out.println(m.toString()); // 转成字符串输出 不过不转也行 &#125; &#125;&#125; 真·一行一注释了！看懂了就 快乐交题 ac++; rank=9949;然后去魔改代码 用在线编译跑 整自闭了 还是下了IDEA配了环境 啊要死不过当时没选好题 没选水的然后搜索关键词：hdoj 大数 Javaget到hdoj上的Java大数水题 BigInteger的有1002 // 两个大数相加1047 // 大数累加1715 // 求斐波那契 直接大数相加1316 // 求区间有几个斐波那契数 大数加完for一遍1297 // 递推+大数加法然后 BigInteger基本函数： 1234567891011121314151617181920212223242526BigInteger a, b;a = BigInteger.valueOf(b); // a=b;int c;a = BigInteger.valueOf(c); // 类型转换String s = &quot;111&quot;;a = BigInteger.valueOf(s); // 运行后a==111;a = BigInteger(&quot;111&quot;); // 赋值常量a = sc.nextInteger(); // 赋值输入a = a.add(b); // a+=b;a = a.subtract(b); // a-=b;a = a.multiply(b); // a*=b;a = a.divide(b); // a/=b;/* 函数里的值也是BigInteger 如果是具体数值 格式：a.add(new BigInteger(&quot;1&quot;));是前面变量 格式：a.add(BigInteger.valueOf(i));特殊的 0 1 10 可以用BigInteger.ZERO\\ONE\\TEN;*/if(a.compareTo(b)&gt;0) System.out.println(a&gt;b); if(a.compareTo(b)==0) System.out.println(a==b);if(a.compareTo(b)&lt;0) System.out.println(a&lt;b);remainder(); mod(); // 都是a%bpow(); gcd(); // a^b 最大公约数abs(); negate(); // 绝对值 相反数max(); min();// 定义数组格式BigInteger array[]=new BigInteger[maxn]; 然后BigDecimal 12345678import java.math.BigDecimal; // 头文件BigDecimal a, b;a = sc.nextBigDecimal();a = new BigDecimal(111);a = new BigDecimal(b);// 函数和BigInteger差不太多嗷 就有的语法有的小小区别System.out.println(a.stripTrailingZeros().toPlainString());// 这个是 输出时去除多余末尾0 好用！！ hdoj BigDecimal水题首先BigInteger的用BigDecimal应该也能做？1753 // 加法2054 // 比较1063 // a^b问题然后说点题外话？配完Java环境后我发现我的hexo命令不能用辽 Google后跟着教程是 在高级系统设置中的环境变量的PATH加了node_modules\\.bin和nodejs的路径 就可以辣！","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"Java","slug":"Java","permalink":"http://wzgshyvin.github.io/tags/Java/"}]},{"title":"杭师校赛I题-Little Sub and Enigma AC代码","slug":"Little-Sub-and-Enigma题解","date":"2019-03-18T02:13:12.000Z","updated":"2021-01-26T16:41:23.120Z","comments":true,"path":"2019/03/18/Little-Sub-and-Enigma题解/","link":"","permalink":"http://wzgshyvin.github.io/2019/03/18/Little-Sub-and-Enigma%E9%A2%98%E8%A7%A3/","excerpt":"不难 听了出题人讲思路马上就会 但我就是要搞题解 纪念我的赛场自闭四小时","text":"不难 听了出题人讲思路马上就会 但我就是要搞题解 纪念我的赛场自闭四小时 最坑的是25对推第26对双向映射一一对应直接数组存感觉也许是输在英语不好？ 题目：Little Sub and Enigma DescriptionLittle Sub builds a naive Enigma machine of his own. It can only be used to encrypt/decrypt lower-case letters by giving each letter a unique corresponding lower-case letter. In order to ensure the accuracy, no contradiction or controversy is allowed in both the decryption and the encryption, which means all lower-case letters can only be decrypted/encrypted into a distinct lower-case letter.Now we give you a string and its encrypted version. Please calculate all existing corresponding relationship which can be observed or deducted through the given information.InputThe first line contains a string S, indicating the original message.The second line contains a string T , indicating the encrypted version.The length of S and T will be the same and not exceed 1000000.Outputwe use a string like ’x-&gt;y’ to indicate that letter x will be encrypted to letter y.Please output all possible relationships in the given format in the alphabet order.However, if there exists any contradiction in the given information, please just output Impossible in one line.AuthorYE, Zicheng 放一下出题人，zjunb AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int a[27], b[27];string s1, s2;int main() &#123; while (cin &gt;&gt; s1 &gt;&gt; s2) &#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); int flag = 0; for (int i = 0; i &lt; s1.length(); i++) &#123; int t1, t2; t1 = s1[i] - &#x27;a&#x27; + 1; t2 = s2[i] - &#x27;a&#x27; + 1; if (!a[t1]) a[t1] = t2; else if (a[t1] != t2) &#123; cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; flag = 1; break; &#125; if (!b[t2]) b[t2] = t1; else if (b[t2] != t1) &#123; cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; flag = 1; break; &#125; //复读，双向存 &#125; if (flag) continue; //上面break的是for，还需要一个continue，晕了 int ai, bi = 0; int cnt = 0; for (int i = 1; i &lt;= 26; i++) &#123; if (a[i] == 0) cnt++, ai = i; if (cnt &gt;= 2) continue; &#125; if (cnt == 1) for (int i = 1; i &lt;= 26; i++) if (b[i] == 0) bi = i; if (bi) a[ai] = bi;//25推26 for (int i = 1; i &lt;= 26; i++) &#123; if (a[i] ) &#123; char tmp1, tmp2; tmp1 = i - 1 + &#x27;a&#x27;; tmp2 = a[i] - 1 + &#x27;a&#x27;; cout &lt;&lt; tmp1 &lt;&lt; &quot;-&gt;&quot; &lt;&lt; tmp2 &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 其他题莫得了 太菜了","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"}]},{"title":"ZSTUoj 4433-Suffix Zeroes（暴力枚举）","slug":"Suffix-Zeroes题解","date":"2019-03-16T13:01:55.000Z","updated":"2021-02-22T15:23:01.427Z","comments":true,"path":"2019/03/16/Suffix-Zeroes题解/","link":"","permalink":"http://wzgshyvin.github.io/2019/03/16/Suffix-Zeroes%E9%A2%98%E8%A7%A3/","excerpt":"这两天和队友聊了一下理工新生赛，提到我暴力枚举A掉的这题，干脆搞个题解了时效性确实是 过了","text":"这两天和队友聊了一下理工新生赛，提到我暴力枚举A掉的这题，干脆搞个题解了时效性确实是 过了 题目：Suffix Zeroes Description这个游戏超休闲的~。现在你需要找一个自然数 n ，你找的自然数需要满足 n! 的末尾恰好有 k 个 0（当然我们都是十进制下的数，n! = 123…n）。比如：5！= 120，尾部恰好有一个 0 。Input先输入 T ，代表有 T 组数据（T ≤10000）接下来的T行每一行都包括一个数字 k（1≤k≤108）。具体含义请见题意。Output如果能找到这样的数，请输出满足条件的最小的自然数 n ，如果不存在这样的自然数，请输出 impossible 。Sample Input215Sample OutputCase 1: 5Case 2: impossible 首先，题目意思就是找 5（ 2 比 5 多很多所以不必考虑 2 ），有几个 0 就是有几个 5 25 算两个 5 ，50 算两个，125 算三个 所以可以很直接地得到一个式子 mx 等于 10 其实差不多了，我下面代码写得花里胡哨的 mx 是一开始因为 tle 的改动，现在想想就 10 能改变什么 再整理得 即有 mx 越大，ans 越接近 4×k（用星号会用奇奇怪怪的问题所以不用了） 等 mx=10 的时候，5^mx 接近 1e8，这个时候 ans 也不会比 4×k 大多少，所以可直接暴力枚举： AC代码12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main() &#123; int T, b = 1, mx, d = 1; int k, k1 = 0, flag = 0, ans; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%d&quot;, &amp;k); printf(&quot;Case %d: &quot;, d++); mx = floor(log(k * 5) / log(5)); for (int i = k * 4; i &lt;= k * 4 + 100; i++) &#123; for (int j = 1; j &lt;= mx; j++) &#123; b = b * 5; k1 += (i / b); &#125; b = 1; if (k1 == k) &#123; printf(&quot;%d\\n&quot;, i); flag = 1; break; &#125; k1 = 0; &#125; if (flag == 0) printf(&quot;impossible\\n&quot;); flag = k1 = 0; &#125; return 0;&#125; 类似有一题，是在 HDU 的 HelloWorld 社团的比赛上（但是这题贼简单）： 题目2：这是一道简单的数学题 Problem Description“今晚你会成为我的人！”电视里传出这样的声音，小明和小红执手相看，含情脉脉，四目相对。小红红着脸：“你爱我吗？”小明：“当然！”小红：“那你能告诉我你有多少个前女友吗？”小明：“别问，问就爆炸。”小红：“老娘给你脸了，说！！！”小明脑补着该说有几个比较合适，他知道小红有个习惯，就是特别喜欢不断重复计算 n∗n∗n 里有多少个 9 ，于是，他开始不断枚举 n ，以便让小红沉迷于计算，而不追究。小红对于n里有多少个 9 的定义：从1到n的每一个数能整除 9 的次数相加，如：9 里有一个 9（9/9），18 里有两个 9（9/9，18/9），81 里有 10 个 9（9/9，18/9，27/9，36/9，45/9，54/9，63/9，72/9，81/9/9）Input多组测试数据，每组占一行。每行一个n（1&lt;=n&lt;=100000）Output每行输出一个整数，表示 n∗n∗n 中有多少个 9Sample Input134Sample Output037 AC代码1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;int main() &#123; long long n, c, a = 1,ans=0; while (~scanf(&quot;%lld&quot;, &amp;n)) &#123; c = pow(n, 3); for (int i = 1; i &lt; 18; i++) &#123; a *= 9; ans = ans + (c / a); &#125; printf(&quot;%lld\\n&quot;, ans); a = 1; ans = 0; &#125; return 0;&#125;","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"zstuoj","slug":"zstuoj","permalink":"http://wzgshyvin.github.io/tags/zstuoj/"}]},{"title":"noip模拟-确定的位置（map + vector）","slug":"确定的位置-题解","date":"2019-03-16T03:19:23.000Z","updated":"2021-01-26T16:43:25.834Z","comments":true,"path":"2019/03/16/确定的位置-题解/","link":"","permalink":"http://wzgshyvin.github.io/2019/03/16/%E7%A1%AE%E5%AE%9A%E7%9A%84%E4%BD%8D%E7%BD%AE-%E9%A2%98%E8%A7%A3/","excerpt":"想清楚了就不难这题还是在c程上机课的时候a掉的","text":"想清楚了就不难这题还是在c程上机课的时候a掉的 还是aaa和vv的命名，本家独创还是只会举例论证，wztcl 题目：确定的位置 描述hzy很喜欢了解歌曲的排行榜，他每次都从XX网站获知。由于这个网站想对这个歌曲的排行榜含蓄的告诉大家，组织了一个“猜榜大赛”。这个网站宣布一些歌曲的信息，那些歌曲在歌曲榜上的前几名，例如：·”qianlizhiwai” 是在榜上的前三名·”qianlizhiwai”,”dachengxiaoai” 是在歌曲榜的前两名网站不会把歌曲的名次十分明确的告诉你，他就是想让你通过这些信息，推出一部分歌曲的名次，现在困惑的hzy找您帮忙，想让您推出所有确定名次的歌曲。输入第一行包括一个整数n, 1≤n≤500，表示网站给你的信息的条数。下面n行包括一条信息，形式为”A and B song1 song2 song3 … songA”,1≤A≤B≤100，表示”song1”,”song2”,…,”songA”是在歌曲榜的前B位。每一首歌都是一个string,由最多25个小写字母组成。输出输出可以知道的所有的歌的排名，形式:”Position Song”位置必须有序。输入样例 121 and 3 lonely2 and 2 trebami jasekonja输出样例 13 lonely输入样例 232 and 2 pjesma1 pjesma23 and 4 pjesma1 pjesma3 pjesma41 and 3 pjesma4输出样例 23 pjesma44 pjesma3 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#define INF 0xfffffffusing namespace std;int n, m, k;int a, b, c, d;int sum, ans, num, cnt[105];string s, sa, sb;map&lt;string, int&gt;aaa;vector&lt;string&gt;vv[105];vector&lt;string&gt;::iterator it;int main() &#123; num = 0; aaa.clear(); for (int i = 1; i &lt; 105; i++) vv[i].clear(); cin &gt;&gt; n; int tmp = INF; while (n--) &#123; cin &gt;&gt; k &gt;&gt; s &gt;&gt; m; while (k--) &#123; cin &gt;&gt; s; if (!aaa[s]) aaa[s] = m, vv[m].push_back(s); else if (aaa[s] &gt; m)&#123; for(it=vv[aaa[s]].begin();it!=vv[aaa[s]].end();) if(*it==s) it=vv[aaa[s]].erase(it); else it++; vv[m].push_back(s); aaa[s] = m; &#125; &#125; &#125; for (int i = 1; i &lt; 105; i++)&#123; num+=vv[i].size(); //没有num遇到1 1 and 3 lonely这种情况会输出3 lonely（正确是没有输出） if (vv[i].size() == 1&amp;&amp;num==i) cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; vv[i][0] &lt;&lt; endl; &#125; return 0;&#125; 感觉没什么太难理解的不必要打什么注释= =","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"队内训练","slug":"队内训练","permalink":"http://wzgshyvin.github.io/tags/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%83/"}]},{"title":"震惊！原来这就是万恶之源！","slug":"是题解哦","date":"2019-03-14T14:11:59.000Z","updated":"2020-03-02T07:19:13.238Z","comments":true,"path":"2019/03/14/是题解哦/","link":"","permalink":"http://wzgshyvin.github.io/2019/03/14/%E6%98%AF%E9%A2%98%E8%A7%A3%E5%93%A6/","excerpt":"G题正确率跌破5%，ID为HDU8的用户刷屏提交记录四页，这一切的背后，到底是人性的灭亡，还是道德的沦丧……","text":"G题正确率跌破5%，ID为HDU8的用户刷屏提交记录四页，这一切的背后，到底是人性的灭亡，还是道德的沦丧…… 因为这道题没有出现在除去我们比赛的其他oj里（至少我没搜到），来看的估计都是熟人，我就放飞自我辽。 这题我交了六十多次……太倔强了，我为自己鼓鼓掌 A掉的时候贼高兴，所以就想搭个博客，所以G题就是万恶之源（严肃） WARNING：有用map，map名字叫aaa，可能引起阅读不适（但我就是不改这多有特点啊）；只会举例论证，语言逻辑不太行 题目：化学方程式 描述102班每天要写化学方程式，现在要想办法批改方程式。方程式中反应物的顺序可以不一样，中间可以有空格。不会出现沉淀和气体符号和反应条件。错误有系数不对（下标不对，如CO2为CO3也算系数不对。反应物或生成物中不会出现元素相同，系数不同的化学式，如：CO和CO2不会一起出现在反应物或生成物中），化学式错误，缺少反应物，两边元素不守恒。输入第一排输入N,M第二排输入长度为N的字符串为正确方程式第三排输入长度为M的字符串为要批改方程式输出正确输出RIGHT错误第一排输出WRONG，第二排输出错误原因（只系数不对为1，其他错误和有两个以上错误为2）输入样例 134 292Na O H + H2S O4 = Na 2 S O4+2H2OH2S O4 +2NaO H =Na2 S O4+2H2O输出样例 1RIGHT输入样例 234 252Na O H + H2S O4 = Na 2 SO4 +2H2OH2S O4 +NaO H=2H2O +2 K Cl输出样例 2WRONG2 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#define INF 0xfffffffusing namespace std;int n, m, k;int a, b, c, d;int sum, ans, num, cnt;string s, sa, sb;map&lt;string, int&gt;aaa;int main() &#123; cin &gt;&gt; n &gt;&gt; m; getchar(); cnt = 1; aaa.clear(); string s1[100], s2[100]; for (int i = 0; i &lt; 100; i++) s1[i] = &quot;&quot;, s2[i] = &quot;&quot;; while (1) &#123; s = getchar(); if (s == &quot;\\n&quot;) break; else if (s != &quot;+&quot;&amp;&amp;s != &quot;=&quot;&amp;&amp;s != &quot; &quot;) s1[cnt] += s; else if (s == &quot;+&quot;) cnt++; else if (s == &quot;=&quot;) a = cnt, cnt++;//a是存反应物和生成物的分隔 &#125; int tt = cnt; for (int i = 1; i &lt;= cnt; i++) &#123; sa = &quot;&quot;; aaa[s1[i]] = i; for (int j = 0; j &lt; s1[i].length(); j++) if (s1[i][j] &lt;= &#x27;0&#x27;||s1[i][j] &gt;= &#x27;9&#x27;) sa += s1[i][j];//去数字 if (!aaa[sa]) aaa[sa] = ++tt;//系数去掉后也存一下 &#125; int cnt2 = 1; int flag = 1;//flag设置为1是因为全对全错都比半对好考虑 sum = 0; int p[100]; memset(p, 0, sizeof(p)); while (1) &#123; s = getchar(); if (s == &quot;\\n&quot;) break; else if (s != &quot;+&quot;&amp;&amp;s != &quot;=&quot;&amp;&amp;s != &quot; &quot;) s2[cnt2] += s; else if (s == &quot;+&quot;) cnt2++; else if (s == &quot;=&quot;) b = cnt2, cnt2++; &#125;//复读机 if (cnt2 != cnt) flag = 2;//一二式方程式里物质数目不同直接错 for (int i = 1; i &lt;= cnt2; i++) &#123; sb = &quot;&quot;; if (flag == 2) break; for (int j = 0; j &lt; s2[i].length(); j++) if (s2[i][j] &lt;= &#x27;0&#x27;||s2[i][j] &gt;= &#x27;9&#x27;) sb += s2[i][j]; if (aaa[s2[i]] &amp;&amp; aaa[s2[i]] &lt;= cnt &amp;&amp; !p[aaa[s2[i]]]) sum++, p[aaa[s2[i]]] = 1;//包含系数物质的直接比较 和一式一样计数+标记 // aaa[s2[i]] &lt;= cnt的存在必要：如一式是2HCl二式是HCl // p[aaa[s2[i]]] = 1的存在必要：一式CO+CuO=Cu+CO2二式CO+CuO=Cu+CO else if (!aaa[sb]) flag = 2;//去掉系数了还没有存过肯定是错的了 if (aaa[s2[i]] &gt; a &amp;&amp; aaa[s2[i]] &lt;= cnt &amp;&amp; i &lt;= b) flag = 2; //判断生成物和反应物有没有跑错位子 &#125; if (flag == 1 &amp;&amp; sum == cnt) flag = 0; if (!flag) cout &lt;&lt; &quot;RIGHT&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;WRONG&quot; &lt;&lt; endl; if (flag) cout &lt;&lt; flag &lt;&lt; endl; return 0;&#125; 其实这题走了好多弯路，怪自己太瞎题目没看清（反思） 删删改改，从五六十加加加到百来行再删删删到七十行（然后再加加加注释） 这个解系数为1不能判断，不过讲道理化学方程式系数为1确实不写 CO2和CO3只是系数错了能把化学老师气死（也把我气死了，所以一开始是开了vector的） 比较常规而且又稳的解法应该是四个map+一个vector，顾老师好像就是这样不过他还分了单质啊什么的我也没细看= =反正我这个能A嘻嘻","categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"队内训练","slug":"队内训练","permalink":"http://wzgshyvin.github.io/tags/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%83/"}]},{"title":"相 逢 即 是 缘","slug":"一个置顶","date":"2019-03-13T09:13:12.000Z","updated":"2021-02-22T15:16:26.456Z","comments":true,"path":"2019/03/13/一个置顶/","link":"","permalink":"http://wzgshyvin.github.io/2019/03/13/%E4%B8%80%E4%B8%AA%E7%BD%AE%E9%A1%B6/","excerpt":"Like the meeting of the seagulls and the waves we meet and come near. The seagulls fly off, the waves roll away and we depart. ——《Stray Birds》Rabindranath Tagore","text":"Like the meeting of the seagulls and the waves we meet and come near. The seagulls fly off, the waves roll away and we depart. ——《Stray Birds》Rabindranath Tagore wz&amp;yx wz 是 wenzhuan 是已退役的菜鸡 ACMer Vidar-Team 的好美工 有最好看的键盘海洋之星 以后应该也会一直敲代码的 yx 是 yuxin 余心 悆字拆开 是希望自己快快乐乐 好久没动工的字体设计爱好者 字设/书法/Graffiti/绘画/剪纸/叶雕 初心 我两周前还说不想搞博客，飞快真香 最开始是写了一个猛题感觉自己好强想搞个题解 应该以后就会开始做题解和发作品 一是对自己成长的一个纪念吧 二是督促自己好好写题好好画画 三是希望更多人看到这么优秀的我 许几个愿 小转要天天开心 好好生活 好好学习计算机基础课！ 希望能有心仪的 offer","categories":[{"name":"w&y","slug":"w-y","permalink":"http://wzgshyvin.github.io/categories/w-y/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://wzgshyvin.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"w","slug":"w","permalink":"http://wzgshyvin.github.io/categories/w/"},{"name":"w&y","slug":"w-y","permalink":"http://wzgshyvin.github.io/categories/w-y/"},{"name":"y","slug":"y","permalink":"http://wzgshyvin.github.io/categories/y/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://wzgshyvin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"http://wzgshyvin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"ACM","slug":"ACM","permalink":"http://wzgshyvin.github.io/tags/ACM/"},{"name":"HDOJ","slug":"HDOJ","permalink":"http://wzgshyvin.github.io/tags/HDOJ/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://wzgshyvin.github.io/tags/Nowcoder/"},{"name":"随笔","slug":"随笔","permalink":"http://wzgshyvin.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"素材","slug":"素材","permalink":"http://wzgshyvin.github.io/tags/%E7%B4%A0%E6%9D%90/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://wzgshyvin.github.io/tags/Codeforces/"},{"name":"pintia","slug":"pintia","permalink":"http://wzgshyvin.github.io/tags/pintia/"},{"name":"hdoj","slug":"hdoj","permalink":"http://wzgshyvin.github.io/tags/hdoj/"},{"name":"板子","slug":"板子","permalink":"http://wzgshyvin.github.io/tags/%E6%9D%BF%E5%AD%90/"},{"name":"design","slug":"design","permalink":"http://wzgshyvin.github.io/tags/design/"},{"name":"Java","slug":"Java","permalink":"http://wzgshyvin.github.io/tags/Java/"},{"name":"zstuoj","slug":"zstuoj","permalink":"http://wzgshyvin.github.io/tags/zstuoj/"},{"name":"队内训练","slug":"队内训练","permalink":"http://wzgshyvin.github.io/tags/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%83/"}]}